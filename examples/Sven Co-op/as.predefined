//Type to store console command flags in;
typedef uint32 ConCommandFlags_t;
//Unix timestamp type.;
typedef uint64 time_t;
//Menu id.;
typedef int32 TextMenuId_t;
//Persistence object id type.;
typedef uint PersistID_t;
//Seek File Flags;
typedef uint8 SeekFileFlags_t;
//Open File Flags;
typedef uint8 OpenFileFlags_t;
//Size type used for denoting sizes;
typedef uint32 size_t;

class ref{}
funcdef bool less(const ?&in a, const ?&in b);
class array<T>{
	uint length() const;
	void resize(uint);
	void reverse();
	void insertAt(uint index, const T& in value);
	void insertAt(uint index, const array<T>& arr);
	void insertLast(const T& in);
	void removeAt(uint index);
	void removeLast();
	void removeRange(uint start, uint count);
	void sortAsc();
	void sortAsc(uint startAt, uint count);
	void sortDesc();
	void sortDesc(uint startAt, uint count);
	void sort(const less &in compareFunc, uint startAt = 0, uint count = uint(-1));
	int find(const T& in);
	int find(uint startAt, const T& in);
	int findByRef(const T& in);
	int findByRef(uint startAt, const T& in);
}
class any{
	//The default constructor creates an empty object, and the second initializes the object with the provided value.
	//The int64 and double overloads make sure that all numbers are converted to 64bit before being stored in the object.
	any();
	any(? &in value);
	any(int64 &in value);
	any(double &in value);
	//The assignment operator will copy the contained value from the other object.
	any &opAssign(const any &in other);
	//These methods sets the value in the object.
	//The int64 and double overloads make sure that all numbers are converted to 64bit before being stored in the object.
	void store(? &in value);
	void store(int64 &in value);
	void store(double &in value);
	//These methods retrieve the value stored in the object. The methods will return true if the stored value is compatible with the requested type.
	bool retrieve(? &out value) const;
	bool retrieve(int64 &out value) const;
	bool retrieve(double &out value) const;
}
class dictionary{
	//Sets a key/value pair in the dictionary. If the key already exists, the value will be changed.
	void set(const string &in key, ? &in value);
	void set(const string &in key, int64 &in value);
	void set(const string &in key, double &in value);
	//Retrieves the value corresponding to the key. The methods return false if the key is not found, and in this case the value will maintain its default value based on the type.
	bool get(const string &in key, ? &out value) const;
	bool get(const string &in key, int64 &out value) const;
	bool get(const string &in key, double &out value) const;
	//This method returns an array with all of the existing keys in the dictionary. The order of the keys in the array is undefined.
	array<string> @getKeys() const;
	//Returns true if the key exists in the dictionary.
	bool exists(const string &in key) const;
	//Removes the key and the corresponding value from the dictionary. Returns false if the key wasn't found.
	bool delete(const string &in key);
	//Removes all entries in the dictionary.
	void deleteAll();
	//Returns true if the dictionary doesn't hold any entries.
	bool isEmpty() const;
	//Returns the number of keys in the dictionary.
	uint getSize() const;
}
class dictionaryValue{}

//Listener for CountPlayersInBrushVolume.;
interface PlayerInVolumeListener {
	void PlayerDetected(const bool fInVolume, CBasePlayer@ pPlayer);
}
//Script class interface;
interface ScriptClassInterface {
}
//Module class.\nRepresents this module.;
class CModule {
	//Gets this module\'s script info object.;
	CScriptInfo@ get_ScriptInfo();
	//Gets the name of this module.;
	string GetModuleName() const;
}
//Script info object.\nContains script information.;
class CScriptInfo {
	//Sets the minimum admin level required for commands. You cannot lower the minimum level.;
	void SetMinimumAdminLevel(const AdminLevel_t minimumAdminLevel);
	//Gets the minimum admin level required for commands.;
	AdminLevel_t GetMinimumAdminLevel() const;
	//Sets the author\'s contact info.;
	void SetContactInfo(const string& in szContactInfo);
	//Gets the author\'s contact info.;
	const string& GetContactInfo() const;
	//Sets the author name.;
	void SetAuthor(const string& in szAuthor);
	//Gets the author name.;
	const string& GetAuthor() const;
}
//Module hook manager;
class CModuleHookManager {
	//Removes a hook. Pass in the hook function or delegate to remove.;
	void RemoveHook(uint uiHookCode, ?& in pHookFunction);
	//Removes all functions hooked into the given hook.;
	void RemoveHook(uint uiHookCode);
	//Registers a hook. Pass in a hook function or delegate.;
	bool RegisterHook(uint uiHookCode, ?& in pHookFunction);
}
//Survival Mode handler;
class CSurvivalMode {
	//Sets delay before survival mode starts.;
	void SetDelayBeforeStart( float value );
	//Returns delay before survival mode starts.;
	float GetDelayBeforeStart() const;
	//Can be used to end a round and force a retry to be used.;
	void EndRound();
	//Sets name of the next survival map.;
	void SetNextMap(const string& in szMapName);
	//Returns name of the next survival map.;
	const string& GetNextMap(void) const;
	//Returns whether Survival Mode should start when the map is loaded.;
	bool GetStartOn();
	//Sets whether Survival Mode should start when the map is loaded.;
	void SetStartOn( bool value );
	//Returns whether the current map supports Survival Mode or not.;
	bool MapSupportEnabled();
	//Tells the game that the current map wants to use Survival Mode. Should be called in MapInit. Cannot be disabled once set.;
	void EnableMapSupport();
	//Resets the Survival Mode vote state to undefined.;
	void ResetVoteState();
	//Toggles Survival Mode vote state.;
	void VoteToggle();
	//Returns Survival Mode vote state.;
	int GetVoteState();
	//Activate Survival Mode;
	void Activate( bool fActivateNow = false );
	//Returns whether Survival Mode is active or not.;
	bool IsActive() const;
	//Toggles Survival Mode.;
	void Toggle();
	//Disable Survival Mode;
	void Disable();
	//Enable Survival Mode;
	void Enable( bool fActivateNow = false );
	//Returns whether Survival Mode is enabled or not.;
	bool IsEnabled() const;
}
//Classic Mode handler;
class CClassicMode {
	//Gets the item mapped to the given item name, or an empty string if no mapping exists.;
	const string& FindItemMapping(const string& in szItemName) const;
	//Sets the item mappings to use from now on.\nDoes not affect previous mappings.\nPass null to disable all mappings.;
	void SetItemMappings(array<ItemMapping@>@ pItemMappings);
	//Sets whether the map should restart if Classic Mode is changed.;
	void SetShouldRestartOnChange(const bool bShouldRestart);
	//Returns whether the map should restart if Classic Mode is changed or not. Defaults to true if not changed by a script. Reset on map change.;
	bool ShouldRestartOnChange() const;
	//Tells the game that the current map wants to use Classic Mode. Must be called in MapInit. Cannot be disabled once set.This will ask players whether they want to enable Classic Mode. Reset on map change.;
	void EnableMapSupport();
	//Toggles Classic Mode.;
	void Toggle();
	//Forces item remapping even if classic mode is disabled.;
	void ForceItemRemap(const bool fEnabled);
	//Enable or disable Classic Mode.;
	void SetEnabled(const bool fEnabled);
	//Returns whether Classic Mode is enabled or not.;
	bool IsEnabled() const;
	//Resets the Classic Mode state setting to undefined.;
	void ResetState();
	//Returns whether the Classic Mode state setting is defined. If not defined, no voting has taken place to choose whether or not to enable Classic Mode.;
	bool IsStateDefined() const;
}
//Item mapping for classic mode.;
class ItemMapping {
	//Gets the To item name;
	const string& get_To() const;
	//Gets the From item name;
	const string& get_From() const;
	//Constructor;
	ItemMapping@ ItemMapping(const string& in szFrom, const string& in szTo);
}
//ClientSay parameters;
class SayParameters {
	//Sets whether this text will be hidden or not;
	void set_ShouldHide(bool fShouldHide);
	//Gets whether this text will be hidden or not;
	bool get_ShouldHide() const;
	//Gets the arguments in this command.;
	const CCommand@ GetArguments() const;
	//Gets the entire command string;
	const string& GetCommand() const;
	//Gets the say type of this text;
	ClientSayType GetSayType() const;
	//Gets the player that is saying something;
	CBasePlayer@ GetPlayer() const;
}
//Script console command manager.;
class CConCommandSystem {
	//Executes an Angelscript server command.;
	void ServerCommand(const string& in szCommand);
	//If the current command was executed by a player, this returns that player.;
	CBasePlayer@ GetCurrentPlayer() const;
}
//CVar class;
class CCVar {
	//Sets the given boolean as the value.;
	void SetBool(const bool bValue);
	//Sets the given integer as the value.;
	void SetInt(const int iValue);
	//Sets the given float as the value.;
	void SetFloat(const float flValue);
	//Sets the given string as the value.;
	void SetString(const string& in szValue);
	//Converts the value to a boolean.;
	bool GetBool() const;
	//Converts the value to an integer.;
	int GetInt() const;
	//Converts the value to a float.;
	float GetFloat() const;
	//Converts the value to a string.;
	const string& GetString() const;
	//Gets the default value for this cvar.;
	const string& GetDefaultValue() const;
	//Constructor;
	CCVar@ CCVar(const string& in szName, const string& in szValue, const string& in szHelpInfo = "", const ConCommandFlags_t flags = ConCommandFlag::ConCommandFlag::None, CVarCallback@ pCallback = null);
	//Constructor;
	CCVar@ CCVar(const string& in szName, float flValue = 0, const string& in szHelpInfo = "", const ConCommandFlags_t flags = ConCommandFlag::ConCommandFlag::None, CVarCallback@ pCallback = null);
	//Whether this command was added to the list of commands.\nMust be added to be usable from the console.;
	bool HasBeenAdded() const;
	//Gets the name of the module that owns (created) this command.;
	const string& GetOwningModuleName() const;
	//Gets the type of this console command.;
	ConCommandKind::Type GetKind() const;
	//Gets the help info describing this command.;
	const string& GetHelpInfo() const;
	//Gets the fully qualified name of this command. This is the name that the command is referred by when called.;
	const string& GetFullyQualifiedName() const;
	//Gets the name of this command.;
	const string& GetName() const;
}
//Client console command class;
class CClientCommand {
	//Constructor;
	CClientCommand@ CClientCommand(const string& in szName, const string& in szHelpInfo, ClientCommandCallback@ pCallback, const ConCommandFlags_t flags = ConCommandFlag::ConCommandFlag::None);
	//Whether this command was added to the list of commands.\nMust be added to be usable from the console.;
	bool HasBeenAdded() const;
	//Gets the name of the module that owns (created) this command.;
	const string& GetOwningModuleName() const;
	//Gets the type of this console command.;
	ConCommandKind::Type GetKind() const;
	//Gets the help info describing this command.;
	const string& GetHelpInfo() const;
	//Gets the fully qualified name of this command. This is the name that the command is referred by when called.;
	const string& GetFullyQualifiedName() const;
	//Gets the name of this command.;
	const string& GetName() const;
}
//Console command class;
class CConCommand {
	//Constructor;
	CConCommand@ CConCommand(const string& in szName, const string& in szHelpInfo, ConCommandCallback@ pCallback, const ConCommandFlags_t flags = ConCommandFlag::ConCommandFlag::None);
	//Whether this command was added to the list of commands.\nMust be added to be usable from the console.;
	bool HasBeenAdded() const;
	//Gets the name of the module that owns (created) this command.;
	const string& GetOwningModuleName() const;
	//Gets the type of this console command.;
	ConCommandKind::Type GetKind() const;
	//Gets the help info describing this command.;
	const string& GetHelpInfo() const;
	//Gets the fully qualified name of this command. This is the name that the command is referred by when called.;
	const string& GetFullyQualifiedName() const;
	//Gets the name of this command.;
	const string& GetName() const;
}
//Command arguments.;
class CCommand {
	//Find an int value for a given argument. Returns iDefault if no such argument exists, or no value exists for it. Otherwise, returns the value, converted to an int;
	int FindIntArg(const string& in szArgument, const int iDefault = 0) const;
	//Find a value for a given argument. If the argument does not exist or has no value, an empty string is returned. Otherwise, returns the value.;
	string FindArg(const string& in szArgument) const;
	//Gets the argument by index.;
	string opIndex(const int iIndex) const;
	//Gets the argument by index.;
	string Arg(const int iIndex) const;
	//Gets all arguments as a single string.;
	string GetArgumentsString() const;
	//Gets the entire command as a string.;
	string GetCommandString() const;
	//Gets the number of arguments.;
	int ArgC() const;
}
//This class can log data to the Angelscript log file.;
class CLog {
	//Prints formatted data to the file. Uses SC printf formatting style.;
	bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Prints formatted data to the file. Uses SC printf formatting style.;
	bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Prints formatted data to the file. Uses SC printf formatting style.;
	bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Prints formatted data to the file. Uses SC printf formatting style.;
	bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Prints formatted data to the file. Uses SC printf formatting style.;
	bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in, ?& in);
	//Prints formatted data to the file. Uses SC printf formatting style.;
	bool PrintF(const string& in szFormat, ?& in, ?& in, ?& in);
	//Prints formatted data to the file. Uses SC printf formatting style.;
	bool PrintF(const string& in szFormat, ?& in, ?& in);
	//Prints formatted data to the file. Uses SC printf formatting style.;
	bool PrintF(const string& in szFormat, ?& in);
	//Prints formatted data to the file. Uses SC printf formatting style.;
	bool PrintF(const string& in szFormat);
}
//Network message class. Used to send messages to clients.;
class NetworkMessage {
	//Writes a float to the buffer.;
	void WriteFloat(float flValue);
	//Writes an entity index to the buffer.;
	void WriteEntity(CBaseEntity@ pEntity);
	//Writes an entity index to the buffer.;
	void WriteEntity(int iEntity);
	//Writes a string to the buffer.;
	void WriteString(const string& in szString);
	//Writes a vector to the buffer.;
	void WriteVector(const Vector& in vecVector);
	//Writes a coordinate to the buffer.;
	void WriteCoord(float flValue);
	//Writes an angle to the buffer.;
	void WriteAngle(float flValue);
	//Writes a long to the buffer.;
	void WriteLong(int32 long);
	//Writes a short to the buffer.;
	void WriteShort(int16 short);
	//Writes a character to the buffer.;
	void WriteChar(const string& in szChar);
	//Writes a byte to the buffer.;
	void WriteByte(uint8 byte);
	//Ends the message. Must be called to send the message.;
	void End();
	//Constructor;
	NetworkMessage@ NetworkMessage(NetworkMessageDest dest, NetworkMessages::NetworkMessageType type, const Vector& in vecOrigin, edict_t@ pEdict = null);
	//Constructor;
	NetworkMessage@ NetworkMessage(NetworkMessageDest dest, NetworkMessages::NetworkMessageType type, edict_t@ pEdict = null);
}
//Admin control panel.;
class CAdminControl {
	//Slaps the given player. Slap direction is randomized.;
	bool SlapPlayer(CBasePlayer@ pSlappee, float flDamage, int iDamageType = 0);
	//Slaps the given player. Slapping player must have admin rights. Target player cannot be an admin. Slap direction is randomized.;
	bool SlapPlayer(CBasePlayer@ pSlapper, CBasePlayer@ pSlappee, float flDamage, int iDamageType = 0);
	//Slaps the given player.;
	bool SlapPlayer(CBasePlayer@ pSlappee, float flDamage, const Vector& in vecDirection, int iDamageType = 0);
	//Slaps the given player. Slapping player must have admin rights. Target player cannot be an admin.;
	bool SlapPlayer(CBasePlayer@ pSlapper, CBasePlayer@ pSlappee, float flDamage, const Vector& in vecDirection, int iDamageType = 0);
	//Bans the given player.;
	bool BanPlayer(CBasePlayer@ pBannee, const float flCustomBanTime = -1);
	//Bans the given player. Banning player must have admin rights Target player cannot be an admin.;
	bool BanPlayer(CBasePlayer@ pBanner, CBasePlayer@ pBannee, const float flCustomBanTime = -1);
	//Kicks the given player.;
	bool KickPlayer(CBasePlayer@ pKickee, const float flCustomBanTime = -1);
	//Kicks the given player. Kicking player must have admin rights. Target player cannot be an admin.;
	bool KickPlayer(CBasePlayer@ pKicker, CBasePlayer@ pKickee, const float flCustomBanTime = -1);
	//Kills the given player.;
	bool KillPlayer(CBasePlayer@ pKillee, float flRespawntime = -1.0f);
	//Kills the given player. Killing player must have admin rights. Target player cannot be an admin.;
	bool KillPlayer(CBasePlayer@ pKiller, CBasePlayer@ pKillee, float flRespawntime = -1.0f);
	//Gets the number of reserved slots.;
	uint GetReservedSlots() const;
	//Sets the number of reserved slots.;
	void SetReservedSlots(uint uiReservedSlots);
}
//Represents the difference between 2 times.;
class TimeDifference {
	//Sets the time difference to the range between 0 and time.;
	void SetTime(const DateTime& in time);
	//Sets the time difference to the range between beginning and end. If begin is later than end, is negative.;
	void SetDifferenceBetween(const DateTime& in end, const DateTime& in begin);
	//Makes the time difference absolute.;
	void MakeAbsolute();
	//Gets the time difference in years.;
	int GetYears() const;
	//Gets the time difference in days.;
	int GetDays() const;
	//Gets the time difference in hours.;
	int GetHours() const;
	//Gets the time difference in minutes.;
	int GetMinutes() const;
	//Gets the time difference in seconds.;
	int GetSeconds() const;
	//Returns whether the time difference is positive.;
	bool IsPositive() const;
	//Gets the time difference;
	double GetTimeDifference() const;
	//Assignment operator;
	TimeDifference& opAssign( const DateTime& in time);
	//Assignment operator;
	TimeDifference& opAssign(double timeDiff);
	//Assignment operator;
	TimeDifference& opAssign(const TimeDifference& in other);
	//Sets the time difference to the range between 0 and time.;
	void TimeDifference(const DateTime& in time);
	//Sets the time difference to the range between beginning and end. If begin is later than end, is negative.;
	void TimeDifference(const DateTime& in end, const DateTime& in begin);
	//Sets the time difference to the given value, in seconds;
	void TimeDifference(double flValue);
	//Copy constructor;
	void TimeDifference(const TimeDifference& in other);
	//Default constructor;
	void TimeDifference();
}
//DateTime class.\nNote: milliseconds default to 0 due to limited accuracy.;
class DateTime {
	//Adds this DateTime and the given TimeDifferene together, returning a copy containing the new time.;
	DateTime opAdd(const TimeDifference& in diffTime) const;
	//Adds the given TimeDifference to this one.;
	DateTime& opAddAssign(const TimeDifference& in diffTime);
	//Subtracts the given DateTime from this one, resulting in a TimeDifference object.;
	TimeDifference opSub(const DateTime& in other) const;
	//Comparison operator.;
	int opCmp(const DateTime& in other) const;
	//Returns whether these two DateTimes represent the same time.;
	bool opEquals(const DateTime& in other) const;
	//Returns a string representation of this datetime.;
	void ToString(string& out szResult) const;
	//Formats this datetime as a string.\nReturns the length of the destination string, or 0 if the buffer was not large enough.;
	int Format(string& out szResult, const string& in szFormat) const;
	//Set year.;
	void SetYear(int iYear);
	//Set month (0-11).;
	void SetMonth(int iMonth);
	//Set day of month (0-30).;
	void SetDayOfMonth(int iDay);
	//Set hours (0-23).;
	void SetHour(int iHours);
	//Set minutes (0-59).;
	void SetMinutes(int iMinutes);
	//Set seconds (0-59).;
	void SetSeconds(int iSeconds);
	//Set milliseconds.;
	void SetMilliseconds(uint uiMilliseconds);
	//Get year.;
	int GetYear() const;
	//Get month (0-11).;
	int GetMonth() const;
	//Get day of month (0-30).;
	int GetDayOfMonth() const;
	//Get hours (0-23).;
	int GetHour() const;
	//Get minutes (0-59).;
	int GetMinutes() const;
	//Get seconds (0-59).;
	int GetSeconds() const;
	//Get milliseconds.;
	uint GetMilliseconds() const;
	//Sets time as a unix timestamp.;
	void SetUnixTimestamp(time_t time);
	//Get time as a unix timestamp.;
	time_t ToUnixTimestamp() const;
	//Assignment operator.;
	DateTime& opAssign(time_t time);
	//Assignment operator.;
	DateTime& opAssign(const DateTime& in ref);
	//Copy constructor.;
	void DateTime(const DateTime& in ref);
	//Unix timestamp constructor.;
	void DateTime(time_t time);
	//Init constructor.;
	void DateTime(uint uiMilliseconds, int iSeconds, int iMinutes, int iHour, int iDayOfMonth, int iMonth, int iYear);
	//Default constructor.;
	void DateTime();
}
//Vote class. Can be used to start custom votes.;
class Vote {
	//Clears the user data set on this vote.;
	void ClearUserData();
	//Sets the user data on this vote.;
	void SetUserData(any@ pUserData);
	//Gets the user data set on this vote.;
	any@ GetUserData();
	//Starts this vote.;
	void Start();
	//Sets the vote end callback.;
	void SetVoteEndCallback(VoteEnd@ pCallback);
	//Sets the vote blocked callback.;
	void SetVoteBlockedCallback(VoteBlocked@ pCallback);
	//Sets the no button text.;
	void SetNoText(const string& in szNoText);
	//Gets the no button text.;
	const string& GetNoText() const;
	//Sets the yes button text.;
	void SetYesText(const string& in szYesText);
	//Gets the yes button text.;
	const string& GetYesText() const;
	//Sets the vote text.;
	void SetVoteText(const string& in szVoteText);
	//Gets the vote text.;
	const string& GetVoteText() const;
	//Gets name of this vote.;
	const string& GetName() const;
	//Constructor;
	Vote@ Vote(const string& in szName, const string& in szVoteText, float flVoteLength, float flPercentageNeeded);
}
//Text menu manager.;
class CTextMenus {
	//Invalid text menu id.;
	const TextMenuId_t INVALID_TEXT_MENU_ID;
}
//Text menu.;
class CTextMenu {
	//Adds an item to the menu.;
	void AddItem( const string& in szName, any@ pUserData = null);
	//Sets the title.;
	void SetTitle(const string& in szTitle);
	//Gets the title.;
	const string& GetTitle() const;
	//Gets the item at the given index.;
	const CTextMenuItem@ GetItem(const size_t uiIndex) const;
	//Gets the number of pages in this menu.;
	uint GetPageCount() const;
	//Gets the number of items in this menu.;
	size_t GetItemCount() const;
	//Opens the menu and keeps it open for the given amount of time.\nTime must be a positive value. Maximum 255 seconds. Pass 0 for infinite.\nYou must pass the player that receives this menu.;
	void Open(const int iDisplayTime, const uint page, CBasePlayer@ pPlayer);
	//Opens the menu and keeps it open for the given amount of time.\nTime must be a positive value. Maximum 255 seconds. Pass 0 for infinite.\nYou can optionally pass a list of players that receive this menu.;
	void Open(const int iDisplayTime, const uint page, array<edict_t@>@ pPlayers = null);
	//Unregisters this text menu.;
	void Unregister();
	//Registers this text menu.;
	bool Register();
	//Returns whether this menu is registered or not.;
	bool IsRegistered() const;
	//Gets this text menu\'s id. If CTextMenus::INVALID_TEXT_MENU_ID, this is an unregistered menu.;
	TextMenuId_t get_Id() const;
	//Constructor. You must pass a player slot callback and handle the input yourself.;
	CTextMenu@ CTextMenu(TextMenuPlayerSlotCallback@ inputCB);
}
//Text menu item. Do not store handles to this object.;
class CTextMenuItem {
	//User data. For internal use.;
	any@ m_pUserData;
	//Item name. Used for display.;
	const string m_szName;
}
//Player start inventory manager\nCan be used to modify the player\'s start inventory during a map\nAlways check if inventory modification is available before trying to make any changes;
class CStartInventory {
	//Gets the amount of a given entry.\nReturns 0 if the entry doesn\'t exist.;
	uint GetAmount(const string& in szEntry) const;
	//Limits the inventory content of the given item to at most uiAmount.\nDoes nothing if there is less than uiAmount in the inventory.;
	bool Limit(const string& in szItem, uint uiAmount);
	//Restocks the inventory with up to uiAmount of the given item.\nDoes nothing if the current amount already exceeds the given amount.;
	bool Restock(const string& in szItem, uint uiAmount);
	//Removes an entry from the inventory.;
	bool Remove(const string& in szEntry);
	//Add or subtract from an existing value.\nInserts if the value is not already in the inventory.;
	bool Add(const string& in szEntry, uint uiAmount, bool fAdd = true);
	//Set an entry to the inventory.;
	void Set(const string& in szEntry);
	//Set an item in the inventory.\nSets the amount if the item is already in the inventory.;
	void Set(const string& in szItem, uint uiAmount);
	//Returns whether the given entry is present in the inventory.;
	bool Exists(const string& in szEntry) const;
	//Returns whether inventory modification is available.;
	bool IsAvailable() const;
}
//Plugin manager for handling basic plugin operations;
class CPluginManager {
	//Gets the list of plugins as strings.;
	array<string>@ GetPluginList() const;
}
//Persistence manager;
class CPersistence {
	//Clears all values.;
	void Clear(const PersistID_t ID);
	//Clears the given value.;
	void Clear(const PersistID_t ID, const string& in szKey);
	//Sets the given value as a string.;
	void Set(const PersistID_t ID, const string& in szKey, float flValue);
	//Sets the given value as a string.;
	void Set(const PersistID_t ID, const string& in szKey, uint32 uiValue);
	//Sets the given value as a string.;
	void Set(const PersistID_t ID, const string& in szKey, int32 iValue);
	//Sets the given value as a boolean.;
	void Set(const PersistID_t ID, const string& in szKey, bool fValue);
	//Sets the given value as a string.;
	void Set(const PersistID_t ID, const string& in szKey, const string& in szValue);
	//Returns the given value as a float, or 0.0 if it does not exist.;
	float GetFloat(const PersistID_t ID, const string& in szKey);
	//Returns the given value as a unsigned long, or 0 if it does not exist.;
	uint32 GetUlong(const PersistID_t ID, const string& in szKey, int iRadix = 10);
	//Returns the given value as a long, or 0 if it does not exist.;
	int32 GetLong(const PersistID_t ID, const string& in szKey, int iRadix = 10);
	//Returns the given value as a boolean, or false if it does not exist.;
	bool GetBoolean(const PersistID_t ID, const string& in szKey);
	//Returns the given value as a string, or  if it does not exist.;
	const string& GetString(const PersistID_t ID, const string& in szKey);
	//Returns whether the given key exists in this instance.;
	bool Exists(const PersistID_t ID, const string& in szKey);
	//Returns the number of persisted items in this instance.;
	size_t Size(int iId) const;
	//Returns the name of this instance.;
	const string& GetName(const PersistID_t ID) const;
	//Clears all persistence instances.\nMake sure to avoid calling handles referencing the cleared instances.;
	void Clear();
	//Clears the specified persistence instance.;
	void ClearInstance(const PersistID_t ID);
	//Clears the specified persistence instance.;
	void ClearInstance(const string& in szName);
	//Returns the name of the current map.;
	const string& GetCurrentMapName() const;
	//Returns the name of the previous map. Can be empty if the server has just started.;
	const string& GetPreviousMapName() const;
	//Returns a persistence instance tied to the given name. Will be created if it does not already exist.;
	PersistID_t RegisterInstance(const string& in szName);
	//Will make the persistence manager keep the previous map\'s persistence instancesif the previous map\'s name matches the given map name.;
	bool KeepIfPrevious(const string& in szMapName);
	//Will make the persistence manager keep the previous map\'s persistence instancesif the previous map\'s name matches any of the elements in the array.;
	bool KeepIfPrevious(const array<string>@ pArray);
	//Sets whether the previous map\'s persistence instances will be kept.;
	void SetKeep(bool fValue);
	//Returns whether the previous map\'s persistence instances will be kept.;
	bool ShouldKeep() const;
	//Returns whether the given persistence instance handle is valid.;
	bool IsValidHandle(const PersistID_t ID) const;
	//Returns whether the given persistence instance exists.;
	bool Exists(const string& in szName) const;
	//Id used by invalid persistence objects.;
	const PersistID_t INVALID_ID;
}
//Map state variables;
class CMap {
	//Load a custom skill file.;
	bool LoadSkillFile(const string& in szFileName);
	//Reload the global skill file.;
	bool LoadGlobalSkillFile();
	//Reload the standard map skill file (_skl.cfg).;
	bool LoadMapSkillFile();
	//Get if player models are forced;
	bool HasForcedPlayerModels() const;
}
//Map cycle read only manager;
class CMapCycle {
	//Gets the next map in the cycle after the given one.;
	string GetNextMap(const string& in szMapName) const;
	//Gets the next map in the cycle.;
	string GetNextMap() const;
	//Returns the number of maps in the map cycle.;
	size_t Count() const;
	//Gets the map cycle as an array of strings.;
	array<string>@ GetMapCycle() const;
}
//Angelscript debugging functions;
class CAngelscript {
	//Gets the minor version of the Angelscript Sven Co-op implementation;
	uint GetMinorVersion() const;
	//Gets the major version of the Angelscript Sven Co-op implementation;
	uint GetMajorVersion() const;
	//Gets the current version of Angelscript;
	uint GetAngelscriptVersion() const;
	//Gets the current version of Angelscript as a string;
	string GetAngelscriptVersionString() const;
	//Returns a brief description of Angelscript;
	string GetAngelscriptDescription() const;
}
//Global state manager;
class CGlobalState {
	//Dumps all global state objects to the console;
	void DumpGlobals() const;
	//Returns whether the global state object is in the table of objects;
	bool EntityInTable(const string& in globalName) const;
	//Gets the state of the specified global state object;
	const GLOBALESTATE EntityGetState(const string& in globalName) const;
	//Finds a global state object by name;
	const GlobalEntity@ EntityFromTable(const string& in globalName) const;
	//Updates the level name of the specified global state object;
	void EntityUpdate(const string& in globalName, const string& in mapName);
	//Sets the state of an existing global state object;
	void EntitySetState(const string& in globalName, GLOBALESTATE state);
	//Adds a new global state object;
	void EntityAdd(const string& in globalName, const string& in mapName , GLOBALESTATE state);
	//Clears all global states;
	void ClearStates();
}
//Global state entity;
class GlobalEntity {
	//Name of the level where this global state was last updated;
	string levelName() const;
	//Gets the name of this global state;
	string name() const;
	//Next global state entity in the list;
	GlobalEntity@ next;
	//Global state of this entity;
	GLOBALESTATE state;
}
//Weapon functions class.;
class CWeaponFuncs {
	//Deals radius damage.;
	void RadiusDamage(const Vector& in vecSrc, entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, float flRadius, int iClassIgnore, int bitsDamageType);
	//Creates a damage decal on the given entity.;
	int DamageDecal(CBaseEntity@ pEntity, int bitsDamageType);
	//Spawns blood at the given location.;
	void SpawnBlood(const Vector& in vecSpot, int bloodColor, float flDamage);
	//Creates a gunshot decal at the trace hit point.;
	void DecalGunshot(TraceResult& in trace, int iBulletType);
	//Gets the weapon time base.;
	float WeaponTimeBase();
	//Add multi damage.;
	void AddMultiDamage(entvars_t@ pevInflictor, CBaseEntity@ pEntity, float flDamage, int bitsDamageType);
	//Applies multi damage.;
	void ApplyMultiDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker);
	//Clears the multi damage data.;
	void ClearMultiDamage();
}
//Global player functions;
class CPlayerFuncs {
	//Disconnects the bot. This will call ClientDisconnect and removes the entity. Do not use the entity after this call.;
	 void BotDisconnect(CBasePlayer@ pBot);
	//Creates a bot with the given name.;
	CBasePlayer@ CreateBot(const string& in szName);
	//Gets the index of the given ammo, or -1 if it is invalid;
	int GetAmmoIndex(const string& in szAmmoName);
	//Gets a random float whose value is the same on both the client and server.;
	float SharedRandomFloat(uint iRandomSeed, float iLow, float iHigh);
	//Gets a random long whose value is the same on both the client and server.;
	int SharedRandomLong(uint iRandomSeed, int iLow, int iHigh);
	//Returns whether the given spawn point entity is occupied;
	bool IsSpawnPointOccupied(CBaseEntity@ pSpawnEnt);
	//Returns whether the given spawn point is valid for the given player;
	bool IsSpawnPointValid(CBaseEntity@ pSpawnEnt, CBaseEntity@ pPlayer);
	//Returns whether the given player passes the given spawn point\'s filter;
	bool SpawnPointFilterPasses(CBaseEntity@ pSpawnEnt, CBaseEntity@ pPlayer);
	//Relocates all players to active spawn points. If a player is dead and fRespawnDeadPlayers is true, the player is respawned.;
	void RespawnAllPlayers(bool fMoveLivingPlayers = true, bool fRespawnDeadPlayers = false);
	//Relocates the given player to an active spawn point. If the player is dead and fRespawnDeadPlayers is true, the player is respawned.;
	void RespawnPlayer(CBasePlayer@ pPlayer, bool fMoveLivingPlayers = true, bool fRespawnDeadPlayers = false);
	//Applies the map configuration on the given player.\nWill stack if called multiple times, unless fReEquip is true, in which case the player is stripped of all weapons and ammo first.;
	void ApplyMapCfgToPlayer(CBasePlayer@ pPlayer, bool fReEquip = false);
	//Converts a string containing one of AdminLevelToString\'s return values to an admin level.Returns ADMIN_NO if the string cannot be converted to a suitable constant;
	AdminLevel_t StringToAdminLevel(const string& in szString) const;
	//Converts the admin level to a string. If the level is an invalid value, an empty string is returned;
	string AdminLevelToString(const AdminLevel_t adminLevel) const;
	//Returns the admin level for a given player.;
	AdminLevel_t AdminLevel(CBasePlayer@ pPlayer) const;
	//Returns whether cheats are enabled for the given player.;
	bool CheatsAllowed(CBasePlayer@ pPlayer, const string& in szCheatName, bool fMustBeAlive = true, bool fNoMessage = false) const;
	//Makes the given player select the next best weapon available, based on the current weapon.;
	bool GetNextBestWeapon(CBasePlayer@ pPlayer, CBasePlayerItem@ pCurrentWeapon);
	//Applies concussion effect to a given player.;
	void ConcussionEffect(CBaseEntity@ pEntity, float amplitude, float frequency, float fadeTime);
	//Shows a message to all players.;
	void ScreenFadeAll(const Vector& in color, float fadeTime, float fadeHold, int alpha, int flags);
	//Shows a message to a given player.;
	void ScreenFade(CBaseEntity@ pEntity, const Vector& in color, float fadeTime, float fadeHold, int alpha, int flags);
	//Shakes the screen for all players;
	void ScreenShakeAll(const Vector& in center, float amplitude, float frequency, float duration);
	//Shakes the screen for players near a certain location;
	void ScreenShake(const Vector& in center, float amplitude, float frequency, float duration, float radius);
	//Gets the number of players that are currently connected to the server.;
	int GetNumPlayers() const;
	//Finds a player by name;
	CBasePlayer@ FindPlayerByName(const string& in szName, bool bCaseSensitive = true);
	//Finds a player by index;
	CBasePlayer@ FindPlayerByIndex(int index);
	//Updates value of a custom time display.;
	void HudUpdateTime(CBasePlayer@ pTargetPlayer, uint8 iChannel, float flTime);
	//Shows a custom time display to a given player or to all players if pTargetPlayer is not specified.;
	void HudTimeDisplay(CBasePlayer@ pTargetPlayer, const HUDNumDisplayParams& in params);
	//Updates value of a custom numberic display.;
	void HudUpdateNum(CBasePlayer@ pTargetPlayer, uint8 iChannel, float flValue);
	//Shows a custom numeric display to a given player or to all players if pTargetPlayer is not specified.;
	void HudNumDisplay(CBasePlayer@ pTargetPlayer, const HUDNumDisplayParams& in params);
	//Shows a custom HUD sprite to a given player or to all players if pTargetPlayer is not specified.;
	void HudCustomSprite(CBasePlayer@ pTargetPlayer, const HUDSpriteParams& in params);
	//Shows or hides HUD element occupying a given channel.;
	void HudToggleElement(CBasePlayer@ pTargetPlayer, uint8 iChannel, bool fVisible);
	//Prints a string containing key bindings to the screen of all players.;
	void PrintKeyBindingStringAll(const string& in szString);
	//Prints a string containing key bindings to the screen of the given player.;
	void PrintKeyBindingString(CBasePlayer@ pPlayer, const string& in szString);
	//Shows a HUD message to all players.;
	void HudMessageAll(const HUDTextParams& in textParams, const string& in szMessage);
	//Shows a HUD message to a given player.;
	void HudMessage(CBasePlayer@ pTargetPlayer, const HUDTextParams& in textParams, const string& in szMessage);
	//Shows a message to all players.;
	void ShowMessageAll(const string& in szString);
	//Shows a message to the given player.;
	void ShowMessage(CBasePlayer@ pTargetPlayer, const string& in szString);
	//Prints one or more messages centered on the HUD of all players.;
	void CenterPrintAll(const string& in szMessage, const string& in szLine2 = "", const string& in szLine3 = "", const string& in szLine4 = "", const string& in szLine5 = "");
	//Prints one or more messages on the HUD of all players.\nSee HUD enum.;
	void ClientPrintAll(HUD iMsgDest, const string& in szMessage, const string& in szLine2 = "", const string& in szLine3 = "", const string& in szLine4 = "", const string& in szLine5 = "");
	//Prints one or more messages on the HUD of the given player.\nSee HUD enum.;
	void ClientPrint(CBasePlayer@ pTargetPlayer, HUD iMsgDest, const string& in szMessage, const string& in szLine2 = "", const string& in szLine3 = "", const string& in szLine4 = "", const string& in szLine5 = "");
	//Says text to all players;
	void SayTextAll(CBasePlayer@ pOriginatingPlayer, const string& in szText);
	//Says text to a specific player;
	void SayText(CBasePlayer@ pTargetPlayer, const string& in szText);
}
//Holds parameters for custom numeric/time display.;
class HUDNumDisplayParams {
	//Assignment operator;
	HUDNumDisplayParams& opAssign(const HUDNumDisplayParams& in other);
	//Copy constructor;
	void HUDNumDisplayParams(const HUDNumDisplayParams& in other);
	//Constructor;
	void HUDNumDisplayParams();
	//Sprite height\nRange: 0-512 (0: auto; use total height of the sprite);
	int16 height;
	//Sprite width\nRange: 0-512 (0: auto; use total width of the sprite);
	int16 width;
	//Sprite top offset\nRange: 0-255;
	uint8 top;
	//Sprite left offset\nRange: 0-255;
	uint8 left;
	//Sprite name;
	string_t spritename;
	//Effect\nSee HUD_EFFECT enum.;
	uint8 effect;
	//Effect time;
	float fxTime;
	//Hold time;
	float holdTime;
	//Fade out time;
	float fadeoutTime;
	//Fade in time;
	float fadeinTime;
	//Color 2;
	RGBA color2;
	//Color 1;
	RGBA color1;
	//Vertical position on the screen.\n<0, 1.0> = top to bottom\n(-1.0, 0) = bottom to top\n-1.0 = centered;
	float y;
	//Horizontal position on the screen.\n<0, 1.0> = left to right\n(-1.0, 0) = right to left\n-1.0 = centered;
	float x;
	//Maximum number of digits (numeric display only);
	uint8 maxdigits;
	//Default number of digits (numeric display only);
	uint8 defdigits;
	//Value;
	float value;
	//Flags\nSee HUD_ELEM, HUD_NUM (numeric display only) and HUD_TIME (time display only) enums.;
	int flags;
	//Channel.\nRange: 0-15 (each module type has its own channel group).;
	uint8 channel;
}
//Holds parameters for custom sprite.;
class HUDSpriteParams {
	//Assignment operator;
	HUDSpriteParams& opAssign(const HUDSpriteParams& in other);
	//Copy constructor;
	void HUDSpriteParams(const HUDSpriteParams& in other);
	//Constructor;
	void HUDSpriteParams();
	//Effect\nSee HUD_EFFECT enum.;
	uint8 effect;
	//Effect time;
	float fxTime;
	//Hold time;
	float holdTime;
	//Fade out time;
	float fadeoutTime;
	//Fade in time;
	float fadeinTime;
	//Framerate;
	float framerate;
	//Number of frames;
	uint8 numframes;
	//Frame;
	uint8 frame;
	//Color 2;
	RGBA color2;
	//Color 1;
	RGBA color1;
	//Vertical position on the screen.\n<0, 1.0> = top to bottom\n(-1.0, 0) = bottom to top\n-1.0 = centered;
	float y;
	//Horizontal position on the screen.\n<0, 1.0> = left to right\n(-1.0, 0) = right to left\n-1.0 = centered;
	float x;
	//Sprite height\nRange: 0-512 (0: auto; use total height of the sprite);
	int16 height;
	//Sprite width\nRange: 0-512 (0: auto; use total width of the sprite);
	int16 width;
	//Sprite top offset\nRange: 0-255;
	uint8 top;
	//Sprite left offset\nRange: 0-255;
	uint8 left;
	//Sprite name;
	string_t spritename;
	//Flags\nSee HUD_ELEM and HUD_SPR enums.;
	int flags;
	//Channel.\nRange: 0-15 (each module type has its own channel group).;
	uint8 channel;
}
//Parameters for text output to the HUD.;
class HUDTextParams {
	//Assignment operator;
	HUDTextParams& opAssign(const HUDTextParams& in other);
	//Copy constructor;
	void HUDTextParams(const HUDTextParams& in other);
	//Constructor;
	void HUDTextParams();
	//Channel. 1-4.;
	int channel;
	//Effect time (scan effect only);
	float fxTime;
	//Hold time;
	float holdTime;
	//Fade out time;
	float fadeoutTime;
	//Fade in time;
	float fadeinTime;
	//Alpha 2;
	uint8 a2;
	//Blue 2;
	uint8 b2;
	//Green 2;
	uint8 g2;
	//Red 2;
	uint8 r2;
	//Alpha 1;
	uint8 a1;
	//Blue 1;
	uint8 b1;
	//Green 1;
	uint8 g1;
	//Red 1;
	uint8 r1;
	//Effects.\n0 : Fade In/Out\n1 : Credits\n2 : Scan Out;
	int effect;
	//Vertical position on the screen.\n<0, 1.0> = top to bottom\n(-1.0, 0) = bottom to top\n-1.0 = centered;
	float y;
	//Horizontal position on the screen.\n<0, 1.0> = left to right\n(-1.0, 0) = right to left\n-1.0 = centered;
	float x;
}
//Color stored as four uint8 components;
class RGBA {
	//Assignment operator;
	RGBA& opAssign(const RGBA& in other);
	//Copy constructor;
	void RGBA(const RGBA& in other);
	//Constructor;
	void RGBA(uint8 r, uint8 g, uint8 b, uint8 a = 255);
	//Constructor;
	void RGBA();
	//Alpha component;
	uint8 a;
	//Blue component;
	uint8 b;
	//Green component;
	uint8 g;
	//Red component;
	uint8 r;
}
//Global entity functions;
class CEntityFuncs {
	//Precaches the sounds used by a particular material;
	void PrecacheMaterialSounds(const Materials material);
	//Returns a randomly selected entity that has the given target name.;
	CBaseEntity@ RandomTargetname(const string& in szTargetname);
	//Casts an CBaseEntity@ representing a custom entity to the ScriptClassBaseClass type;
	ScriptClassInterface@ CastToScriptClass(CBaseEntity@ pEntity);
	//tosses a brass shell from passed origin at passed velocity.;
	void EjectBrass(const Vector& in vecOrigin, const Vector& in vecVelocity, float flRotation, int iModel, TE_BOUNCE soundtype);
	//Gets the edict for the given index.;
	edict_t@ IndexEnt(int iEdictNum);
	//Gets the index for the given edict.;
	int EntIndex(edict_t@ pEdict);
	//Returns whether this is a valid entity.;
	bool IsValidEntity(edict_t@ pEntity);
	//Removes the given entity before the next frame starts.;
	void Remove(CBaseEntity@ pEntity);
	//Returns whether the master with the given name would be triggered if activated by the given entity.;
	bool IsMasterTriggered(const string& in szMaster, CBaseEntity@ pActivator);
	//Triggers targets. If flDelay is nonzero, causes a temporary entity to be spawned to trigger the target at the given time.\nThe temporary entity becomes the caller, not the entity passed in.;
	void FireTargets(const string& in szTargetName, CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f, float flDelay = 0.0f);
	//Gets the entity instance based on an edict number;
	CBaseEntity@ Instance(int iEdictNum);
	//Gets the entity instance of an entvars instance;
	CBaseEntity@ Instance(entvars_t@ vars);
	//Gets the entity instance of an edict instance;
	CBaseEntity@ Instance(edict_t@ edict);
	//Dispatches the initialization of the collision box of an entity;
	void DispatchObjectCollisionBox(edict_t@ entity);
	//Handles the initialization of keyvalues located in the entity\'s entvars_t object.;
	bool EntvarsKeyvalue(edict_t@ entity, const string& in szKeyName, const string& in szValue);
	//Dispatches the passing of a key value pair to an entity;
	bool DispatchKeyValue(edict_t@ entity, const string& in szKeyName, const string& in szValue);
	//Dispatches the spawning of an entity;
	int DispatchSpawn(edict_t@ entity);
	//Finds brush entities in a box;
	int BrushEntsInBox(array<CBaseEntity@>@ pArray, const Vector& in mins, const Vector& in maxs );
	//Finds targets in a box;
	int TargetsInBox(array<CBaseEntity@>@ pArray, const Vector& in mins, const Vector& in maxs);
	//Finds entities in a box;
	int EntitiesInBox(array<CBaseEntity@>@ pArray, const Vector& in mins, const Vector& in maxs, int flagMask);
	//Finds monsters in a sphere;
	int MonstersInSphere(array<CBaseEntity@>@ pArray, const Vector& in vecCenter, float flRadius);
	//Finds an entity by target name in a sphere;
	CBaseEntity@ FindEntityGeneric(const string& in szName, const Vector& in vecSrc, float flRadius);
	//Finds an entity by target name;
	CBaseEntity@ FindEntityByTargetname(CBaseEntity@ startEntity, const string& in name);
	//Finds an entity by class name;
	CBaseEntity@ FindEntityByClassname(CBaseEntity@ startEntity, const string& in name);
	//Finds an entity based on a key value pair;
	CBaseEntity@ FindEntityByString(CBaseEntity@ pStartEntity,const string& in szKeyword, const string& in szValue);
	//Finds an entity in a sphere;
	CBaseEntity@ FindEntityInSphere(CBaseEntity@ pStartEntity, const Vector& in vecCenter, float flRadius,const string& in szValue = "", const string& in szKeyword = "targetname");
	//Set the size of an entity;
	void SetSize(entvars_t@ pev, const Vector& in vecMin, const Vector& in vecMax);
	//Set the model of an entity;
	void SetModel(CBaseEntity@ entity, const string& in szFileName);
	//Set the origin of an entity;
	void SetOrigin(CBaseEntity@ entity, const Vector& in vecOrigin);
	//Spawns sticky gibs for the target victim.\ncGibs specifies how many gibs there are.;
	void SpawnStickyGibs(entvars_t@ pevVictim, const Vector& in vecOrigin, int cGibs);
	//Spawns random gibs for the target victim.\niHuman specifies whether the gibs are human or alien.;
	void SpawnRandomGibs(entvars_t@ pevVictim, int cGibs, int iHuman);
	//Spawns a head gib for the target victim.;
	void SpawnHeadGib(entvars_t@ pevVictim);
	//Triggers all satchel charges owned by pevOwner to either be released from ownership, or detonated.;
	void UseSatchelCharges(entvars_t@ pevOwner, SATCHELCODE code);
	//Spawn a banana bomb.;
	CGrenade@ ShootBananaCluster(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity);
	//Spawns a mortar grenade.;
	CGrenade@ ShootMortar(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity);
	//Spawns a contact grenade.;
	CGrenade@ ShootContact(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity);
	//Spawns a timed grenade.;
	CGrenade@ ShootTimed(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity, float flTime);
	//Creates a server side gib.;
	CGib@ CreateGib( const Vector& in vecOrigin, const Vector& in vecAngles);
	//Creates an rpg rocket with custom velocity.;
	CBaseEntity@ CreateRPGRocket(const Vector& in vecOrigin, const Vector& in vecAngles, const Vector& in vecVelocity, edict_t@ pOwner);
	//Creates an rpg rocket.;
	CBaseEntity@ CreateRPGRocket(const Vector& in vecOrigin, const Vector& in vecAngles, edict_t@ pOwner);
	//Creates a displacer portal.;
	CBaseEntity@ CreateDisplacerPortal(const Vector& in vecOrigin, const Vector& in vecVelocity, edict_t@ pOwner, float flDamage, float flRadius);
	//Creates an explosion.\nIf fDoDamage is true, also deals damage to entities within its effect radius, which is determined by the magnitude.;
	void CreateExplosion(const Vector& in vecCenter, const Vector& in vecAngles, edict_t@ pOwner, int iMagnitude, bool fDoDamage);
	//Creates a beam entity with the given sprite and width set.;
	CBeam@ CreateBeam(const string& in szSpriteName, int width);
	//Creates a sprite. flFrameRate must be set to a valid value to animate the sprite.;
	CSprite@ CreateSprite(const string& in szSpriteName, const Vector& in vecOrigin, bool fAnimated, float flFrameRate = 10.0f);
	//Creates a decal with the specified name.\nIf given a name, has to be triggered to be placed, otherwise, is placed immediately.;
	void CreateDecal(const string& in szDecalName, const Vector& in vecOrigin, const string& in szTargetName = "");
	//Creates an entity by class name.;
	CBaseEntity@ Create(const string& in szClassname, const Vector& in vecOrigin, const Vector& in vecAngles, bool fCreateAndDontSpawn, edict_t@ entOwner = null);
	//Create an entity by class name. Pass keyvalues in using the dictionary, if any. Keyvalues must be strings.\nThe class name can be either one of the entities included with the game or a custom entity.;
	CBaseEntity@ CreateEntity(const string& in szClassName, dictionary@ pDictionary = null, bool fSpawn = true);
}
//Engine global variables;
class CEngine {
	//Maximum entities;
	const int maxEntities;
	//Maximum connected clients;
	const int maxClients;
	//CD audio track;
	int cdAudioTrack;
	//Message entity;
	const int msg_entity;
	//Trace flags;
	const int trace_flags;
	//Trace hit group;
	const int trace_hitgroup;
	//Trace is in water flag;
	const float trace_inwater;
	//Trace is in open flag;
	const float trace_inopen;
	//Trace entity;
	const edict_t@ trace_ent;
	//Trace plane distance;
	const float trace_plane_dist;
	//Trace plane normal;
	const Vector trace_plane_normal;
	//Trace end position;
	const Vector trace_endpos;
	//Trace fraction;
	const float trace_fraction;
	//Trace start is solid flag;
	const float trace_startsolid;
	//Trace all is solid flag;
	const float trace_allsolid;
	//Right vector;
	const Vector v_right;
	//Up vector;
	const Vector v_up;
	//Forward vector;
	const Vector v_forward;
	//Found secrets;
	float found_secrets;
	//Server flags;
	const float serverflags;
	//Flag telling whether this is teamplay;
	float teamplay;
	//Flag telling whether this is coop;
	float coop;
	//Flag telling whether this is deathmatch;
	float deathmatch;
	//Start location in the map;
	const string_t startspot;
	//Name of the current map;
	const string_t mapname;
	//How many times to force all entities to retouch entities they are currently touching/intersecting. Should always be >= 0.;
	float force_retouch;
	//Time between frames;
	const float frametime;
	//Current time;
	const float time;
}
//Sound engine.\nCan either play sounds given to it directly, or use sound replacement to look up a replacement sample.;
class CSoundEngine {
	//Maps the texture name to a material type. See the TextureType enum.;
	char FindMaterialType(const string& in szMaterial) const;
	//Plays a hit sound based on the trace result\'s hit target. Returns the volume at which the hit is being played.;
	float PlayHitSound( TraceResult& in tr, const Vector& in vecSrc, const Vector& in vecEnd, int iBulletType );
	//Plays a sentence group sequentially;
	void EmitAmbientSound(edict_t@ entity, const Vector& in vecOrigin, const string& in szSample,float flVolume, float flAttenuation, int fFlags, int iPitch);
	//Plays a sentence group sequentially;
	int PlaySentenceGroupSequential(edict_t@ entity, const string& in szGroupName,float volume, float attenuation, int flags, int pitch, int ipick, const bool bReset);
	//Plays a sentence group;
	int PlaySentenceGroup(edict_t@ entity, int iGroupIndex, float volume, float attenuation, int flags, int pitch);
	//Plays a sentence group;
	int PlaySentenceGroup(edict_t@ entity, const string& in szGroupName, float volume, float attenuation, int flags, int pitch);
	//Looks up the sentence group index of the given sentence;
	int LookupSentenceGroupIndex(const string& in szGroup);
	//Looks up the sentence index of the given sentence;
	int LookupSentenceIndex(const string& in sentenceName);
	//Play a sentence, randomly selected from the passed in groupname.;
	void EmitGroupNameSuit(edict_t@ entity, const string& in szSample);
	//Play a sentence, randomly selected from the passed in group id, over the HEV suit speaker.;
	void EmitGroupIdSuit(edict_t@ entity, int isentencereg);
	//Play a specific sentence over the HEV suit speaker - just pass player entity, and !sentencename.;
	void EmitSoundSuit(edict_t@ entity, const string& in szSample);
	//Plays the given sound with the given parameters. Sound replacement will affect this.;
	void EmitSound(edict_t@ entity, SOUND_CHANNEL channel, const string& in szSample, float flVolume, float flAttenuation);
	//Plays the given sound with the given parameters. Sound replacement will affect this.;
	void EmitSoundDyn(edict_t@ entity, SOUND_CHANNEL channel, const string& in szSample,float flVolume, float flAttenuation, int iFlags = 0, int iPitch = PITCH::PITCH_NORM, int target_ent_unreliable = 0);
	//Stops the given sound on the given entity on the given channel. If the sound was started using PlaySound, set fUseSoundReplacement to false.;
	void StopSound(edict_t@ entity, SOUND_CHANNEL channel, const string& in szSample, const bool fUseSoundReplacement = true);
	//Plays the given sound with the given parameters. Sound replacement is not used here.;
	void PlaySound(edict_t@ entity, SOUND_CHANNEL channel, const string& in sample,float volume, float attenuation, int flags = 0, int pitch = PITCH::PITCH_NORM,int target_ent_unreliable = 0, bool setOrigin = false, const Vector& in vecOrigin = g_vecZero);
	//Finds the sound replacement sample for the given entity and sample.If the sample is replaced, it will return the sample used instead. Otherwise, szSample is returned.;
	string FindSoundReplacementSample(CBaseEntity@ pEntity, const string& in szSample) const;
	//Precaches the given sound for the given entity. Supports entity sound replacement.\nMust be called in MapInit;
	void PrecacheSound(CBaseEntity@ pEntity, const string& in szFilename);
	//Precaches the given sound.\nMust be called in MapInit;
	void PrecacheSound(const string& in szFilename);
}
//Game functions;
class CGame {
	//Returns the game version as a number, e.g. 500:\nmajor version, minor version (3.0 becomes 300, 4.0b1 becomes 401, 4.06 becomes 406, 4.5 becomes 450, etc...);
	uint32 GetGameVersion() const;
	//Returns the game version as a string, e.g. 5.0.;
	string GetGameVersionString() const;
	//Returns the game name.;
	string GetGameName() const;
	//Precaches a file for download to clients.;
	void PrecacheGeneric(const string& in szFileName);
	//Precaches a monster entity.\nThis effectively instances a monster entity with the given class name, calls precache on it, and removes the entity.;
	void PrecacheMonster(const string& in szClassName, bool fAlly);
	//Precaches an entity.\nThis effectively instances an entity with the given class name, calls precache on it, and removes the entity.;
	void PrecacheOther(const string& in szClassName);
	//Precaches a model.\nShuts down the game if not found.\nCan only be called from entity Precache methods.;
	int PrecacheModel(CBaseEntity@ pEntity, const string& in szFileName);
	//Precaches a model.\nShuts down the game if not found.\nCan only be called from MapInit.;
	int PrecacheModel(const string& in szFileName);
	//Outputs a message to the console. Uses SC printf formatting style.;
	bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Outputs a message to the console. Uses SC printf formatting style.;
	bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Outputs a message to the console. Uses SC printf formatting style.;
	bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Outputs a message to the console. Uses SC printf formatting style.;
	bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Outputs a message to the console. Uses SC printf formatting style.;
	bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in, ?& in);
	//Outputs a message to the console. Uses SC printf formatting style.;
	bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in, ?& in);
	//Outputs a message to the console. Uses SC printf formatting style.;
	bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in, ?& in);
	//Outputs a message to the console. Uses SC printf formatting style.;
	bool AlertMessage(ALERT_TYPE aType, const string& in szFormat, ?& in);
	//Outputs a message to the console. Uses SC printf formatting style.;
	bool AlertMessage(ALERT_TYPE aType, const string& in szFormat);
}
//Utility methods;
class CUtility {
	//Get a player log string.;
	string GetPlayerLog(edict_t@ pPlayerEdict) const;
	//Builds a generic player log string.;
	string BuildPlayerLogString(const string& in szName, const string& in szUserID = null, const string& in szAuthID = null) const;
	//Builds a generic entity log string.;
	string BuildEntityLogString(const string& in szName, const string& in szUserID = null, const string& in szAuthID = null, const string& in szTeam = null) const;
	//Finds the hull intersection from a traceline in a given set of bounds. The bounds are relative to the input traceline\'s endpoint.\nThe given entity is the entity performing the traceline.;
	void FindHullIntersection(const Vector& in vecSrc, TraceResult& in inTr, TraceResult& out outTr,const Vector& in vecMins, const Vector& in vecMaxs, edict_t@ pEntity, float flDistance = 1e-6f);
	//Counts the number of players inside and outside a brush volume.;
	int CountPlayersInBrushVolume(const bool fIgnoreDeadPlayers, CBaseEntity@ pBrushVolume,int& out iOutPlayersInsideVolume, int& out iOutPlayersOutsideVolume, PlayerInVolumeListener@ pListener);
	//Gets circular gaussian spread.;
	void GetCircularGaussianSpread(float& out x, float& out y) const;
	//Returns whether a vote is active. This only covers the votes started using the in-game vote menu, trigger_vote and the Vote class.;
	bool VoteActive() const;
	//Returns whether the given player is in the given volume.;
	bool IsPlayerInVolume(CBasePlayer@ pPlayer, CBaseEntity@ pEntityVolume);
	//Gets the global trace data stored in g_Engine as a TraceResult object.;
	TraceResult GetGlobalTrace();
	//Convience function that finds the entity that the given entity is currently looking at. Uses a maximum distance of 12048 units.;
	CBaseEntity@ FindEntityForward(CBaseEntity@ pLooker);
	//Convience function that finds the entity that the given entity is currently looking at.;
	CBaseEntity@ FindEntityForward(CBaseEntity@ pLooker, float flMaxDistance);
	//Trace texture;
	string TraceTexture(edict_t@ pEntity, const Vector& in vecStart, const Vector& in vecEnd);
	//TraceModel;
	void TraceModel(const Vector& in vecStart, const Vector& in vecEnd, int iHullNumber, edict_t@ pEntityToIgnore, TraceResult& out ptr);
	//Trace monster hull. Returns true if the trace was entirely in a solid object, or hit something.;
	bool TraceMonsterHull(edict_t@ pEntity, const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon, edict_t@ pEntityToIgnore, TraceResult& out ptr);
	//Trace toss;
	void TraceToss(edict_t@ pEntity, edict_t@ pEntityToIgnore, TraceResult& out traceResult);
	//Calculates a trace along the given line, storing the results in ptr, using the specified hull type.;
	void TraceHull(const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon,HULL_NUMBER hullNumber, edict_t@ pEntIgnore, TraceResult& out ptr);
	//Calculates a trace along the given line, storing the results in ptr.;
	void TraceLine(const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon,IGNORE_GLASS ignoreGlass, edict_t@ pEntIgnore, TraceResult& out ptr);
	//Calculates a trace along the given line, storing the results in ptr.;
	void TraceLine(const Vector& in vecStart, const Vector& in vecEnd, IGNORE_MONSTERS igmon,edict_t@ pEntIgnore, TraceResult& out ptr);
	//Returns whether the given string is a 3D vector;
	bool IsString3DVec(const string& in szString);
	//Returns whether the given float is a whole number, and returns the rounded number;
	bool IsWholeNumber(const float flNum, int& out iRounded);
	//Returns whether the given string is a float;
	bool IsStringFloat(const string& in szString);
	//Returns whether the given string is an integer;
	bool IsStringInt(const string& in szString);
	//Converts the given string to a vector;
	void StringToVector(Vector& out vecVector, const string& in szString, const char delimiter = char(' '));
	//Creates a trail of bubbles;
	void BubbleTrail(const Vector& in vecFrom, const Vector& in vecTo, int iCount);
	//Creates a box filled with bubbles;
	void Bubbles(const Vector& in vecMins, const Vector& in vecMaxs, int iCount);
	//Determines the Z level at which a water surface level is, given a position to start searching from and a range to search.;
	float WaterLevel(const Vector& in vecPosition, float minz, float maxz);
	//Creates a ricochet at the given location;
	void Ricochet(const Vector& in vecPosition, float flScale);
	//Creates sparks at the given location;
	void Sparks(const Vector& in vecPosition);
	//Applies gunshot decal to the trace hit location;
	void GunshotDecalTrace(TraceResult& in trace, int iDecalNumber);
	//Applies player decal to the trace hit location;
	void PlayerDecalTrace(TraceResult& in trace, int iPlayerNum, int iDecalNumber, const bool bIsCustom);
	//Applies decal to the trace hit location;
	void DecalTrace(TraceResult& in trace, int iDecalNumber);
	//Applies blood decal to the trace hit location;
	void BloodDecalTrace(TraceResult& in trace, int iBloodColor);
	//Returns whether blood of the given type should be shown.;
	bool ShouldShowBlood(int iBloodColor);
	//Returns a random blood direction vector;
	Vector RandomBloodVector();
	//Creates blood drips. Use BLOOD_COLOR enum for the color.;
	void BloodDrips(const Vector& in vecOrigin, const Vector& in vecDirection, int iColor, int iAmount);
	//Creates a blood stream. Use BLOOD_COLOR enum for the color.;
	void BloodStream(const Vector& in vecOrigin, const Vector& in vecDirection, int iColor, int iAmount);
}
//Baseclass for CItem.\nAllows calling of the base implementation of certain methods.;
class BaseItem {
	//Calls the base class implementation of EndRevive;
	void EndRevive(float flTimeUntilRevive);
	//Calls the base class implementation of BeginRevive;
	void BeginRevive(float flTimeUntilRevive);
	//Calls the base class implementation of IsRevivable;
	bool IsRevivable();
	//Calls the base class implementation of GetPointsForDamage;
	float GetPointsForDamage(float flDamage);
	//Calls the base class implementation of TraceBleed;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Calls the base class implementation of BloodColor;
	int BloodColor();
	//Calls the base class implementation of Killed;
	void Killed(entvars_t@ pevAttacker, int iGib);
	//Calls the base class implementation of TakeArmor;
	bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0);
	//Calls the base class implementation of TakeHealth;
	bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0);
	//Calls the base class implementation of TakeDamage;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Calls the base class implementation of TraceAttack;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType);
	//Calls the base class implementation of ObjectCaps;
	int ObjectCaps();
	//Calls the base class implementation of UpdateOnRemove;
	void UpdateOnRemove();
	//Calls the base class implementation of Blocked;
	void Blocked(CBaseEntity@ pOther);
	//Calls the base class implementation of Use;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Calls the base class implementation of Touch;
	void Touch(CBaseEntity@ pOther);
	//Calls the base class implementation of Think;
	void Think();
	//Calls the base class implementation of PostSpawn;
	void PostSpawn();
	//Calls the base class implementation of Spawn;
	void Spawn();
	//Calls the base class implementation of PreSpawn;
	void PreSpawn();
	//Calls the base class implementation of Precache;
	void Precache();
	//Calls the base class implementation of KeyValue;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Implicitly casts to base type.;
	BaseEntity@ opImplCast();
}
//Baseclass for CBasePlayerAmmo.\nAllows calling of the base implementation of certain methods.;
class BasePlayerAmmo {
	//Calls the base class implementation of EndRevive;
	void EndRevive(float flTimeUntilRevive);
	//Calls the base class implementation of BeginRevive;
	void BeginRevive(float flTimeUntilRevive);
	//Calls the base class implementation of IsRevivable;
	bool IsRevivable();
	//Calls the base class implementation of GetPointsForDamage;
	float GetPointsForDamage(float flDamage);
	//Calls the base class implementation of TraceBleed;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Calls the base class implementation of BloodColor;
	int BloodColor();
	//Calls the base class implementation of Killed;
	void Killed(entvars_t@ pevAttacker, int iGib);
	//Calls the base class implementation of TakeArmor;
	bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0);
	//Calls the base class implementation of TakeHealth;
	bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0);
	//Calls the base class implementation of TakeDamage;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Calls the base class implementation of TraceAttack;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType);
	//Calls the base class implementation of ObjectCaps;
	int ObjectCaps();
	//Calls the base class implementation of UpdateOnRemove;
	void UpdateOnRemove();
	//Calls the base class implementation of Blocked;
	void Blocked(CBaseEntity@ pOther);
	//Calls the base class implementation of Use;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Calls the base class implementation of Touch;
	void Touch(CBaseEntity@ pOther);
	//Calls the base class implementation of Think;
	void Think();
	//Calls the base class implementation of PostSpawn;
	void PostSpawn();
	//Calls the base class implementation of Spawn;
	void Spawn();
	//Calls the base class implementation of PreSpawn;
	void PreSpawn();
	//Calls the base class implementation of Precache;
	void Precache();
	//Calls the base class implementation of KeyValue;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Implicitly casts to base type.;
	BaseEntity@ opImplCast();
}
//Baseclass for CBasePlayerWeapon.\nAllows calling of the base implementation of certain methods.;
class BasePlayerWeapon {
	//Calls the base class implementation of BurstSupplement;
	void BurstSupplement();
	//Calls the base class implementation of UseDecrement;
	bool UseDecrement();
	//Calls the base class implementation of ShouldWeaponIdle;
	bool ShouldWeaponIdle();
	//Calls the base class implementation of RetireWeapon;
	void RetireWeapon();
	//Calls the base class implementation of WeaponIdle;
	void WeaponIdle();
	//Calls the base class implementation of ShouldReload;
	bool ShouldReload();
	//Calls the base class implementation of FinishReload;
	void FinishReload();
	//Calls the base class implementation of Reload;
	void Reload();
	//Calls the base class implementation of TertiaryAttack;
	void TertiaryAttack();
	//Calls the base class implementation of SecondaryAttack;
	void SecondaryAttack();
	//Calls the base class implementation of PrimaryAttack;
	void PrimaryAttack();
	//Calls the base class implementation of IsUseable;
	bool IsUseable();
	//Calls the base class implementation of BulletAccuracy;
	Vector BulletAccuracy(const Vector& in vecMoving, const Vector& in vecStanding, const Vector& in vecCrouched);
	//Calls the base class implementation of SendWeaponAnim;
	void SendWeaponAnim(int iAnim, int skiplocal = 0, int body = 0);
	//Calls the base class implementation of ResetEmptySound;
	void ResetEmptySound();
	//Calls the base class implementation of PlayEmptySound;
	bool PlayEmptySound();
	//Calls the base class implementation of AddWeapon;
	bool AddWeapon();
	//Calls the base class implementation of ExtractAmmo;
	bool ExtractAmmo(CBasePlayerWeapon@ pWeapon);
	//Calls the base class implementation of CanHaveDuplicates;
	bool CanHaveDuplicates();
	//Calls the base class implementation of DropItem;
	CBasePlayerItem@ DropItem();
	//Calls the base class implementation of GetRespawnTime;
	float GetRespawnTime() const;
	//Calls the base class implementation of UpdateClientData;
	bool UpdateClientData(CBasePlayer@ pPlayer);
	//Calls the base class implementation of SecondaryAmmoIndex;
	int SecondaryAmmoIndex();
	//Calls the base class implementation of PrimaryAmmoIndex;
	int PrimaryAmmoIndex();
	//Calls the base class implementation of AttachToPlayer;
	void AttachToPlayer(CBasePlayer@ pPlayer);
	//Calls the base class implementation of Kill;
	void Kill();
	//Calls the base class implementation of InactiveItemPostFrame;
	void InactiveItemPostFrame();
	//Calls the base class implementation of InactiveItemPreFrame;
	void InactiveItemPreFrame();
	//Calls the base class implementation of ItemPostFrame;
	void ItemPostFrame();
	//Calls the base class implementation of ItemPreFrame;
	void ItemPreFrame();
	//Calls the base class implementation of UpdateItemInfo;
	void UpdateItemInfo();
	//Calls the base class implementation of Holster;
	void Holster(int skiplocal = 0);
	//Calls the base class implementation of CanHolster;
	bool CanHolster();
	//Calls the base class implementation of Deploy;
	bool Deploy();
	//Calls the base class implementation of CanDeploy;
	bool CanDeploy();
	//Calls the base class implementation of GetItemInfo;
	void GetItemInfo(ItemInfo& out info);
	//Calls the base class implementation of Materialize;
	void Materialize();
	//Calls the base class implementation of AddDuplicate;
	bool AddDuplicate(CBasePlayerItem@ pItem);
	//Calls the base class implementation of AddToPlayer;
	bool AddToPlayer(CBasePlayer@ pPlayer);
	//Implicitly casts to base type.;
	BasePlayerItem@ opImplCast();
	//Calls the base class implementation of EndRevive;
	void EndRevive(float flTimeUntilRevive);
	//Calls the base class implementation of BeginRevive;
	void BeginRevive(float flTimeUntilRevive);
	//Calls the base class implementation of IsRevivable;
	bool IsRevivable();
	//Calls the base class implementation of GetPointsForDamage;
	float GetPointsForDamage(float flDamage);
	//Calls the base class implementation of TraceBleed;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Calls the base class implementation of BloodColor;
	int BloodColor();
	//Calls the base class implementation of Killed;
	void Killed(entvars_t@ pevAttacker, int iGib);
	//Calls the base class implementation of TakeArmor;
	bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0);
	//Calls the base class implementation of TakeHealth;
	bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0);
	//Calls the base class implementation of TakeDamage;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Calls the base class implementation of TraceAttack;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType);
	//Calls the base class implementation of ObjectCaps;
	int ObjectCaps();
	//Calls the base class implementation of UpdateOnRemove;
	void UpdateOnRemove();
	//Calls the base class implementation of Blocked;
	void Blocked(CBaseEntity@ pOther);
	//Calls the base class implementation of Use;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Calls the base class implementation of Touch;
	void Touch(CBaseEntity@ pOther);
	//Calls the base class implementation of Think;
	void Think();
	//Calls the base class implementation of PostSpawn;
	void PostSpawn();
	//Calls the base class implementation of Spawn;
	void Spawn();
	//Calls the base class implementation of PreSpawn;
	void PreSpawn();
	//Calls the base class implementation of Precache;
	void Precache();
	//Calls the base class implementation of KeyValue;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Implicitly casts to base type.;
	BaseEntity@ opImplCast();
}
//Baseclass for CBasePlayerItem.\nAllows calling of the base implementation of certain methods.;
class BasePlayerItem {
	//Explicitly casts to sub type.;
	BasePlayerWeapon@ opCast();
	//Calls the base class implementation of CanHaveDuplicates;
	bool CanHaveDuplicates();
	//Calls the base class implementation of DropItem;
	CBasePlayerItem@ DropItem();
	//Calls the base class implementation of GetRespawnTime;
	float GetRespawnTime() const;
	//Calls the base class implementation of UpdateClientData;
	bool UpdateClientData(CBasePlayer@ pPlayer);
	//Calls the base class implementation of SecondaryAmmoIndex;
	int SecondaryAmmoIndex();
	//Calls the base class implementation of PrimaryAmmoIndex;
	int PrimaryAmmoIndex();
	//Calls the base class implementation of AttachToPlayer;
	void AttachToPlayer(CBasePlayer@ pPlayer);
	//Calls the base class implementation of Kill;
	void Kill();
	//Calls the base class implementation of InactiveItemPostFrame;
	void InactiveItemPostFrame();
	//Calls the base class implementation of InactiveItemPreFrame;
	void InactiveItemPreFrame();
	//Calls the base class implementation of ItemPostFrame;
	void ItemPostFrame();
	//Calls the base class implementation of ItemPreFrame;
	void ItemPreFrame();
	//Calls the base class implementation of UpdateItemInfo;
	void UpdateItemInfo();
	//Calls the base class implementation of Holster;
	void Holster(int skiplocal = 0);
	//Calls the base class implementation of CanHolster;
	bool CanHolster();
	//Calls the base class implementation of Deploy;
	bool Deploy();
	//Calls the base class implementation of CanDeploy;
	bool CanDeploy();
	//Calls the base class implementation of GetItemInfo;
	void GetItemInfo(ItemInfo& out info);
	//Calls the base class implementation of Materialize;
	void Materialize();
	//Calls the base class implementation of AddDuplicate;
	bool AddDuplicate(CBasePlayerItem@ pItem);
	//Calls the base class implementation of AddToPlayer;
	bool AddToPlayer(CBasePlayer@ pPlayer);
	//Calls the base class implementation of EndRevive;
	void EndRevive(float flTimeUntilRevive);
	//Calls the base class implementation of BeginRevive;
	void BeginRevive(float flTimeUntilRevive);
	//Calls the base class implementation of IsRevivable;
	bool IsRevivable();
	//Calls the base class implementation of GetPointsForDamage;
	float GetPointsForDamage(float flDamage);
	//Calls the base class implementation of TraceBleed;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Calls the base class implementation of BloodColor;
	int BloodColor();
	//Calls the base class implementation of Killed;
	void Killed(entvars_t@ pevAttacker, int iGib);
	//Calls the base class implementation of TakeArmor;
	bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0);
	//Calls the base class implementation of TakeHealth;
	bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0);
	//Calls the base class implementation of TakeDamage;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Calls the base class implementation of TraceAttack;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType);
	//Calls the base class implementation of ObjectCaps;
	int ObjectCaps();
	//Calls the base class implementation of UpdateOnRemove;
	void UpdateOnRemove();
	//Calls the base class implementation of Blocked;
	void Blocked(CBaseEntity@ pOther);
	//Calls the base class implementation of Use;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Calls the base class implementation of Touch;
	void Touch(CBaseEntity@ pOther);
	//Calls the base class implementation of Think;
	void Think();
	//Calls the base class implementation of PostSpawn;
	void PostSpawn();
	//Calls the base class implementation of Spawn;
	void Spawn();
	//Calls the base class implementation of PreSpawn;
	void PreSpawn();
	//Calls the base class implementation of Precache;
	void Precache();
	//Calls the base class implementation of KeyValue;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Implicitly casts to base type.;
	BaseEntity@ opImplCast();
}
//Baseclass for CBaseTank.\nAllows calling of the base implementation of certain methods.;
class BaseTank {
	//Calls the base class implementation of BulletCount;
	int BulletCount();
	//Calls the base class implementation of UpdateTargetPosition;
	Vector UpdateTargetPosition(CBaseEntity@ pTargetEntity);
	//Calls the base class implementation of Fire;
	void Fire(const Vector& in vecBarrelEnd, const Vector& in vecForward, entvars_t@ pevAttacker);
	//Calls the base class implementation of EndRevive;
	void EndRevive(float flTimeUntilRevive);
	//Calls the base class implementation of BeginRevive;
	void BeginRevive(float flTimeUntilRevive);
	//Calls the base class implementation of IsRevivable;
	bool IsRevivable();
	//Calls the base class implementation of GetPointsForDamage;
	float GetPointsForDamage(float flDamage);
	//Calls the base class implementation of TraceBleed;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Calls the base class implementation of BloodColor;
	int BloodColor();
	//Calls the base class implementation of Killed;
	void Killed(entvars_t@ pevAttacker, int iGib);
	//Calls the base class implementation of TakeArmor;
	bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0);
	//Calls the base class implementation of TakeHealth;
	bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0);
	//Calls the base class implementation of TakeDamage;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Calls the base class implementation of TraceAttack;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType);
	//Calls the base class implementation of ObjectCaps;
	int ObjectCaps();
	//Calls the base class implementation of UpdateOnRemove;
	void UpdateOnRemove();
	//Calls the base class implementation of Blocked;
	void Blocked(CBaseEntity@ pOther);
	//Calls the base class implementation of Use;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Calls the base class implementation of Touch;
	void Touch(CBaseEntity@ pOther);
	//Calls the base class implementation of Think;
	void Think();
	//Calls the base class implementation of PostSpawn;
	void PostSpawn();
	//Calls the base class implementation of Spawn;
	void Spawn();
	//Calls the base class implementation of PreSpawn;
	void PreSpawn();
	//Calls the base class implementation of Precache;
	void Precache();
	//Calls the base class implementation of KeyValue;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Implicitly casts to base type.;
	BaseEntity@ opImplCast();
}
//Baseclass for CBaseMonster.\nAllows calling of the base implementation of certain methods.;
class BaseMonster {
	//Calls the base class implementation of GibMonster;
	void GibMonster();
	//Calls the base class implementation of CallGibMonster;
	void CallGibMonster();
	//Calls the base class implementation of RunAI;
	void RunAI();
	//Calls the base class implementation of ScheduleFromName;
	Schedule@ ScheduleFromName(const string& in szName);
	//Calls the base class implementation of GetSchedule;
	Schedule@ GetSchedule();
	//Calls the base class implementation of GetScheduleOfType;
	Schedule@ GetScheduleOfType(int iType);
	//Calls the base class implementation of HandleAnimEvent;
	void HandleAnimEvent(MonsterEvent@ pEvent);
	//Calls the base class implementation of RunTask;
	void RunTask(Task@ pTask);
	//Calls the base class implementation of StartTask;
	void StartTask(Task@ pTask);
	//Calls the base class implementation of SetYawSpeed;
	void SetYawSpeed();
	//Calls the base class implementation of CheckAmmo;
	void CheckAmmo();
	//Calls the base class implementation of CheckMeleeAttack2_Move;
	bool CheckMeleeAttack2_Move(float flDot, float flDist);
	//Calls the base class implementation of CheckMeleeAttack2;
	bool CheckMeleeAttack2(float flDot, float flDist);
	//Calls the base class implementation of CheckMeleeAttack1_Move;
	bool CheckMeleeAttack1_Move(float flDot, float flDist);
	//Calls the base class implementation of CheckMeleeAttack1;
	bool CheckMeleeAttack1(float flDot, float flDist);
	//Calls the base class implementation of CheckRangeAttack2_Move;
	bool CheckRangeAttack2_Move(float flDot, float flDist);
	//Calls the base class implementation of CheckRangeAttack2;
	bool CheckRangeAttack2(float flDot, float flDist);
	//Calls the base class implementation of CheckRangeAttack1_Move;
	bool CheckRangeAttack1_Move(float flDot, float flDist);
	//Calls the base class implementation of CheckRangeAttack1;
	bool CheckRangeAttack1(float flDot, float flDist);
	//Calls the base class implementation of ISoundMask;
	int ISoundMask();
	//Calls the base class implementation of DeathSound;
	void DeathSound();
	//Calls the base class implementation of PainSound;
	void PainSound();
	//Calls the base class implementation of AlertSound;
	void AlertSound();
	//Calls the base class implementation of IgnoreConditions;
	int IgnoreConditions();
	//Calls the base class implementation of Classify;
	int Classify();
	//Calls the base class implementation of SetupFriendly;
	void SetupFriendly();
	//Calls the base class implementation of EndRevive;
	void EndRevive(float flTimeUntilRevive);
	//Calls the base class implementation of BeginRevive;
	void BeginRevive(float flTimeUntilRevive);
	//Calls the base class implementation of IsRevivable;
	bool IsRevivable();
	//Calls the base class implementation of GetPointsForDamage;
	float GetPointsForDamage(float flDamage);
	//Calls the base class implementation of TraceBleed;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Calls the base class implementation of BloodColor;
	int BloodColor();
	//Calls the base class implementation of Killed;
	void Killed(entvars_t@ pevAttacker, int iGib);
	//Calls the base class implementation of TakeArmor;
	bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0);
	//Calls the base class implementation of TakeHealth;
	bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0);
	//Calls the base class implementation of TakeDamage;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Calls the base class implementation of TraceAttack;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType);
	//Calls the base class implementation of ObjectCaps;
	int ObjectCaps();
	//Calls the base class implementation of UpdateOnRemove;
	void UpdateOnRemove();
	//Calls the base class implementation of Blocked;
	void Blocked(CBaseEntity@ pOther);
	//Calls the base class implementation of Use;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Calls the base class implementation of Touch;
	void Touch(CBaseEntity@ pOther);
	//Calls the base class implementation of Think;
	void Think();
	//Calls the base class implementation of PostSpawn;
	void PostSpawn();
	//Calls the base class implementation of Spawn;
	void Spawn();
	//Calls the base class implementation of PreSpawn;
	void PreSpawn();
	//Calls the base class implementation of Precache;
	void Precache();
	//Calls the base class implementation of KeyValue;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Implicitly casts to base type.;
	BaseEntity@ opImplCast();
}
//Baseclass for CBaseEntity.\nAllows calling of the base implementation of certain methods.;
class BaseEntity {
	//Explicitly casts to sub type.;
	BaseItem@ opCast();
	//Explicitly casts to sub type.;
	BasePlayerAmmo@ opCast();
	//Explicitly casts to sub type.;
	BasePlayerWeapon@ opCast();
	//Explicitly casts to sub type.;
	BasePlayerItem@ opCast();
	//Explicitly casts to sub type.;
	BaseTank@ opCast();
	//Explicitly casts to sub type.;
	BaseMonster@ opCast();
	//Calls the base class implementation of EndRevive;
	void EndRevive(float flTimeUntilRevive);
	//Calls the base class implementation of BeginRevive;
	void BeginRevive(float flTimeUntilRevive);
	//Calls the base class implementation of IsRevivable;
	bool IsRevivable();
	//Calls the base class implementation of GetPointsForDamage;
	float GetPointsForDamage(float flDamage);
	//Calls the base class implementation of TraceBleed;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Calls the base class implementation of BloodColor;
	int BloodColor();
	//Calls the base class implementation of Killed;
	void Killed(entvars_t@ pevAttacker, int iGib);
	//Calls the base class implementation of TakeArmor;
	bool TakeArmor(float flArmor, int bitsDamageType, float armor_cap = 0);
	//Calls the base class implementation of TakeHealth;
	bool TakeHealth(float flHealth, int bitsDamageType, float health_cap = 0);
	//Calls the base class implementation of TakeDamage;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Calls the base class implementation of TraceAttack;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in ptr, int bitsDamageType);
	//Calls the base class implementation of ObjectCaps;
	int ObjectCaps();
	//Calls the base class implementation of UpdateOnRemove;
	void UpdateOnRemove();
	//Calls the base class implementation of Blocked;
	void Blocked(CBaseEntity@ pOther);
	//Calls the base class implementation of Use;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Calls the base class implementation of Touch;
	void Touch(CBaseEntity@ pOther);
	//Calls the base class implementation of Think;
	void Think();
	//Calls the base class implementation of PostSpawn;
	void PostSpawn();
	//Calls the base class implementation of Spawn;
	void Spawn();
	//Calls the base class implementation of PreSpawn;
	void PreSpawn();
	//Calls the base class implementation of Precache;
	void Precache();
	//Calls the base class implementation of KeyValue;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
}
//Custom entity functions.;
class CCustomEntityFuncs {
	//Unregisters a custom entity by the given name;
	void UnRegisterCustomEntity(const string& in szEntityname);
	//Registers a class called szClassname as a custom entity named szEntityname. The class must inherit from a script entity base class.;
	void RegisterCustomEntity(const string& in szClassname, const string& in szEntityname);
	//Returns whether the given entity name is a registered custom entity;
	bool IsCustomEntity(const string& in szEntityname) const;
}
//Custom entity callback handler. Is used to set callbacks to methods;
class CustomEntityCallbackHandler {
	//Sets the use function for this handler\'s owning instance.;
	void SetUseFunction(UseFunction@ pFunction);
	//Sets the blocked function for this handler\'s owning instance.;
	void SetBlockedFunction(BlockedFunction@ pFunction);
	//Sets the touch function for this handler\'s owning instance.;
	void SetTouchFunction(TouchFunction@ pFunction);
	//Sets the think function for this handler\'s owning instance.;
	void SetThinkFunction(ThinkFunction@ pFunction);
}
//Entity loader.\nLoads entity keyvalue data and instances the entities.\nFile format:\nEntity{\tclassname info_player_deathmatch\t<additional keyvalues>}...;
class CEntityLoader {
	//Loads entities from a file.;
	bool LoadFromFile(const string& in szFileName, const Vector& in vecOffset = g_vecZero);
}
//Item registry.;
class CItemRegistry {
	//Registers the given entity name as a weapon and returns the id associated with it.\nReturns WEAPON_NONE if no id could be assigned to it.;
	int RegisterWeapon(const string& in szName, const string& in szSpriteDir, const string& in szPrimaryAmmoName = "", const string& in szSecondaryAmmoName = "", const string& in szPrimaryAmmoClass = "", const string& in szSecondaryAmmoClass = "");
	//Registers the given entity name as an item and returns the id associated with it.\nReturns WEAPON_NONE if no id could be assigned to it.;
	int RegisterItem(const string& in szName, const string& in szSpriteDir, const string& in szPrimaryAmmoName = "", const string& in szSecondaryAmmoName = "", const string& in szPrimaryAmmoClass = "", const string& in szSecondaryAmmoClass = "");
	//Gets the id associated with the given weapon name. Returns WEAPON_NONE if no id is associated with the given name.;
	int GetIdForName(const string& in szName) const;
}
//Item info object.;
class ItemInfo {
	//Gets the secondary ammo name of this weapon.;
	string szAmmo2() const;
	//Gets the primary ammo name of this weapon.;
	string szAmmo1() const;
	//Gets the name of this weapon.;
	string szName() const;
	//Assignment operator;
	ItemInfo& opAssign(const ItemInfo& in other);
	//Constructor;
	void ItemInfo(const ItemInfo& in other);
	//Constructor;
	void ItemInfo();
	//Item primary ammo max clip contents.;
	int iMaxClip;
	//Amount of dropped secondary ammo.;
	int iAmmo2Drop;
	//Item secondary max ammo. -1 if this weapon does not use secondary ammo.;
	int iMaxAmmo2;
	//Amount of dropped primary ammo.;
	int iAmmo1Drop;
	//Item primary max ammo. -1 if this weapon does not use primary ammo.;
	int iMaxAmmo1;
	//Item weight.\nThis value used to determine this weapon\'s importance in autoselection.;
	int iWeight;
	//Item flags.;
	int iFlags;
	//Item HUD slot position.;
	int iPosition;
	//Item HUD slot.;
	int iSlot;
	//Item id.;
	int iId;
}
//Misc functions for handling inventories across classes;
class CInventoryMisc {
	//Clears all held inventory;
	void RemoveAllFromHolder(CBaseMonster@ pHolder, const bool fDrop = false, const bool fBlockingWeaponsOnly = false, const bool fKeepOnRespawn = false);
	//Returns true if is holding all items of a group;
	bool HasAllInGroup(CBaseMonster@ pHolder, const string& in szGroup);
	//Returns count of how many items someone holds of a group;
	int HaveNumFromGroup(CBaseMonster@ pHolder, const string& in szGroup);
	//Counts all the existing items in a group;
	int ExistsInGroup(const string& in szGroup);
	//Gets the total weight of all inventory items held by the given holder;
	float GetWeight(CBaseMonster@ pHolder);
	//Counts the number of inventory items held by the given holder;
	int Count(CBaseMonster@ pHolder);
	//Returns whether the given value is in the given rule;
	bool CheckTokenStringRule(const string& in szRule, const string& in szValue);
	//Returns whether the given entity is a valid inventory holder;
	bool IsValidInventoryHolder(CBaseEntity@ pOther);
}
//Structure for a list of item_inventory\'s stored within CBaseMonster;
class InventoryList {
	//Next item in the list;
	InventoryList@ pNext;
	//Item;
	EHandle hItem;
}
//Inventory rules: Contained by CBaseToggle to hold and\nmanage inventory rules attached to a triggerable entity;
class InventoryRules {
	//Returns whether the owning trigger can be triggered by the given activator.;
	bool CanUseTrigger(CBaseEntity@ pActivator, bool fContinueByDefault = false);
	//Target: Inventory rules failed;
	string_t m_szTargetOnFail;
	//On pass: Ignore item\'s on destroy triggers?;
	bool m_fIgnoreDestroyTriggers;
	//On pass: Destroy item(s) in these group(s);
	string_t m_szDestroyItemGroupOnUse;
	//On pass: Destroy item(s);
	string_t m_szDestroyItemNameOnUse;
	//On pass: Ignore item\'s on return triggers?;
	bool m_fIgnoreReturnTriggers;
	//On pass: Return item(s) in these group(s);
	string_t m_szReturnItemGroupOnUse;
	//On pass: Return item(s);
	string_t m_szReturnItemNameOnUse;
	//On pass: Ignore item\'s on drop triggers?;
	bool m_fIgnoreDropTriggers;
	//On pass: Drop item(s) in these group(s);
	string_t m_szDropItemGroupOnUse;
	//On pass: Drop item(s);
	string_t m_szDropItemNameOnUse;
	//On pass: Ignore item\'s on use triggers?;
	bool m_fIgnoreUseTriggers;
	//Inventory: Number of item(s) from the can\'t have group(s) (0 = all);
	int m_iCantHaveItemGroupNum;
	//Inventory: Must not have an item in these group(s);
	string_t m_szCantHaveItemGroup;
	//Inventory: Must not have these item(s);
	string_t m_szCantHaveItemName;
	//Inventory: Number of item(s) from the required group(s) required (0 = all);
	int m_iRequiresItemGroupNum;
	//Inventory: Require an item from these group(s);
	string_t m_szRequiresItemGroup;
	//Inventory: Require these item(s);
	string_t m_szRequiresItemName;
	//Owning entity;
	EHandle m_hEntity;
}
//Sound manager entity. Manages sound events made in the world, like gunfire.\nDoes not handle the playing of sounds, see CSoundEngine for actual sound playing.;
class CSoundEnt {
	//Returns the number of sounds in the given list. Must be either SOUNDLISTTYPE_FREE or SOUNDLISTTYPE_ACTIVE.;
	int ISoundsInList(int iListType);
	//Returns whether the sound list is empty.;
	bool IsEmpty();
	//Gets the index for the given client.;
	int ClientSoundIndex(edict_t@ pClient);
	//Return a pointer for this index in the sound list.\nIndex must be between 0 and MAX_WORLD_SOUNDS.;
	CSound@ SoundPointerForIndex(int iIndex);
	//Returns the head of the free list.;
	int FreeList();
	//Returns the head of the active list.;
	int ActiveList();
	//Inserts a sound. iType is one of the bits_SOUND enum.;
	void InsertSound(int iType, const Vector& in vecOrigin, int iVolume, float flDuration, CBaseEntity@ pOwner);
	//keeps track of the number of active sounds at the last update. (for diagnostic work);
	const int m_cLastActiveSounds;
}
//Sound class used by CSoundEnt;
class CSound {
	//Returns whether this is a scent;
	bool FIsScent();
	//Returns whether this is a sound;
	bool FIsSound();
	//Resets the sound;
	void Reset();
	//Clears the sound;
	void Clear();
	//Sounds now have OWNERS... (For various AI checks);
	EHandle hOwner;
	//Temporary link that monsters use to build a list of audible sounds;
	int m_iNextAudible;
	//Index of next sound in this list ( Active or Free );
	int m_iNext;
	//When the sound should be purged from the list;
	float m_flExpireTime;
	//How loud the sound is;
	int m_iVolume;
	//What type of sound this is;
	int m_iType;
	//Sound\'s location in space;
	Vector m_vecOrigin;
}
//Model functions;
class CModelFuncs {
	//Gets the number of attachments in a model.;
	int GetAttachmentCount(int iModelIndex);
	//Gets the number of submodels.;
	int GetBodygroupSubmodelCount(int iModelIndex, int iGroup);
	//Gets bodygroup configuration.;
	int GetBodygroup(int iModelIndex, int iBody, int iGroup);
	//Builds bodygroup configuration.;
	int SetBodygroup(int iModelIndex, int iBody, int iGroup, int iValue);
	//Gets model index.;
	int ModelIndex(const string& in szModelName);
}
//Engine functions;
class CEngineFuncs {
	//Get the player\'s Auth ID. (WON/Steam ID);
	string GetPlayerAuthId(edict_t@ pEdict);
	//Voice system - Set client listening.;
	bool Voice_SetClientListening(int iReceiver, int iSender, bool fListen);
	//Voice system - Get client listening.;
	bool Voice_GetClientListening(int iReceiver, int iSender);
	//Get player stats.;
	void GetPlayerStats(const edict_t@ pEdict, int& out iPing, int& out iPacketLoss);
	//Gets a pointer to a cvar.;
	const Cvar@ CVarGetPointer(const string& in szCvar) const;
	//Returns whether this is a dedicated server.;
	bool IsDedicatedServer() const;
	//Get player user ID. This is a unique id generated when a player connects. It remains valid as long as the player stays connected to the server.;
	int GetPlayerUserId(edict_t@ pEdict);
	//Project a static decal.;
	void StaticDecal(const Vector& in vecOrigin, int iDecalIndex, int iEntityIndex, int iModelIndex);
	//Returns whether the given map is valid.;
	bool IsMapValid(const string& in szMapName) const;
	//Get physics key buffer.;
	KeyValueBuffer@ GetPhysicsKeyBuffer(edict_t@ pEdict);
	//Get info key buffer.;
	KeyValueBuffer@ GetInfoKeyBuffer(edict_t@ pEdict);
	//Get number of entities.;
	int NumberOfEntities();
	//Run player move.;
	void RunPlayerMove(edict_t@ pEdict, const Vector& in vecViewAngles, float flFowardMove, float flSideMove, float flUpMove, uint16 iButtons, uint8 iImpulse, uint8 iMsec);
	//Get game directory.;
	string GetGameDir();
	//Sets the angles of the given player\'s crosshairs to the given settings. Set both to 0 to disable. May not have any effect in SC.;
	void CrosshairAngle(const edict_t@ pEdict, float flPitch, float flYaw);
	//Get current time.;
	float Time();
	//Set view.;
	void SetView(const edict_t@ pEdict, const edict_t@ pViewEntity);
	//Get attachment position.;
	void GetAttachment(const edict_t@ pEdict, int iAttachment, Vector& out vecOrigin, Vector& out vecAngles);
	//Get number of command arguments.;
	int Cmd_Argc();
	//Get command argument by index.;
	string Cmd_Argv(int iIndex);
	//Get command arguments.;
	string Cmd_Args();
	//Server print;
	void ServerPrint(const string& in szMessage);
	//Client print;
	void ClientPrintf(CBasePlayer@ pPlayer, PRINT_TYPE printType, const string& in szMessage);
	//Get bone position.;
	void GetBonePosition(const edict_t@ pEdict, int iBone, Vector& out vecOrigin, Vector& out vecAngles);
	//Find entity by variables.;
	edict_t@ FindEntityByVars(entvars_t@ pVars);
	//Get entity by entity index.;
	edict_t@ PEntityOfEntIndex(int iIndex);
	//Get index of edict.;
	int IndexOfEdict(const edict_t@ pEdict);
	//Gets entity variables of entity.;
	entvars_t@ GetVarsOfEnt(edict_t@ pEdict);
	//Set cvar string value.;
	void CVarSetString(const string& in szCvar, const string& in szValue);
	//Set cvar float value.;
	void CVarSetFloat(const string& in szCvar, float flValue);
	//Get cvar string value.;
	string CVarGetString(const string& in szCvar);
	//Get cvar float value.;
	float CVarGetFloat(const string& in szCvar);
	//Check if point is in contents.;
	CONTENTS PointContents(const Vector& in vecPoint);
	//Get decal index.;
	int DecalIndex(const string& in szName);
	//Set a light style.;
	void LightStyle(int iStyle, const string& in szVal);
	//Emit a particle effect.;
	void ParticleEffect(const Vector& in vecOrigin, const Vector& in vecDir, float flColor, float flCount);
	//Executes all pending server commands. Plugins only.;
	void ServerExecute();
	//Issues a command to the server. Plugins only.;
	void ServerCommand(const string& in szCommand);
	//Get aim vector for entity.;
	void GetAimVector(edict_t@ pEntity, float flSpeed, Vector& out vecReturn);
	//Make entity walk.\nSee WALKMOVE enum;
	int WalkMove(edict_t@ pEntity, float flYaw, float flDist, int iMove);
	//Drop entity to floor.;
	int DropToFloor(edict_t@ pEntity);
	//Returns whether entity is on the floor.;
	int EntIsOnFloor(edict_t@ pEntity);
	//Make entity static. This moves the entity to the client.Its current visual state is copied over, and the entity is removed on the server side.Only valid while the level is loading.;
	void MakeStatic(edict_t@ pEntity);
	//Angle vectors;
	void AngleVectors(const Vector& in vecIn, Vector& out vecForward, Vector& out vecRight, Vector& out vecUp);
	//Make vectors. The results are stored in g_Engine::v_forward, v_right, and v_up.;
	void MakeVectors(const Vector& in vec);
	//Find entities in Potentially Visible Set. Edict::vars::chain is used for this list, and is temporary.;
	edict_t@ EntitiesInPVS(edict_t@ pStartEntity);
	//Find client in Potentially Visible Set.;
	edict_t@ FindClientInPVS(edict_t@ pStartEntity);
	//Get entity illumination. This is a weighted value between 0 and 255, inclusive.;
	int GetEntityIllum(edict_t@ pEntity);
	//Change pitch. This updates entvars_t::angles[ 0 ] to approach entvars_t::idealpitch, at entvars_t::pitch_speed degrees speed.;
	void ChangePitch(edict_t@ pEntity);
	//Change yaw. This updates entvars_t::angles[ 1 ] to approach entvars_t::ideal_yaw, at entvars_t::yaw_speed degrees speed.;
	void ChangeYaw(edict_t@ pEntity);
	//Move entity to origin.;
	void MoveToOrigin(edict_t@ pEntity, const Vector& in vecGoal, float flDist, int iMoveType);
	//Vector to angles;
	void VecToAngles(const Vector& in vec, Vector& out angles);
	//Vector to yaw;
	float VecToYaw(const Vector& in vec);
	//Changes the current level to the one specified.;
	void ChangeLevel(const string& in szLevelName);
	//Gets the number of frames in a model.;
	int ModelFrames(int iModelIndex);
	//Gets the model index of a model.;
	int ModelIndex(const string& in szModelName);
}
//Buffer containing keyvalue pairs;
class KeyValueBuffer {
	//Removes a key value. If this is a physics key buffer, this will set the key to an empty string instead.;
	void RemoveValue(const string& in szKey);
	//Sets a key value.;
	void SetValue(const string& in szKey, const string& in szValue) const;
	//Gets a key value;
	string GetValue(const string& in szKey) const;
	//Gets the client that this buffer belongs to.;
	edict_t@ GetClient() const;
}
//Cvar structure;
class Cvar {
	//Gets the value of the cvar as a string.;
	string GetString();
	//Gets the name of the cvar.;
	string GetName();
	//The value of this cvar as a float.;
	const float value;
	//The flags of this cvar.;
	const int flags;
}
//Damage info structure;
class DamageInfo {
	//Damage type.;
	int bitsDamageType;
	//Damage amount.;
	float flDamage;
	//Attacker entity.;
	CBaseEntity@ pAttacker;
	//Inflictor entity.;
	CBaseEntity@ pInflictor;
	//Victim entity.;
	CBaseEntity@ pVictim;
}
//Trace result structure;
class TraceResult {
	//Assignment operator;
	TraceResult& opAssign(const TraceResult& in tr);
	//Constructor.;
	void TraceResult(const TraceResult& in tr);
	//Constructor.;
	void TraceResult();
	//Hit group.;
	int iHitgroup;
	//Hit entity;
	edict_t@ pHit;
	//Plane normal;
	Vector vecPlaneNormal;
	//Plane distance.;
	float flPlaneDist;
	//End position.;
	Vector vecEndPos;
	//Fraction.;
	float flFraction;
	//Flag telling whether the trace ended in water;
	int fInWater;
	//Flag telling whether the trace ended in an open area.;
	int fInOpen;
	//Flag telling whether the trace started in a solid area.;
	int fStartSolid;
	//Flag telling whether the trace occured in an all solid area.;
	int fAllSolid;
}
//Observer mode management class.;
class Observer {
	//Removes the player\'s dead body, if it exists.;
	void RemoveDeadBody();
	//Sets whether this player can control the observer mode.;
	void SetObserverModeControlEnabled(bool fEnabled);
	//Returns whether this player can control the observer mode.;
	bool CanControlObserverMode() const;
	//Returns whether this player has a corpse.;
	bool HasCorpse();
	//Find a point to start a player at for observer.;
	CBaseEntity@ FindObserverStartPoint();
	//Sets the observer mode.;
	void SetMode(ObserverMode iMode);
	//Handles button input.;
	void HandleButtons();
	//Find the next player to observe.;
	void FindNextPlayer(bool fReverse);
	//Stops observer mode.;
	void StopObserver(bool fRespawn);
	//Starts observer mode.;
	void StartObserver(const Vector& in vecPosition, const Vector& in vecViewAngle, bool fCreateBody = true);
	//Returns whether this player is an observer.;
	bool IsObserver() const;
	//Returns whether this player can use observer mode.;
	bool CanUseObserver();
	//Sets the observer target.;
	void SetObserverTarget(CBasePlayer@ pPlayer);
	//Resets the observer target and finds the next suitable candidate.;
	void ResetObserverTarget();
	//Gets the current observer target, if any.;
	CBaseEntity@ GetObserverTarget();
}
//Monster event type;
class MonsterEvent {
	//Options. Usually a sound name.;
	string options() const;
	//Event type.\nSee MonsterEventType enum;
	int event;
}
//Waypoint for monsters to follow.;
class Waypoint {
	//Type(s) of this waypoint.;
	int iType;
	//How long to wait on this waypoint.;
	float flSavedMoveWait;
	//Handle to a door to use.;
	EHandle hDoor;
	//Saved ladder velocity.;
	Vector vecLadderVelocity;
	//Saved jump velocity.;
	Vector vecJumpVelocity;
	//Location of this waypoint.;
	Vector vecLocation;
}
//Script schedule class;
class ScriptSchedule {
	//Adds a task to the list;
	void AddTask(const ScriptTask& in task);
	//Cast to Schedule;
	Schedule@ opImplCast();
	//Constructor;
	ScriptSchedule@ ScriptSchedule(int iInterruptMask, int iSoundMask, const string& in szName);
	//Gets the name of this schedule.;
	string szName() const;
	//Gets a task in this schedule.\nMust be between 0 and cTasks.;
	Task@ GetTask(int iIndex) const;
	//A more specific mask that indicates which TYPES of sounds will interrupt the schedule in the event that the schedule is broken by COND_HEAR_SOUND.;
	int iSoundMask;
	//A bit mask of conditions that can interrupt this schedule.;
	int iInterruptMask;
	//Number of tasks in this schedule.;
	int cTasks;
}
//Script task class;
class ScriptTask {
	//Constructor;
	void ScriptTask(int iTask, float flData = 0.0f);
	//Constructor;
	void ScriptTask();
	//Task data;
	float flData;
	//Task to execute.\nCan be monster-specific.;
	int iTask;
}
//Schedule for monsters to follow.;
class Schedule {
	//Gets the name of this schedule.;
	string szName() const;
	//Gets a task in this schedule.\nMust be between 0 and cTasks.;
	Task@ GetTask(int iIndex) const;
	//A more specific mask that indicates which TYPES of sounds will interrupt the schedule in the event that the schedule is broken by COND_HEAR_SOUND.;
	int iSoundMask;
	//A bit mask of conditions that can interrupt this schedule.;
	int iInterruptMask;
	//Number of tasks in this schedule.;
	int cTasks;
}
//Task for monsters to execute.;
class Task {
	//Task data;
	float flData;
	//Task to execute.\nCan be monster-specific.;
	int iTask;
}
//Activity map;
class CActivityMap {
	//Gets the name of the given activity;
	string GetName(Activity activity) const;
}
//Custom keyvalues. Do not keep handles to instances of these objects.;
class CustomKeyvalues {
	//Gets the keyvalue with the given name. Check if it exists by calling Exists.;
	CustomKeyvalue GetKeyvalue(const string& in szKey) const;
	//Returns whether the keyvalue with the given name exists.;
	bool HasKeyvalue(const string& in szKey) const;
	//Initializes a keyvalue with the default value for its type.;
	void InitializeKeyvalueWithDefault(const string& in szKey);
	//Sets a custom keyvalue to the given integer value.\nReturns true if the key existed and was overwritten.;
	bool SetKeyvalue(const string& in szKey, int iValue);
	//Sets a custom keyvalue to the given float value.\nReturns true if the key existed and was overwritten.;
	bool SetKeyvalue(const string& in szKey, float flValue);
	//Sets a custom keyvalue to the given vector value.\nReturns true if the key existed and was overwritten.;
	bool SetKeyvalue(const string& in szKey, const Vector& in vecValue);
	//Sets a custom keyvalue to the given string value.\nReturns true if the key existed and was overwritten.;
	bool SetKeyvalue(const string& in szKey, const string& in szValue);
}
//Custom keyvalue. Only use this as a local variable, do not store them!;
class CustomKeyvalue {
	//Gets the value as an integer.;
	int GetInteger() const;
	//Gets the value as a float.;
	float GetFloat() const;
	//Gets the value as a vector.;
	Vector GetVector() const;
	//Gets the value as a string.;
	string GetString() const;
	//Gets the type of the keyvalue.\nReturns VAR_INVALID if this value does not exist.;
	Entvartype GetType() const;
	//Returns whether the value exists.;
	bool Exists() const;
	//Constructor;
	void CustomKeyvalue(const CustomKeyvalue& in other);
	//Constructor;
	void CustomKeyvalue();
}
//Safe way to point to CBaseEntities who may die between frames.;
class EHandle {
	//CBaseEntity serial number. Used to determine if the entity is still valid.;
	int GetSerialNumber() const;
	//Makes this handle refer to the same entity as the given handle.;
	EHandle& opAssign(const EHandle& in other);
	//Assigns the given entity to this handle.;
	CBaseEntity@ opAssign(CBaseEntity@ pEntity);
	//Gets the Entity this handle refers to.\nReturns null if invalid.;
	CBaseEntity@ opImplCast() const;
	//Gets the Entity this handle refers to.\nReturns null if invalid.;
	CBaseEntity@ GetEntity() const;
	//Returns whether this handle is valid.;
	bool opImplConv() const;
	//Returns whether this handle is valid.;
	bool IsValid() const;
	//Constructs this handle with a reference to the given entity.;
	void EHandle(CBaseEntity@ pEntity);
	//Copy constructs this handle.;
	void EHandle(const EHandle& in other);
	//Default constructs this handle.;
	void EHandle();
}
//Gib class;
class CGib {
	//Limits the velocity of the gib;
	void LimitVelocity();
	//Spawns the gib with the given model. Note: this sets several of CGib\'s variables. Set variables after calling this.;
	void Spawn(const string& in szModelName);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Lifetime of this gib, in seconds;
	float m_lifeTime;
	//Gib material type. One of the Materials enum values should be used here.;
	int m_material;
	//Maximum number of blood decals this gib can spray.;
	int m_cBloodDecals;
	//The color of the blood that is sprayed onto walls when the gib touches it.;
	int m_bloodColor;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Door entity base class;
class CBaseDoor {
	//If the door is moving, changes the movement direction. Returns true if the door was moving.;
	bool DoorChangeDirection();
	//Makes the door go down.;
	void DoorGoDown();
	//Makes the door go up.;
	void DoorGoUp();
	//Door touch function.;
	void DoorTouch(CBaseEntity@ pOther);
	//The inventory rules.;
	InventoryRules@ get_m_pInventoryRules() const;
	//Returns whether this entity is locked by its master.\nSeparate from IsLockedByMaster due to limitations.;
	bool IsToggleLockedByMaster();
	//Performs angular movement.;
	void AngularMove(Vector vecDestAngle, float flSpeed);
	//Performs linear movement.;
	void LinearMove(Vector vecDest, float flSpeed);
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//Implicitly casts to base type.;
	CBaseAnimating@ opImplCast();
	//Implicitly casts to base type.;
	CBaseToggle@ opImplCast();
	//This entity\'s master, if any.;
	string_t m_sMaster;
	//DMG_ damage type that the door or trigger does.;
	int m_bitsDamageInflict;
	//Final angle.;
	Vector m_vecFinalAngle;
	//Final destination.;
	Vector m_vecFinalDest;
	//Open angle.;
	Vector m_vecAngle2;
	//Closed angle.;
	Vector m_vecAngle1;
	//Open position.;
	Vector m_vecPosition2;
	//Closed position.;
	Vector m_vecPosition1;
	//Handle to the activator.;
	EHandle m_hActivator;
	//Height.;
	float m_flHeight;
	//Trigger_counter only: # of activations remaining.;
	int m_cTriggersLeft;
	//For plats.;
	float m_flTLength;
	//For plats.;
	float m_flTWidth;
	//How much to stick out of a wall. Will recede further into walls if negative.;
	float m_flLip;
	//How long to wait before resetting.;
	float m_flWait;
	//How far a door should slide or rotate.;
	float m_flMoveDistance;
	//Current toggle state.;
	TOGGLE_STATE m_toggle_state;
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Button entity base class;
class CBaseButton {
	//Gets the button response to a touch event.;
	ButtonCode ButtonResponseToTouch();
	//Button Use function.;
	void ButtonUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue);
	//Button has returned to start state.  Quiesce it.;
	void ButtonBackHome();
	//Starts the button moving out/down;
	void ButtonReturn();
	//Button has reached the in/up position.  Activate its targets, and pause before popping out.;
	void TriggerAndWait();
	//Makes the button start sparking. The button will spark randomly after this.;
	void ButtonSpark();
	//Button Touch function.;
	void ButtonTouch(CBaseEntity@ pOther);
	//Activates the button.;
	void ButtonActivate();
	//The inventory rules.;
	InventoryRules@ get_m_pInventoryRules() const;
	//Returns whether this entity is locked by its master.\nSeparate from IsLockedByMaster due to limitations.;
	bool IsToggleLockedByMaster();
	//Performs angular movement.;
	void AngularMove(Vector vecDestAngle, float flSpeed);
	//Performs linear movement.;
	void LinearMove(Vector vecDest, float flSpeed);
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//Implicitly casts to base type.;
	CBaseAnimating@ opImplCast();
	//Implicitly casts to base type.;
	CBaseToggle@ opImplCast();
	//a rotating button?  default is a sliding button.;
	bool m_fRotating;
	//button stays pushed in until touched again?;
	bool m_fStayPushed;
	//This entity\'s master, if any.;
	string_t m_sMaster;
	//DMG_ damage type that the door or trigger does.;
	int m_bitsDamageInflict;
	//Final angle.;
	Vector m_vecFinalAngle;
	//Final destination.;
	Vector m_vecFinalDest;
	//Open angle.;
	Vector m_vecAngle2;
	//Closed angle.;
	Vector m_vecAngle1;
	//Open position.;
	Vector m_vecPosition2;
	//Closed position.;
	Vector m_vecPosition1;
	//Handle to the activator.;
	EHandle m_hActivator;
	//Height.;
	float m_flHeight;
	//Trigger_counter only: # of activations remaining.;
	int m_cTriggersLeft;
	//For plats.;
	float m_flTLength;
	//For plats.;
	float m_flTWidth;
	//How much to stick out of a wall. Will recede further into walls if negative.;
	float m_flLip;
	//How long to wait before resetting.;
	float m_flWait;
	//How far a door should slide or rotate.;
	float m_flMoveDistance;
	//Current toggle state.;
	TOGGLE_STATE m_toggle_state;
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Path condition entity;
class CPathCondition {
}
//Tank base class;
class CBaseTank {
	//Gets the current player controlling this tank, if any.;
	const CBasePlayer@ GetController();
	//Looks around itself in a box that is iDistance * 2 in width and height for possible targets and stores the list in m_pLink.\nThe target stores the next target in the list in its m_pLink, and so on.;
	void Look(int iDistance);
	//If a monster is controlling this tank, makes the monster stop controlling the tank.;
	void MonsterStopControl();
	//If a player is controlling this tank, makes the player stop controlling the tank.;
	void StopControl();
	//Makes the given player start controlling this tank.;
	bool StartControl(CBasePlayer@ pController);
	//Adjusts the given angles to point at the target.;
	Vector AdjustAnglesForBarrel(const Vector& in vecInAngles, float flDistance);
	//Gets the bullet count at this time.;
	int BulletCount();
	//Returns the barrel position.;
	Vector BarrelPosition();
	//Performs a traceline using a random spread based on the given spread amount.;
	void TankTrace(const Vector& in vecStart, const Vector& in vecForward, const Vector& in vecSpread, TraceResult& out tr);
	//Makes the given monster begin controlling this tank, if no other monster had control before.;
	void MonsterStartup(CBaseMonster@ pMonster);
	//Finds a target to attack, if any.;
	CBaseEntity@ FindTarget();
	//Returns whether the given range is within the minimum and maximum range of this tank.;
	bool InRange(float flRange);
	//Returns whether this tank is able to fire.;
	bool CanFire() const;
	//Deactivates the tank. Active tanks are AI controlled.;
	void TankDeactivate();
	//Activates the tank. Active tanks are AI controlled.;
	void TankActivate();
	//Returns whether the tank is active. Active tanks are AI controlled.;
	bool IsActive() const;
	//Stop playing the rotating sound.;
	void StopRotSound();
	//Start playing the rotating sound, if defined.;
	void StartRotSound();
	//Gets the updated position of the given target. Target must be valid.;
	Vector UpdateTargetPosition(CBaseEntity@ pTargetEntity);
	//Fires the tank. Uses this tank\'s settings to fire, does not determine if it is targeting anything.;
	void Fire();
	//Fires the tank. Barrel end position, aiming direction and attacker entvars_t must be given.;
	void Fire(const Vector& in vecBarrelEnd, const Vector& in vecForward, entvars_t@ pevAttacker);
	//Points the tank at the target location.;
	bool PointAt(const Vector& in vecDestination);
	//Updates the tank\'s angles to match either its controlling player, or its current target.Accounts for rotation speed. Will fire at the target if it\'s automated.;
	void TrackTarget();
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Master entity (game_team_master or multisource);
	string_t m_iszMaster;
	//firing spread;
	int m_spread;
	//Last sight of target;
	Vector m_sightOrigin;
	//0 means use Bullet type\'s default damage;
	int m_iBulletDamage;
	//Bullet type;
	TANKBULLET m_bulletType;
	//Scale of any sprites we shoot;
	float m_spriteScale;
	//Length of the freakin barrel;
	Vector m_barrelPos;
	//Max range to aim/track;
	float m_maxRange;
	//Minimum range to aim/track;
	float m_minRange;
	//Persistence of firing (how long do I shoot when I can\'t see);
	float m_persist;
	//Last time I saw target;
	float m_lastSightTime;
	//How many rounds/second;
	float m_fireRate;
	//Last time I fired;
	float m_fireLast;
	//Tolerance angle;
	float m_pitchTolerance;
	//Range of pitch motion as above;
	float m_pitchRange;
	//Max turn rate on pitch;
	float m_pitchRate;
	//Center pitch;
	float m_pitchCenter;
	//Tolerance angle;
	float m_yawTolerance;
	//Range of turning motion (one-sided: 30 is +/- 30 degress from center)\nZero is full rotation;
	float m_yawRange;
	//Max turn rate to track targets;
	float m_yawRate;
	//Center yaw;
	float m_yawCenter;
	//Next attack time;
	float m_flNextAttack;
	//Start origin of the player that is currently controlling this tank.\nUsed to determine when a player has moved too far to continue controlling this tank.;
	Vector m_vecControllerUsePos;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Laser class;
class CLaser {
	//Fires the laser at a point defined by where the TraceResult hit.\nAlso causes beam damage as if CBeam::BeamDamage were used, and sparks at both ends, if the approprite spawn flags have been set.;
	void FireAtPoint(TraceResult& in tr);
	//Returns whether the laser is on;
	bool IsOn();
	//Turns the laser off;
	void TurnOff();
	//Turns the laser on;
	void TurnOn();
	//Creates a Xen teleport effect at the given location, with zaps occuring within the given radius.;
	void XenTeleport(const Vector& in vecSrc, int iRadius = 256);
	//Creates a Xen teleport zap effect between the given points.;
	void XenTeleportZap(const Vector& in vecSrc, const Vector& in vecDest);
	//Causes the given amount of damage to be done to the entity hit by the given traceresult, as if the damage occured one second ago.;
	void BeamDamageInstant(TraceResult& in tr, float flDamage);
	//Sets this beam to live for the given amount of time, after which it is removed.;
	void LiveForTime(float flTime);
	//Initializes this beam to be a beam going from a point in a given direction (BEAM_HOSE).;
	void HoseInit(const Vector& in vecStart, const Vector& in vecDirection);
	//Initializes this beam to be a beam between 2 given entities (BEAM_ENTS).;
	void EntsInit(CBaseEntity@ pEntStart, CBaseEntity@ pEntEnd);
	//Initializes this beam to be a beam between 2 given entities (BEAM_ENTS).;
	void EntsInit(int startIndex, int endIndex);
	//Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT).;
	void PointEntInit(const Vector& in vecStart, CBaseEntity@ pEntEnd);
	//Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT).;
	void PointEntInit(const Vector& in vecStart, int endIndex);
	//Initializes this beam to be a beam between 2 given points (BEAM_POINTS).;
	void PointsInit(const Vector& in vecStart, const Vector& in vecEnd);
	//Initializes this beam with default values and sets the given sprite as the sprite used, with the given width.;
	void BeamInit(const string& in szSpriteName, int iWidth);
	//Damages the entity hit by the given trace line with the amount set in this entity\'s pev->dmg variable.\nAlso applies decals to BSP models if the appropriate spawnflag is set.;
	void BeamDamage(TraceResult& in tr);
	//Creates sparks at the given start and end points, if appropriate spawn flags are set.;
	void DoSparks(const Vector& in vecStart, const Vector& in vecEnd);
	//Call after you change start/end positions.;
	void RelinkBeam();
	//Gets the beam\'s scroll rate.;
	int GetScrollRate();
	//Gets the beam\'s frame number.;
	int GetFrame();
	//Gets the beam\'s brightness.;
	int GetBrightness();
	//Gets the beam\'s color.;
	void GetColor(int& out r, int& out g, int& out b);
	//Gets the beam\'s noise.;
	int GetNoise();
	//Gets the beam\'s width.;
	int GetWidth();
	//Gets the beam\'s texture (sprite) index.;
	int GetTexture();
	//Gets the beam\'s ending position.;
	const Vector& GetEndPos();
	//Gets the beam\'s starting position.;
	const Vector& GetStartPos();
	//Sets the scroll rate of the beam.;
	void SetScrollRate(int speed);
	//Sets the frame number of the beam.;
	void SetFrame(float frame);
	//Sets the brightness of the beam. Value is between 0-255.;
	void SetBrightness(int brightness);
	//Sets the color of the beam.;
	void SetColor(int r, int g, int b);
	//Sets the noise (amplitude) of the beam.;
	void SetNoise(int iAmplitude);
	//Sets the width of the beam.;
	void SetWidth(int iWidth);
	//Sets the sprite to use. The index is the one returned from CGame::PrecacheModel.;
	void SetTexture(int spriteIndex);
	//Sets the end attachment of the beam. Attachment is a point on the entity\'s model. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT. Set to 0 to disable.;
	void SetEndAttachment(int attachment);
	//Sets the start attachment of the beam. Attachment is a point on the entity\'s model. Must be a beam of type BEAM_ENTS. Set to 0 to disable.;
	void SetStartAttachment(int attachment);
	//Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT.;
	void SetEndEntity(CBaseEntity@ pEntity);
	//Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT.;
	void SetEndEntity(int entityIndex);
	//Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS.;
	void SetStartEntity(CBaseEntity@ pEntity);
	//Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS.;
	void SetStartEntity(int entityIndex);
	//Sets the ending position of the beam. Must be a beam of type BEAM_POINTS or BEAM_HOSE.;
	void SetEndPos(const Vector& in vecPos);
	//Sets the starting position of the beam. Must be a beam of type BEAM_POINTS, BEAM_ENTPOINT or BEAM_HOSE.;
	void SetStartPos(const Vector& in vecPos);
	//Sets the flags of the beam. Must be a combination of BeamFlags values, or 0.;
	void SetFlags(int flags);
	//Sets the type of the beam.;
	void SetType(BeamType type);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBeam@ opImplCast();
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Beam class;
class CBeam {
	//Explicitly casts to sub type.;
	CLaser@ opCast();
	//Creates a Xen teleport effect at the given location, with zaps occuring within the given radius.;
	void XenTeleport(const Vector& in vecSrc, int iRadius = 256);
	//Creates a Xen teleport zap effect between the given points.;
	void XenTeleportZap(const Vector& in vecSrc, const Vector& in vecDest);
	//Causes the given amount of damage to be done to the entity hit by the given traceresult, as if the damage occured one second ago.;
	void BeamDamageInstant(TraceResult& in tr, float flDamage);
	//Sets this beam to live for the given amount of time, after which it is removed.;
	void LiveForTime(float flTime);
	//Initializes this beam to be a beam going from a point in a given direction (BEAM_HOSE).;
	void HoseInit(const Vector& in vecStart, const Vector& in vecDirection);
	//Initializes this beam to be a beam between 2 given entities (BEAM_ENTS).;
	void EntsInit(CBaseEntity@ pEntStart, CBaseEntity@ pEntEnd);
	//Initializes this beam to be a beam between 2 given entities (BEAM_ENTS).;
	void EntsInit(int startIndex, int endIndex);
	//Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT).;
	void PointEntInit(const Vector& in vecStart, CBaseEntity@ pEntEnd);
	//Initializes this beam to be a beam between a point and an entity (BEAM_ENTPOINT).;
	void PointEntInit(const Vector& in vecStart, int endIndex);
	//Initializes this beam to be a beam between 2 given points (BEAM_POINTS).;
	void PointsInit(const Vector& in vecStart, const Vector& in vecEnd);
	//Initializes this beam with default values and sets the given sprite as the sprite used, with the given width.;
	void BeamInit(const string& in szSpriteName, int iWidth);
	//Damages the entity hit by the given trace line with the amount set in this entity\'s pev->dmg variable.\nAlso applies decals to BSP models if the appropriate spawnflag is set.;
	void BeamDamage(TraceResult& in tr);
	//Creates sparks at the given start and end points, if appropriate spawn flags are set.;
	void DoSparks(const Vector& in vecStart, const Vector& in vecEnd);
	//Call after you change start/end positions.;
	void RelinkBeam();
	//Gets the beam\'s scroll rate.;
	int GetScrollRate();
	//Gets the beam\'s frame number.;
	int GetFrame();
	//Gets the beam\'s brightness.;
	int GetBrightness();
	//Gets the beam\'s color.;
	void GetColor(int& out r, int& out g, int& out b);
	//Gets the beam\'s noise.;
	int GetNoise();
	//Gets the beam\'s width.;
	int GetWidth();
	//Gets the beam\'s texture (sprite) index.;
	int GetTexture();
	//Gets the beam\'s ending position.;
	const Vector& GetEndPos();
	//Gets the beam\'s starting position.;
	const Vector& GetStartPos();
	//Sets the scroll rate of the beam.;
	void SetScrollRate(int speed);
	//Sets the frame number of the beam.;
	void SetFrame(float frame);
	//Sets the brightness of the beam. Value is between 0-255.;
	void SetBrightness(int brightness);
	//Sets the color of the beam.;
	void SetColor(int r, int g, int b);
	//Sets the noise (amplitude) of the beam.;
	void SetNoise(int iAmplitude);
	//Sets the width of the beam.;
	void SetWidth(int iWidth);
	//Sets the sprite to use. The index is the one returned from CGame::PrecacheModel.;
	void SetTexture(int spriteIndex);
	//Sets the end attachment of the beam. Attachment is a point on the entity\'s model. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT. Set to 0 to disable.;
	void SetEndAttachment(int attachment);
	//Sets the start attachment of the beam. Attachment is a point on the entity\'s model. Must be a beam of type BEAM_ENTS. Set to 0 to disable.;
	void SetStartAttachment(int attachment);
	//Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT.;
	void SetEndEntity(CBaseEntity@ pEntity);
	//Sets the ending entity of the beam. Must be a beam of type BEAM_ENTS or BEAM_ENTPOINT.;
	void SetEndEntity(int entityIndex);
	//Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS.;
	void SetStartEntity(CBaseEntity@ pEntity);
	//Sets the starting entity of the beam. Must be a beam of type BEAM_ENTS.;
	void SetStartEntity(int entityIndex);
	//Sets the ending position of the beam. Must be a beam of type BEAM_POINTS or BEAM_HOSE.;
	void SetEndPos(const Vector& in vecPos);
	//Sets the starting position of the beam. Must be a beam of type BEAM_POINTS, BEAM_ENTPOINT or BEAM_HOSE.;
	void SetStartPos(const Vector& in vecPos);
	//Sets the flags of the beam. Must be a combination of BeamFlags values, or 0.;
	void SetFlags(int flags);
	//Sets the type of the beam.;
	void SetType(BeamType type);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Path track class;
class CPathTrack {
	//;
	CPathTrack@ GetPrevious();
	//;
	CPathTrack@ GetNext();
	//;
	CPathTrack@ Nearest(Vector vecOrigin);
	//;
	CPathTrack@ LookAhead(Vector& in vecOrigin, Vector& out vecResultOrigin, float flDist, const bool bMove);
	//;
	void Project(CPathTrack@ pStart, CPathTrack@ pEnd, Vector& out vecOrigin, float flDist);
	//Returns pPath if enabled, null otherwise.;
	CPathTrack@ ValidPath(CPathTrack@ pPath, const bool testFlag);
	//Links the tracks together;
	void Link();
	//Sets the previous track in this path;
	void SetPrevious(CPathTrack@ pPrevious);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//New train speed;
	float m_flNewSpeed;
	//New maximum speed;
	float m_flMaxSpeed;
	//;
	EHandle m_hAltpath;
	//;
	EHandle m_hPrevious;
	//;
	EHandle m_hNext;
	//;
	string_t m_altName;
	//;
	float m_length;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Sprite class;
class CSprite {
	//Makes this sprite play until time pev->dmgtime has been passed, then removes itself.;
	void AnimateAndDie(float flFramerate);
	//Sets the brightness (render amount).;
	void SetBrightness(int brightness);
	//Sets the color.;
	void SetColor(int r, int g, int b);
	//Sets the current scale.;
	void SetScale(float flScale);
	//Sets the texture used by this sprite. Is a model index returned by g_Game.PrecacheModel.;
	void SetTexture(int iSpriteIndex);
	//Sets the transparency of this sprite.;
	void SetTransparency(int renderMode, int r, int g, int b, int renderAmount, int renderFx);
	//Gets the number of frames in this sprite.;
	float Frames() const;
	//Turns on this sprite.;
	void TurnOn();
	//Turns off this sprite.;
	void TurnOff();
	//Makes this sprite follow the given entity.;
	void SetAttachment(edict_t@ pEntity, int iAttachment);
	//Initializes this sprite.;
	void SpriteInit(const string& in szSpriteName, const Vector& in vecOrigin);
	//Causes this sprite to scale up and fade at the given rates.\nThis sprite will be removed once faded.;
	void Expand(float flScaleSpeed, float flFadeSpeed);
	//Advances this sprite\'s frame by the given amount of frames.;
	void Animate(float flFrames);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Player entity base class;
class CBasePlayer {
	//Get a player\'s cheat bits.;
	int GetCheats();
	//Get a player\'s cheat bit.;
	bool GetCheat(int iBit);
	//Set a player\'s cheat bit. (Requires cheat permission. If requested by self a permission message will be shown/logged.);
	bool SetCheat(int iBit, bool fValue, bool fRequestedBySelf = false);
	//Refresh the player\'s score information with one or all players.;
	void SendScoreInfo(edict_t@ edPlayer = null);
	//Set an overriden player model.;
	void SetOverriddenPlayerModel(const string& in szOverrideModel);
	//Reset an overriden player model.;
	void ResetOverriddenPlayerModel(const bool bResetToClModel, const bool bForceReset);
	//Get the player max speed override (-1 = not overriding);
	int GetMaxSpeedOverride();
	//Get the player persistent max speed. default: sv_maxspeed;
	int GetMaxSpeed();
	//Override players max speed (temporarily) -1 will restore;
	void SetMaxSpeedOverride(int Speed);
	//Set player persistent max speed. default: sv_maxspeed;
	void SetMaxSpeed(int Speed);
	//Reset viewmodel position.;
	void ResetVModelPos();
	//Set custom viewmodel position.;
	void SetVModelPos( const Vector& in vecPos );
	//Creates a sprite above the player\'s head;
	void ShowOverheadSprite(const string& in szSpriteName, const float flZOffset, const float flLifeTime);
	//Sets the player\'s view mode;
	void SetViewMode(PlayerViewMode viewMode);
	//Sets whether the player has an HEV suit.;
	void SetHasSuit(bool fHasSuit);
	//Returns whether the player has an HEV suit.;
	bool HasSuit();
	//Clamps all the player\'s ammo to their maximum amounts.;
	void RemoveAllExcessAmmo();
	//Clamps this player\'s ammo of the given type to the range 0 - MAX_AMMO.;
	void RemoveExcessAmmo(const string& in szName);
	//Clamps this player\'s ammo at the given inex to the range 0 - MAX_AMMO.;
	void RemoveExcessAmmo(size_t uiIndex);
	//Resets the ammo settings for this player for all ammo to their default values.;
	void ResetAllMaxAmmoToDefault();
	//Resets the ammo setting for this player for the given ammo type to its default value.;
	void ResetMaxAmmoToDefault(const string& in szName);
	//Resets the ammo setting for this player at the given index to its default value.;
	void ResetMaxAmmoToDefault(size_t uiIndex);
	//Sets the maximum ammo setting for this player for the given ammo type. Value must be >= 0.;
	void SetMaxAmmo(const string& in szName, int iMaxAmmo);
	//Sets the maximum ammo setting for this player for the ammo at the given index. Value must be >= 0.;
	void SetMaxAmmo(size_t uiIndex, int iMaxAmmo);
	//Gets the maximum ammo setting for this player for the given ammo type. Returns -1 if no ammo setting is present.;
	int GetMaxAmmo(const string& in szName) const;
	//Gets the maximum ammo setting for this player for the ammo at the given index. Returns -1 if no ammo setting is present.;
	int GetMaxAmmo(size_t uiIndex) const;
	//Gets the autoaim vector for the given delta.;
	Vector GetAutoaimVector(float flDelta);
	//Returns the amount of ammo currently in inventory of the given ammo index.;
	int AmmoInventory(int iAmmoIndex);
	//Set a suit update.;
	void SetSuitUpdate(const string& in szName, const bool bGroup, int iNoRepeat);
	//Check for suit update messages.;
	void CheckSuitUpdate();
	//Triggers the player\'s use behavior.;
	void PlayerUse();
	//Sets whether the player has control.;
	void EnableControl(const bool bControl);
	//Gives this player the item with the given name.\nFlags are spawnflags passed to the item.;
	void GiveNamedItem(const string& in szName, int iFlags = 0, int iAmmoCount = 0);
	//Selects the item with the given name.;
	void SelectItem(const string& in szItemName);
	//Selects the last active item.;
	void SelectLastItem();
	//Selects the next item relative to the given item.;
	void SelectNextItem();
	//Selects the previous item relative to the given item.;
	void SelectPrevItem(int iItem);
	//Returns whether this player has any weapons.;
	bool HasWeapons() const;
	//Returns the given item, or null if this player has no item by that name.;
	CBasePlayerItem@ HasNamedPlayerItem(const string& in szItemName);
	//Returns whether this player has the given item.;
	bool HasPlayerItem(CBasePlayerItem@ pCheckItem);
	//Drops ammo used by the named item.;
	CBasePlayerItem@ DropAmmo(const string& in szItemName);
	//Drops the given item, or if no name, the current weapon.;
	CBaseEntity@ DropItem(const string& in szItemName);
	//Gets the Observer instance that represents this player.;
	Observer@ GetObserver();
	//Shows the forced respawn message.;
	void ShowForcedRespawnMessage(int iSeconds);
	//Sets the player\'s view to that of a dead person.;
	void StartPlayerDeathView(const Vector& in vecPosition, const Vector& in vecViewAngle);
	//Returns whether this player can spawn.;
	bool CanSpawn();
	//Starts the death camera.;
	void StartDeathCam();
	//Triggers the given impulse command.;
	void CheatImpulseCommands(int iImpulse);
	//Sets the current animation extension.;
	void set_m_szAnimExtension(const string& in szAnimExtension);
	//Gets the current animation extension.;
	string get_m_szAnimExtension() const;
	//Set the player\'s animation.;
	void SetAnimation(PLAYER_ANIM anim, int mode = 0);
	//Turns off the flashlight.;
	void FlashlightTurnOff();
	//Turns on the flashlight.;
	void FlashlightTurnOn();
	//Returns whether the flashlight is on.;
	bool FlashlightIsOn() const;
	//Returns whether the player is on a ladder.;
	bool IsOnLadder() const;
	//Sets all item pickup times the given absolute time.;
	void SetItemPickupTimes(float flTime);
	//Returns whether the weapons are currently blocked.;
	bool GetWeaponsBlocked();
	//Shows active weapon and unblocks weapon selection.;
	void UnblockWeapons(CBaseEntity@ pSetter);
	//Hides active weapon and blocks weapon selection.;
	void BlockWeapons(CBaseEntity@ pSetter);
	//Deploy weapon.;
	void DeployWeapon();
	//Holster weapon.;
	void HolsterWeapon();
	//Switches weapons to the given item.;
	bool SwitchWeapon(CBasePlayerItem@ pWeapon);
	//Removes all items from the player\'s inventory.;
	void RemoveAllItems(const bool fRemoveSuit);
	//Packs player weapons into a weapon box if possible.;
	void PackDeadPlayerItems();
	//Returns whether this player is connected.;
	bool IsConnected() const;
	//Makes the player duck.;
	void Duck();
	//Makes the player jump.;
	void Jump();
	//Set player ammo amount.;
	void m_rgAmmo(size_t uiIndex, int iValue);
	//Get player ammo amount.;
	int m_rgAmmo(size_t uiIndex);
	//Get player weapons. Index must be between 0 and MAX_ITEM_TYPES.;
	CBasePlayerItem@ m_rgpPlayerItems(size_t uiIndex);
	//Reset all effect modifiers;
	void ResetEffects();
	//Re-calculate compounded effect modifiers and apply to the monster;
	void ApplyEffects();
	//Clears this monster\'s list of enemies;
	void ClearEnemyList();
	//The inventory items this monster has;
	InventoryList@ get_m_pInventory() const;
	//Medic call sound.;
	void MedicCallSound(float flDistance = 0.0f);
	//Current texture name we\'re standing on.;
	string m_szTextureName();
	//Stops following a player.;
	void StopPlayerFollowing(const bool bClearSchedule);
	//Starts following a given player.;
	void StartPlayerFollowing(CBaseEntity@ pLeader);
	//Returns whether this monster can follow a player.;
	bool CanPlayerFollow();
	//Returns whether this monster is following a player.;
	bool IsPlayerFollowing();
	//Use method for following players (set only if friendly);
	void FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue);
	//Turns the shock glow effect on or off.;
	void ShockGlowEffect(bool fMode);
	//Drops the given item from the given position at the given angle.;
	CBaseEntity@ DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng);
	//Cleans up after a cinematic event.;
	bool CineCleanup();
	//Exits the scripted sequence this monster is currently in, if any.;
	bool ExitScriptedSequence();
	//Returns whether this monster remembers all of the given memories.;
	bool HasAllMemories(int iMemory) const;
	//Returns whether this monster remembers any of the given memories.;
	bool HasMemory(int iMemory) const;
	//Makes this monster forget the given memories.;
	void Forget(int iMemory);
	//Makes this monster remember the given memories.;
	void Remember(int iMemory);
	//Stops following its target.;
	void StopPlayerFollowing(const bool clearSchedule, bool bSilent = false);
	//Starts following its target.;
	void StartPlayerFollowing(CBaseEntity@ pLeader, bool bSilent = false);
	//Plays this monster\'s pain sound.;
	void PainSound();
	//Plays this monster\'s idle sound.;
	void IdleSound();
	//Plays this monster\'s alert sound.;
	void AlertSound();
	//Plays this monster\'s death sound.;
	void DeathSound();
	//;
	Vector GetGunPosition();
	//Shoots at the specified location.;
	Vector ShootAtEnemy(const Vector& in vecShootOrigin);
	//Fades this monster.\nNote: does not kill the monster.;
	void FadeMonster();
	//Returns whether this monster has alien gibs.;
	bool HasAlienGibs();
	//Returns whether this monster has human gibs.;
	bool HasHumanGibs();
	//Determines whether to gib or fade this monster, and acts accordingly.;
	void CallGibMonster();
	//Returns whether the monster should be gibbed given the gib type.\nSee GIB enum.;
	bool ShouldGibMonster(int iGib);
	//Gibs the monster.;
	void GibMonster();
	//Tries to find the best suitable enemy for this monster.;
	bool GetEnemy();
	//Returns whether attacking the target location at this time would result in friendly fire;
	bool NoFriendlyFireToPos(Vector vecPos);
	//Returns whether attacking the given target at this time from the given location would result in friendly fire;
	bool NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget);
	//Returns whether attacking at this time from the given location would result in friendly fire;
	bool NoFriendlyFire(Vector vecPos);
	//Returns whether attacking at this time would result in friendly fire;
	bool NoFriendlyFire();
	//Checks and, if necessary, fires the monster\'s trigger target.;
	bool FCheckAITrigger();
	//Make the monster \'full\' for a while.;
	void Eat(float flFullDuration);
	//Returns whether this monster should eat.;
	bool FShouldEat();
	//Returns a pointer to the sound the monster should react to.;
	CSound@ PBestSound();
	//Returns whether this monster has all of the given AI conditions.;
	bool HasAllConditions(int iConditions) const;
	//Returns whether this monster has any of the given AI conditions.;
	bool HasConditions(int iConditions) const;
	//Clears AI conditions.;
	void ClearConditions(int iConditions);
	//Sets AI conditions.;
	void SetConditions(int iConditions);
	//Determine if we should ignore damage.;
	bool CheckAttacker(CBaseEntity@ pAttacker);
	//Returns the MOVEGOAL for the given move flag.;
	int RouteClassify(int iMoveFlag);
	//Allows different yaw_speeds for each activity.;
	void SetYawSpeed();
	//gets a yaw value for the caller that would\nface the supplied vector. Value is stuffed into the monster\'s\nideal_yaw.;
	void MakeIdealYaw(Vector vecTarget);
	//Returns an integer with all Conditions\nbits that are currently set and also set in the current\nschedule\'s Interrupt mask.;
	int IScheduleFlags();
	//Returns whether movement is complete.;
	bool MovementIsComplete();
	//Returns whether the task is complete.;
	bool TaskIsComplete();
	//Returns whether a task is running.;
	bool TaskIsRunning();
	//Sets the task status to running.;
	void TaskBegin();
	//Sets the condition bit for a failed task.;
	void TaskFail();
	//Called when movement has completed.;
	void MovementComplete();
	//Sets the task status to complete.;
	void TaskComplete();
	//TEST FGetNodeRoute.;
	bool TestFGetNodeRoute(Vector vecDest);
	//tries to build an entire node path from\nthe callers origin to the passed vector.\nIf this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route.\ntrue is returned if the operation  succeeds (path is valid) or false if failed (no path  exists ).;
	bool FGetNodeRoute(Vector vecDest);
	//Try remembering the last few enemies.;
	bool PopEnemy();
	//Remember the last few enemies, always remember the player.;
	void PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos);
	//part of the Condition collection process, gets and stores data and conditions pertaining to a monster\'s enemy.\nReturns true if Enemy LKP was updated.;
	bool CheckEnemy(CBaseEntity@ pEnemy);
	//Check whether attacks are possible from the given position.;
	bool CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos);
	//Check attacks to the given enemy at the given distance while moving.;
	void CheckAttacks_Move(CBaseEntity@ pTarget, float flDist);
	//Check attacks to the given enemy at the given distance.;
	void CheckAttacks(CBaseEntity@ pTarget, float flDist);
	//Reports the AI state.;
	void ReportAIState();
	//Sets the current monster state.;
	void SetState(MONSTERSTATE state);
	//Sets the current sequence by name.;
	void SetSequenceByName(const string& in szSequence);
	//Sets the current gait activity.;
	void SetGaitActivity(Activity newActivity);
	//Sets the current activity.;
	void SetActivity(Activity newActivity);
	//Gets the ideal monster state.;
	MONSTERSTATE GetIdealState();
	//Gets the current task.;
	Task@ GetTask();
	//Stops playing its current sentence.;
	void SentenceStop();
	//Plays the given scripted sentence.;
	void PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener);
	//Plays the given sentence.;
	void PlaySentence(const string& in szSentence, float duration, float volume, float attenuation);
	//Returns whether this monster can play its sentence.;
	bool CanPlaySentence(const bool bDisregardState);
	//Returns whether this monster can play its sequence.;
	bool CanPlaySequence(const bool bDisregardState, int iInterruptLevel);
	//Called after the monster\'s schedule changes.;
	void ScheduleChange();
	//Gets the current schedule.;
	Schedule@ GetSchedule();
	//Gets one of the available schedules of the given type.;
	Schedule@ GetScheduleOfType(int iType);
	//Runs the given task.;
	void RunTask(Task@ pTask);
	//Starts the given task.;
	void StartTask(Task@ pTask);
	//Maintains the monster\'s schedule.;
	void MaintainSchedule();
	//Returns the schedule with name szName if it exists, NULL otherwise.;
	Schedule@ ScheduleFromName(const string& in szName);
	//Returns the schedule with name szName if it\'s in the list, NULL otherwise.;
	Schedule@ ScheduleInList(const string& in szName, array<Schedule@>@ pArray);
	//Moves to the next scheduled task.;
	bool NextScheduledTask();
	//Changes this monster\'s schedule.;
	void ChangeSchedule(Schedule@ pNewSchedule);
	//Returns whether this monster\'s schedule is done.;
	bool FScheduleDone();
	//Clears this monster\'s schedule.;
	void ClearSchedule();
	//Returns whether this monster\'s schedule is valid.;
	bool FScheduleValid();
	//Returns whether this monster has a schedule.;
	bool FHaveSchedule();
	//Checks whether the monster can use a func_tank. Return true if possible.;
	bool CheckTankUsage();
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack2_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack2(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack1_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack1(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack2_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack2(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack1_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack1(float flDot, float flDist);
	//This will stop animation until you call ResetSequenceInfo() at some point in the future;
	void StopAnimation();
	//Stops this monster moving;
	void Stop();
	//Gets the stopped activity;
	Activity GetStoppedActivity();
	//Returns whether this monster should advance its route;
	bool ShouldAdvanceRoute(float flWaypointDist);
	//Starts the monster;
	void MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval);
	//Starts the monster;
	void Move(float flInterval = 0.1f);
	//finds best visible enemy for attack;
	int CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false);
	//see if given location is in monster\'s view cone;
	bool FInViewCone(const Vector& in vecOrigin);
	//see if pEntity is in monster\'s view cone;
	bool FInViewCone(CBaseEntity@ pEntity);
	//finds best visible enemy for attack;
	void BestVisibleEnemy();
	//Starts the monster;
	void StartMonster();
	//Revives the monster;
	void Revive();
	//Makes the monster become dead;
	void BecomeDead(float flSavedHealth);
	//Call after animation/pose is set up;
	void MonsterInitDead();
	//Initializes the monster;
	void MonsterInit();
	//use this overridden to make some other friendly monsters;
	void SetupFriendly();
	//Returns the amount of force applied to this monster when the given amount of damage is done.;
	float DamageForce(float flDamage);
	//returns the difference ( in degrees ) between monster\'s current yaw and ideal_yaw.\nPositive result is left turn, negative is right turn.;
	float FlYawDiff();
	//turns a directional vector into a yaw value that points down that vector.;
	float VecToYaw(Vector vecDir);
	//turns a monster towards its ideal_yaw;
	float ChangeYaw(int iSpeed);
	//Returns whether this monster should fade on death.;
	bool ShouldFadeOnDeath();
	//Listens for anything that is within audible distance.;
	void Listen();
	//Runs this monster\'s AI.;
	void RunAI();
	//Look - Base class monster function to find enemies or\nfood by sight. iDistance is distance ( in units ) that the\nmonster can see.\nSets the sight bits of the m_afConditions mask to indicate\nwhich types of entities were sighted.\nFunction also sets the Looker\'s m_pLink\nto the head of a link list that contains all visible ents.\n(linked via each ent\'s m_pLink field);
	void Look(int iDistance);
	//Will make a monster angry at whomever activated it.;
	void MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED.;
	int8& m_rgbTimeBasedDamage(size_t uiIndex);
	//Positions of movement. Index must be between 0 and ROUTE_SIZE;
	Waypoint& m_Route(size_t uiIndex);
	//Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES.;
	Vector& m_vecOldEnemy(size_t uiIndex);
	//Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES.;
	EHandle& m_hOldEnemy(size_t uiIndex);
	//The inventory rules.;
	InventoryRules@ get_m_pInventoryRules() const;
	//Returns whether this entity is locked by its master.\nSeparate from IsLockedByMaster due to limitations.;
	bool IsToggleLockedByMaster();
	//Performs angular movement.;
	void AngularMove(Vector vecDestAngle, float flSpeed);
	//Performs linear movement.;
	void LinearMove(Vector vecDest, float flSpeed);
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//Implicitly casts to base type.;
	CBaseAnimating@ opImplCast();
	//Implicitly casts to base type.;
	CBaseToggle@ opImplCast();
	//Implicitly casts to base type.;
	CBaseMonster@ opImplCast();
	//The player\'s class type.;
	int m_iPlayerClass;
	//Next time this player can spray a decal.;
	float m_flNextDecalTime;
	//get player death count.;
	int m_iDeaths;
	//The active item.;
	EHandle m_hActiveItem;
	//Field of view.;
	int m_iFOV;
	//The players hud weapon info is to be hidden.;
	int m_iHideHUD;
	//Does this player have the longjump module?;
	bool m_fLongJump;
	//the time at which the player died;
	float m_fDeadTime;
	//the tank which the player is currently controlling, NULL if no tank;
	EHandle m_hTank;
	//Train control position;
	int m_iTrain;
	//Track drowning damage restored.;
	int m_iDrownRestored;
	//Track drowning damage taken.;
	int m_iDrownDmg;
	//Last damage taken.;
	int m_lastPlayerDamageAmount;
	//How long this player has been underwater.;
	float m_flSwimTime;
	//;
	uint m_afPhysicsFlags;
	//Player fall velocity.;
	float m_flPlayerFallVelocity;
	//;
	int m_afButtonReleased;
	//;
	int m_afButtonPressed;
	//;
	int m_afButtonLast;
	//Player flashlight amount. 0 <= amount <= 100.;
	int m_iFlashBattery;
	//When to stop the m_iExtraSoundTypes sounds.;
	float m_flStopExtraSoundTime;
	//Brightness of the weapon flash.;
	int m_iWeaponFlash;
	//Additional classification for this weapon\'s sound.;
	int m_iExtraSoundTypes;
	//How loud the player\'s weapon is right now.;
	int m_iWeaponVolume;
	//When did this player move or tried to move (with the IN_ keys) ?;
	float m_flLastMove;
	//Pointer for a spawn point to use.;
	EHandle m_hSpawnPoint;
	//Gets added to the standard respawn delay time when killed, reset in spawn to 0.0.;
	float m_flRespawnDelayTime;
	//Time of last death.;
	float m_flTimeOfLastDeath;
	//The next time this player can execute a vocal client command;
	float m_flNextClientCommandTime;
	//The player\'s random seed.;
	const int random_seed;
	//Damage modifier (%);
	float m_flEffectDamage;
	//Movement speed modifier (%);
	float m_flEffectSpeed;
	//Movement friction modifier (%);
	float m_flEffectFriction;
	//Gravity modifier (%);
	float m_flEffectGravity;
	//Extra/less breathing time underwater in seconds;
	float m_flEffectRespiration;
	//is non-solid;
	int m_iEffectNonSolid;
	//is invisible (render + non-targetable);
	int m_iEffectInvisible;
	//is invulnerable (god mode);
	int m_iEffectInvulnerable;
	//Monster can\'t use weapons.;
	int m_iEffectBlockWeapons;
	//Glow shell.;
	Vector m_vecEffectGlowColor;
	//Guard entity name.;
	string_t m_iszGuardEntName;
	//Monster will guard this entity and turn down follow requests.;
	EHandle m_hGuardEnt;
	//Current fall speed.;
	float m_flFallVelocity;
	//How long an npc will attempt to fire full auto.;
	float m_flAutomaticAttackTime;
	//Whether this monster can fear creatures.;
	bool m_fCanFearCreatures;
	//Current texture type.\nSee TextureType enum.;
	int8 m_chTextureType;
	//The formatted name.\nFor better name outputs. E.g. Alien Slave rather than alien_slave.;
	string_t m_FormattedName;
	//Don\'t allow +USE until this time.;
	float m_useTime;
	//Entity that is blocking cinematic execution.;
	EHandle m_hCineBlocker;
	//Cinematic entity.;
	EHandle m_hCine;
	//internal cinematic state.;
	SCRIPTSTATE m_scriptState;
	//HACK until we can query end of gun.;
	Vector m_HackedGunPos;
	//Name of target that should be fired.;
	string_t m_iszTriggerTarget;
	//for scripted AI, this is the condition that will cause the activation of the monster\'s TriggerTarget.;
	int m_iTriggerCondition;
	//distance monster sees (Default 2048).;
	float m_flDistLook;
	//if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy.;
	float m_flDistTooFar;
	//Time based damage inflictor.;
	float m_flHungryTime;
	//Schedule type to choose if current schedule fails.;
	int m_failSchedule;
	//Time based damage inflictor.;
	entvars_t@ pevTimeBasedInflictor;
	//Time-based damage timer.;
	float m_tbdPrev;
	//how much damage did monster (player) last take.;
	float m_lastDamageAmount;
	//what types of damage has monster (player) taken.;
	int m_bitsDamageType;
	//cannot attack again until this time.;
	float m_flNextAttack;
	//tells us what a monster can/can\'t do, while moving.;
	int m_afMoveShootCap;
	//tells us what a monster can/can\'t do.;
	int m_afCapability;
	//how much ammo is in the weapon (used to trigger reload anim sequences).;
	int m_cAmmoLoaded;
	//last known position of enemy. (enemy\'s origin).;
	Vector m_vecEnemyLKP;
	//keeps track of monster\'s maximum health value (for re-healing, etc).;
	int m_iMaxHealth;
	//color of blood particles.;
	int m_bloodColor;
	//Monster memory.;
	int m_afMemory;
	//this is the hint node that the monster is moving towards or performing active idle on..;
	int m_iHintNode;
	//monster sometimes wants to return to where it started after an operation..;
	Vector m_vecLastPosition;
	//Sound types that can be heard.;
	int m_afSoundTypes;
	//first index of a linked list of sounds that the monster can hear.;
	int m_iAudibleList;
	//When moving, set this activity.;
	Activity m_movementActivity;
	//Kept around for node graph moves, so we know our ultimate goal.;
	Vector m_vecMoveGoal;
	//Minimum radius.;
	float m_moveradius;
	//How long I should wait for something to move.;
	float m_moveWaitTime;
	//Index into m_Route[].;
	int m_iRouteIndex;
	//Goal that defines route.;
	int m_movementGoal;
	//Schedule index.;
	int m_iScheduleIndex;
	//For land_on_ground schedules (remember last schedule and continue).;
	Schedule@ m_pScheduleSaved;
	//Current schedule.;
	Schedule@ m_pSchedule;
	//Task status.;
	int m_iTaskStatus;
	//monster should change to this state.;
	MONSTERSTATE m_IdealMonsterState;
	//monster\'s current state.;
	MONSTERSTATE m_MonsterState;
	//the last body region that took damage.;
	int m_LastHitGroup;
	//gaitsequence.;
	Activity m_GaitActivity;
	//monster should switch to this activity.;
	Activity m_IdealActivity;
	//what the monster is doing (animation).;
	Activity m_Activity;
	//if we\'re told to wait before moving, this is the time that the wait will be over.;
	float m_flMoveWaitFinished;
	//if we\'re told to wait, this is the time that the wait will be over.;
	float m_flWaitFinished;
	//width of monster\'s field of view ( dot product ).;
	float m_flFieldOfView;
	//Target tank to control.;
	EHandle m_hTargetTank;
	//the entity that the monster is trying to reach.;
	EHandle m_hTargetEnt;
	//the entity that the monster is fighting.;
	EHandle m_hEnemy;
	//This entity\'s master, if any.;
	string_t m_sMaster;
	//DMG_ damage type that the door or trigger does.;
	int m_bitsDamageInflict;
	//Final angle.;
	Vector m_vecFinalAngle;
	//Final destination.;
	Vector m_vecFinalDest;
	//Open angle.;
	Vector m_vecAngle2;
	//Closed angle.;
	Vector m_vecAngle1;
	//Open position.;
	Vector m_vecPosition2;
	//Closed position.;
	Vector m_vecPosition1;
	//Handle to the activator.;
	EHandle m_hActivator;
	//Height.;
	float m_flHeight;
	//Trigger_counter only: # of activations remaining.;
	int m_cTriggersLeft;
	//For plats.;
	float m_flTLength;
	//For plats.;
	float m_flTWidth;
	//How much to stick out of a wall. Will recede further into walls if negative.;
	float m_flLip;
	//How long to wait before resetting.;
	float m_flWait;
	//How far a door should slide or rotate.;
	float m_flMoveDistance;
	//Current toggle state.;
	TOGGLE_STATE m_toggle_state;
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Cinematic monster entity base class;
class CCineMonster {
	//Gets the ignore conditions.;
	int IgnoreConditions();
	//Returns whether this script can be interrupted.;
	bool CanInterrupt();
	//If this returns false, scripted sequences cannot possess entities regardless of state.;
	bool FCanOverrideState() const;
	//Make the entity enter a scripted sequence.;
	bool StartSequence(CBaseMonster@ pTarget, const string& in szSequence, const bool fCompleteOnEmpty);
	//Find all the cinematic entities with my targetname and stop them from playing.;
	void CancelScript();
	//Make the entity enter a scripted sequence.;
	void PossessEntity();
	//Find all the cinematic entities with my targetname and tell them to wait before starting.;
	void DelayStart(int iState);
	//Reset all effect modifiers;
	void ResetEffects();
	//Re-calculate compounded effect modifiers and apply to the monster;
	void ApplyEffects();
	//Clears this monster\'s list of enemies;
	void ClearEnemyList();
	//The inventory items this monster has;
	InventoryList@ get_m_pInventory() const;
	//Medic call sound.;
	void MedicCallSound(float flDistance = 0.0f);
	//Current texture name we\'re standing on.;
	string m_szTextureName();
	//Stops following a player.;
	void StopPlayerFollowing(const bool bClearSchedule);
	//Starts following a given player.;
	void StartPlayerFollowing(CBaseEntity@ pLeader);
	//Returns whether this monster can follow a player.;
	bool CanPlayerFollow();
	//Returns whether this monster is following a player.;
	bool IsPlayerFollowing();
	//Use method for following players (set only if friendly);
	void FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue);
	//Turns the shock glow effect on or off.;
	void ShockGlowEffect(bool fMode);
	//Drops the given item from the given position at the given angle.;
	CBaseEntity@ DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng);
	//Cleans up after a cinematic event.;
	bool CineCleanup();
	//Exits the scripted sequence this monster is currently in, if any.;
	bool ExitScriptedSequence();
	//Returns whether this monster remembers all of the given memories.;
	bool HasAllMemories(int iMemory) const;
	//Returns whether this monster remembers any of the given memories.;
	bool HasMemory(int iMemory) const;
	//Makes this monster forget the given memories.;
	void Forget(int iMemory);
	//Makes this monster remember the given memories.;
	void Remember(int iMemory);
	//Stops following its target.;
	void StopPlayerFollowing(const bool clearSchedule, bool bSilent = false);
	//Starts following its target.;
	void StartPlayerFollowing(CBaseEntity@ pLeader, bool bSilent = false);
	//Plays this monster\'s pain sound.;
	void PainSound();
	//Plays this monster\'s idle sound.;
	void IdleSound();
	//Plays this monster\'s alert sound.;
	void AlertSound();
	//Plays this monster\'s death sound.;
	void DeathSound();
	//;
	Vector GetGunPosition();
	//Shoots at the specified location.;
	Vector ShootAtEnemy(const Vector& in vecShootOrigin);
	//Fades this monster.\nNote: does not kill the monster.;
	void FadeMonster();
	//Returns whether this monster has alien gibs.;
	bool HasAlienGibs();
	//Returns whether this monster has human gibs.;
	bool HasHumanGibs();
	//Determines whether to gib or fade this monster, and acts accordingly.;
	void CallGibMonster();
	//Returns whether the monster should be gibbed given the gib type.\nSee GIB enum.;
	bool ShouldGibMonster(int iGib);
	//Gibs the monster.;
	void GibMonster();
	//Tries to find the best suitable enemy for this monster.;
	bool GetEnemy();
	//Returns whether attacking the target location at this time would result in friendly fire;
	bool NoFriendlyFireToPos(Vector vecPos);
	//Returns whether attacking the given target at this time from the given location would result in friendly fire;
	bool NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget);
	//Returns whether attacking at this time from the given location would result in friendly fire;
	bool NoFriendlyFire(Vector vecPos);
	//Returns whether attacking at this time would result in friendly fire;
	bool NoFriendlyFire();
	//Checks and, if necessary, fires the monster\'s trigger target.;
	bool FCheckAITrigger();
	//Make the monster \'full\' for a while.;
	void Eat(float flFullDuration);
	//Returns whether this monster should eat.;
	bool FShouldEat();
	//Returns a pointer to the sound the monster should react to.;
	CSound@ PBestSound();
	//Returns whether this monster has all of the given AI conditions.;
	bool HasAllConditions(int iConditions) const;
	//Returns whether this monster has any of the given AI conditions.;
	bool HasConditions(int iConditions) const;
	//Clears AI conditions.;
	void ClearConditions(int iConditions);
	//Sets AI conditions.;
	void SetConditions(int iConditions);
	//Determine if we should ignore damage.;
	bool CheckAttacker(CBaseEntity@ pAttacker);
	//Returns the MOVEGOAL for the given move flag.;
	int RouteClassify(int iMoveFlag);
	//Allows different yaw_speeds for each activity.;
	void SetYawSpeed();
	//gets a yaw value for the caller that would\nface the supplied vector. Value is stuffed into the monster\'s\nideal_yaw.;
	void MakeIdealYaw(Vector vecTarget);
	//Returns an integer with all Conditions\nbits that are currently set and also set in the current\nschedule\'s Interrupt mask.;
	int IScheduleFlags();
	//Returns whether movement is complete.;
	bool MovementIsComplete();
	//Returns whether the task is complete.;
	bool TaskIsComplete();
	//Returns whether a task is running.;
	bool TaskIsRunning();
	//Sets the task status to running.;
	void TaskBegin();
	//Sets the condition bit for a failed task.;
	void TaskFail();
	//Called when movement has completed.;
	void MovementComplete();
	//Sets the task status to complete.;
	void TaskComplete();
	//TEST FGetNodeRoute.;
	bool TestFGetNodeRoute(Vector vecDest);
	//tries to build an entire node path from\nthe callers origin to the passed vector.\nIf this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route.\ntrue is returned if the operation  succeeds (path is valid) or false if failed (no path  exists ).;
	bool FGetNodeRoute(Vector vecDest);
	//Try remembering the last few enemies.;
	bool PopEnemy();
	//Remember the last few enemies, always remember the player.;
	void PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos);
	//part of the Condition collection process, gets and stores data and conditions pertaining to a monster\'s enemy.\nReturns true if Enemy LKP was updated.;
	bool CheckEnemy(CBaseEntity@ pEnemy);
	//Check whether attacks are possible from the given position.;
	bool CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos);
	//Check attacks to the given enemy at the given distance while moving.;
	void CheckAttacks_Move(CBaseEntity@ pTarget, float flDist);
	//Check attacks to the given enemy at the given distance.;
	void CheckAttacks(CBaseEntity@ pTarget, float flDist);
	//Reports the AI state.;
	void ReportAIState();
	//Sets the current monster state.;
	void SetState(MONSTERSTATE state);
	//Sets the current sequence by name.;
	void SetSequenceByName(const string& in szSequence);
	//Sets the current gait activity.;
	void SetGaitActivity(Activity newActivity);
	//Sets the current activity.;
	void SetActivity(Activity newActivity);
	//Gets the ideal monster state.;
	MONSTERSTATE GetIdealState();
	//Gets the current task.;
	Task@ GetTask();
	//Stops playing its current sentence.;
	void SentenceStop();
	//Plays the given scripted sentence.;
	void PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener);
	//Plays the given sentence.;
	void PlaySentence(const string& in szSentence, float duration, float volume, float attenuation);
	//Returns whether this monster can play its sentence.;
	bool CanPlaySentence(const bool bDisregardState);
	//Returns whether this monster can play its sequence.;
	bool CanPlaySequence(const bool bDisregardState, int iInterruptLevel);
	//Called after the monster\'s schedule changes.;
	void ScheduleChange();
	//Gets the current schedule.;
	Schedule@ GetSchedule();
	//Gets one of the available schedules of the given type.;
	Schedule@ GetScheduleOfType(int iType);
	//Runs the given task.;
	void RunTask(Task@ pTask);
	//Starts the given task.;
	void StartTask(Task@ pTask);
	//Maintains the monster\'s schedule.;
	void MaintainSchedule();
	//Returns the schedule with name szName if it exists, NULL otherwise.;
	Schedule@ ScheduleFromName(const string& in szName);
	//Returns the schedule with name szName if it\'s in the list, NULL otherwise.;
	Schedule@ ScheduleInList(const string& in szName, array<Schedule@>@ pArray);
	//Moves to the next scheduled task.;
	bool NextScheduledTask();
	//Changes this monster\'s schedule.;
	void ChangeSchedule(Schedule@ pNewSchedule);
	//Returns whether this monster\'s schedule is done.;
	bool FScheduleDone();
	//Clears this monster\'s schedule.;
	void ClearSchedule();
	//Returns whether this monster\'s schedule is valid.;
	bool FScheduleValid();
	//Returns whether this monster has a schedule.;
	bool FHaveSchedule();
	//Checks whether the monster can use a func_tank. Return true if possible.;
	bool CheckTankUsage();
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack2_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack2(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack1_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack1(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack2_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack2(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack1_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack1(float flDot, float flDist);
	//This will stop animation until you call ResetSequenceInfo() at some point in the future;
	void StopAnimation();
	//Stops this monster moving;
	void Stop();
	//Gets the stopped activity;
	Activity GetStoppedActivity();
	//Returns whether this monster should advance its route;
	bool ShouldAdvanceRoute(float flWaypointDist);
	//Starts the monster;
	void MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval);
	//Starts the monster;
	void Move(float flInterval = 0.1f);
	//finds best visible enemy for attack;
	int CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false);
	//see if given location is in monster\'s view cone;
	bool FInViewCone(const Vector& in vecOrigin);
	//see if pEntity is in monster\'s view cone;
	bool FInViewCone(CBaseEntity@ pEntity);
	//finds best visible enemy for attack;
	void BestVisibleEnemy();
	//Starts the monster;
	void StartMonster();
	//Revives the monster;
	void Revive();
	//Makes the monster become dead;
	void BecomeDead(float flSavedHealth);
	//Call after animation/pose is set up;
	void MonsterInitDead();
	//Initializes the monster;
	void MonsterInit();
	//use this overridden to make some other friendly monsters;
	void SetupFriendly();
	//Returns the amount of force applied to this monster when the given amount of damage is done.;
	float DamageForce(float flDamage);
	//returns the difference ( in degrees ) between monster\'s current yaw and ideal_yaw.\nPositive result is left turn, negative is right turn.;
	float FlYawDiff();
	//turns a directional vector into a yaw value that points down that vector.;
	float VecToYaw(Vector vecDir);
	//turns a monster towards its ideal_yaw;
	float ChangeYaw(int iSpeed);
	//Returns whether this monster should fade on death.;
	bool ShouldFadeOnDeath();
	//Listens for anything that is within audible distance.;
	void Listen();
	//Runs this monster\'s AI.;
	void RunAI();
	//Look - Base class monster function to find enemies or\nfood by sight. iDistance is distance ( in units ) that the\nmonster can see.\nSets the sight bits of the m_afConditions mask to indicate\nwhich types of entities were sighted.\nFunction also sets the Looker\'s m_pLink\nto the head of a link list that contains all visible ents.\n(linked via each ent\'s m_pLink field);
	void Look(int iDistance);
	//Will make a monster angry at whomever activated it.;
	void MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED.;
	int8& m_rgbTimeBasedDamage(size_t uiIndex);
	//Positions of movement. Index must be between 0 and ROUTE_SIZE;
	Waypoint& m_Route(size_t uiIndex);
	//Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES.;
	Vector& m_vecOldEnemy(size_t uiIndex);
	//Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES.;
	EHandle& m_hOldEnemy(size_t uiIndex);
	//The inventory rules.;
	InventoryRules@ get_m_pInventoryRules() const;
	//Returns whether this entity is locked by its master.\nSeparate from IsLockedByMaster due to limitations.;
	bool IsToggleLockedByMaster();
	//Performs angular movement.;
	void AngularMove(Vector vecDestAngle, float flSpeed);
	//Performs linear movement.;
	void LinearMove(Vector vecDest, float flSpeed);
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//Implicitly casts to base type.;
	CBaseAnimating@ opImplCast();
	//Implicitly casts to base type.;
	CBaseToggle@ opImplCast();
	//Implicitly casts to base type.;
	CBaseMonster@ opImplCast();
	//When in radius, script is done.;
	float m_flMoveToRadius;
	//Whether this scripted sequence can be interrupted.;
	bool m_interruptable;
	//When to start the script.;
	float m_startTime;
	//Delay before execution.;
	int m_iDelay;
	//How much time has to pass before the scripted sequence can repeat.;
	float m_flRepeat;
	//The radius to search in.;
	float m_flRadius;
	//The target entity name.;
	string_t m_iszEntity;
	//The play animation name.;
	string_t m_iszPlay;
	//Te idle animation name.;
	string_t m_iszIdle;
	//Damage modifier (%);
	float m_flEffectDamage;
	//Movement speed modifier (%);
	float m_flEffectSpeed;
	//Movement friction modifier (%);
	float m_flEffectFriction;
	//Gravity modifier (%);
	float m_flEffectGravity;
	//Extra/less breathing time underwater in seconds;
	float m_flEffectRespiration;
	//is non-solid;
	int m_iEffectNonSolid;
	//is invisible (render + non-targetable);
	int m_iEffectInvisible;
	//is invulnerable (god mode);
	int m_iEffectInvulnerable;
	//Monster can\'t use weapons.;
	int m_iEffectBlockWeapons;
	//Glow shell.;
	Vector m_vecEffectGlowColor;
	//Guard entity name.;
	string_t m_iszGuardEntName;
	//Monster will guard this entity and turn down follow requests.;
	EHandle m_hGuardEnt;
	//Current fall speed.;
	float m_flFallVelocity;
	//How long an npc will attempt to fire full auto.;
	float m_flAutomaticAttackTime;
	//Whether this monster can fear creatures.;
	bool m_fCanFearCreatures;
	//Current texture type.\nSee TextureType enum.;
	int8 m_chTextureType;
	//The formatted name.\nFor better name outputs. E.g. Alien Slave rather than alien_slave.;
	string_t m_FormattedName;
	//Don\'t allow +USE until this time.;
	float m_useTime;
	//Entity that is blocking cinematic execution.;
	EHandle m_hCineBlocker;
	//Cinematic entity.;
	EHandle m_hCine;
	//internal cinematic state.;
	SCRIPTSTATE m_scriptState;
	//HACK until we can query end of gun.;
	Vector m_HackedGunPos;
	//Name of target that should be fired.;
	string_t m_iszTriggerTarget;
	//for scripted AI, this is the condition that will cause the activation of the monster\'s TriggerTarget.;
	int m_iTriggerCondition;
	//distance monster sees (Default 2048).;
	float m_flDistLook;
	//if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy.;
	float m_flDistTooFar;
	//Time based damage inflictor.;
	float m_flHungryTime;
	//Schedule type to choose if current schedule fails.;
	int m_failSchedule;
	//Time based damage inflictor.;
	entvars_t@ pevTimeBasedInflictor;
	//Time-based damage timer.;
	float m_tbdPrev;
	//how much damage did monster (player) last take.;
	float m_lastDamageAmount;
	//what types of damage has monster (player) taken.;
	int m_bitsDamageType;
	//cannot attack again until this time.;
	float m_flNextAttack;
	//tells us what a monster can/can\'t do, while moving.;
	int m_afMoveShootCap;
	//tells us what a monster can/can\'t do.;
	int m_afCapability;
	//how much ammo is in the weapon (used to trigger reload anim sequences).;
	int m_cAmmoLoaded;
	//last known position of enemy. (enemy\'s origin).;
	Vector m_vecEnemyLKP;
	//keeps track of monster\'s maximum health value (for re-healing, etc).;
	int m_iMaxHealth;
	//color of blood particles.;
	int m_bloodColor;
	//Monster memory.;
	int m_afMemory;
	//this is the hint node that the monster is moving towards or performing active idle on..;
	int m_iHintNode;
	//monster sometimes wants to return to where it started after an operation..;
	Vector m_vecLastPosition;
	//Sound types that can be heard.;
	int m_afSoundTypes;
	//first index of a linked list of sounds that the monster can hear.;
	int m_iAudibleList;
	//When moving, set this activity.;
	Activity m_movementActivity;
	//Kept around for node graph moves, so we know our ultimate goal.;
	Vector m_vecMoveGoal;
	//Minimum radius.;
	float m_moveradius;
	//How long I should wait for something to move.;
	float m_moveWaitTime;
	//Index into m_Route[].;
	int m_iRouteIndex;
	//Goal that defines route.;
	int m_movementGoal;
	//Schedule index.;
	int m_iScheduleIndex;
	//For land_on_ground schedules (remember last schedule and continue).;
	Schedule@ m_pScheduleSaved;
	//Current schedule.;
	Schedule@ m_pSchedule;
	//Task status.;
	int m_iTaskStatus;
	//monster should change to this state.;
	MONSTERSTATE m_IdealMonsterState;
	//monster\'s current state.;
	MONSTERSTATE m_MonsterState;
	//the last body region that took damage.;
	int m_LastHitGroup;
	//gaitsequence.;
	Activity m_GaitActivity;
	//monster should switch to this activity.;
	Activity m_IdealActivity;
	//what the monster is doing (animation).;
	Activity m_Activity;
	//if we\'re told to wait before moving, this is the time that the wait will be over.;
	float m_flMoveWaitFinished;
	//if we\'re told to wait, this is the time that the wait will be over.;
	float m_flWaitFinished;
	//width of monster\'s field of view ( dot product ).;
	float m_flFieldOfView;
	//Target tank to control.;
	EHandle m_hTargetTank;
	//the entity that the monster is trying to reach.;
	EHandle m_hTargetEnt;
	//the entity that the monster is fighting.;
	EHandle m_hEnemy;
	//This entity\'s master, if any.;
	string_t m_sMaster;
	//DMG_ damage type that the door or trigger does.;
	int m_bitsDamageInflict;
	//Final angle.;
	Vector m_vecFinalAngle;
	//Final destination.;
	Vector m_vecFinalDest;
	//Open angle.;
	Vector m_vecAngle2;
	//Closed angle.;
	Vector m_vecAngle1;
	//Open position.;
	Vector m_vecPosition2;
	//Closed position.;
	Vector m_vecPosition1;
	//Handle to the activator.;
	EHandle m_hActivator;
	//Height.;
	float m_flHeight;
	//Trigger_counter only: # of activations remaining.;
	int m_cTriggersLeft;
	//For plats.;
	float m_flTLength;
	//For plats.;
	float m_flTWidth;
	//How much to stick out of a wall. Will recede further into walls if negative.;
	float m_flLip;
	//How long to wait before resetting.;
	float m_flWait;
	//How far a door should slide or rotate.;
	float m_flMoveDistance;
	//Current toggle state.;
	TOGGLE_STATE m_toggle_state;
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Monster entity base class;
class CBaseMonster {
	//Explicitly casts to sub type.;
	CGrenade@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayer@ opCast();
	//Explicitly casts to sub type.;
	CCineMonster@ opCast();
	//Reset all effect modifiers;
	void ResetEffects();
	//Re-calculate compounded effect modifiers and apply to the monster;
	void ApplyEffects();
	//Clears this monster\'s list of enemies;
	void ClearEnemyList();
	//The inventory items this monster has;
	InventoryList@ get_m_pInventory() const;
	//Medic call sound.;
	void MedicCallSound(float flDistance = 0.0f);
	//Current texture name we\'re standing on.;
	string m_szTextureName();
	//Stops following a player.;
	void StopPlayerFollowing(const bool bClearSchedule);
	//Starts following a given player.;
	void StartPlayerFollowing(CBaseEntity@ pLeader);
	//Returns whether this monster can follow a player.;
	bool CanPlayerFollow();
	//Returns whether this monster is following a player.;
	bool IsPlayerFollowing();
	//Use method for following players (set only if friendly);
	void FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue);
	//Turns the shock glow effect on or off.;
	void ShockGlowEffect(bool fMode);
	//Drops the given item from the given position at the given angle.;
	CBaseEntity@ DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng);
	//Cleans up after a cinematic event.;
	bool CineCleanup();
	//Exits the scripted sequence this monster is currently in, if any.;
	bool ExitScriptedSequence();
	//Returns whether this monster remembers all of the given memories.;
	bool HasAllMemories(int iMemory) const;
	//Returns whether this monster remembers any of the given memories.;
	bool HasMemory(int iMemory) const;
	//Makes this monster forget the given memories.;
	void Forget(int iMemory);
	//Makes this monster remember the given memories.;
	void Remember(int iMemory);
	//Stops following its target.;
	void StopPlayerFollowing(const bool clearSchedule, bool bSilent = false);
	//Starts following its target.;
	void StartPlayerFollowing(CBaseEntity@ pLeader, bool bSilent = false);
	//Plays this monster\'s pain sound.;
	void PainSound();
	//Plays this monster\'s idle sound.;
	void IdleSound();
	//Plays this monster\'s alert sound.;
	void AlertSound();
	//Plays this monster\'s death sound.;
	void DeathSound();
	//;
	Vector GetGunPosition();
	//Shoots at the specified location.;
	Vector ShootAtEnemy(const Vector& in vecShootOrigin);
	//Fades this monster.\nNote: does not kill the monster.;
	void FadeMonster();
	//Returns whether this monster has alien gibs.;
	bool HasAlienGibs();
	//Returns whether this monster has human gibs.;
	bool HasHumanGibs();
	//Determines whether to gib or fade this monster, and acts accordingly.;
	void CallGibMonster();
	//Returns whether the monster should be gibbed given the gib type.\nSee GIB enum.;
	bool ShouldGibMonster(int iGib);
	//Gibs the monster.;
	void GibMonster();
	//Tries to find the best suitable enemy for this monster.;
	bool GetEnemy();
	//Returns whether attacking the target location at this time would result in friendly fire;
	bool NoFriendlyFireToPos(Vector vecPos);
	//Returns whether attacking the given target at this time from the given location would result in friendly fire;
	bool NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget);
	//Returns whether attacking at this time from the given location would result in friendly fire;
	bool NoFriendlyFire(Vector vecPos);
	//Returns whether attacking at this time would result in friendly fire;
	bool NoFriendlyFire();
	//Checks and, if necessary, fires the monster\'s trigger target.;
	bool FCheckAITrigger();
	//Make the monster \'full\' for a while.;
	void Eat(float flFullDuration);
	//Returns whether this monster should eat.;
	bool FShouldEat();
	//Returns a pointer to the sound the monster should react to.;
	CSound@ PBestSound();
	//Returns whether this monster has all of the given AI conditions.;
	bool HasAllConditions(int iConditions) const;
	//Returns whether this monster has any of the given AI conditions.;
	bool HasConditions(int iConditions) const;
	//Clears AI conditions.;
	void ClearConditions(int iConditions);
	//Sets AI conditions.;
	void SetConditions(int iConditions);
	//Determine if we should ignore damage.;
	bool CheckAttacker(CBaseEntity@ pAttacker);
	//Returns the MOVEGOAL for the given move flag.;
	int RouteClassify(int iMoveFlag);
	//Allows different yaw_speeds for each activity.;
	void SetYawSpeed();
	//gets a yaw value for the caller that would\nface the supplied vector. Value is stuffed into the monster\'s\nideal_yaw.;
	void MakeIdealYaw(Vector vecTarget);
	//Returns an integer with all Conditions\nbits that are currently set and also set in the current\nschedule\'s Interrupt mask.;
	int IScheduleFlags();
	//Returns whether movement is complete.;
	bool MovementIsComplete();
	//Returns whether the task is complete.;
	bool TaskIsComplete();
	//Returns whether a task is running.;
	bool TaskIsRunning();
	//Sets the task status to running.;
	void TaskBegin();
	//Sets the condition bit for a failed task.;
	void TaskFail();
	//Called when movement has completed.;
	void MovementComplete();
	//Sets the task status to complete.;
	void TaskComplete();
	//TEST FGetNodeRoute.;
	bool TestFGetNodeRoute(Vector vecDest);
	//tries to build an entire node path from\nthe callers origin to the passed vector.\nIf this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route.\ntrue is returned if the operation  succeeds (path is valid) or false if failed (no path  exists ).;
	bool FGetNodeRoute(Vector vecDest);
	//Try remembering the last few enemies.;
	bool PopEnemy();
	//Remember the last few enemies, always remember the player.;
	void PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos);
	//part of the Condition collection process, gets and stores data and conditions pertaining to a monster\'s enemy.\nReturns true if Enemy LKP was updated.;
	bool CheckEnemy(CBaseEntity@ pEnemy);
	//Check whether attacks are possible from the given position.;
	bool CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos);
	//Check attacks to the given enemy at the given distance while moving.;
	void CheckAttacks_Move(CBaseEntity@ pTarget, float flDist);
	//Check attacks to the given enemy at the given distance.;
	void CheckAttacks(CBaseEntity@ pTarget, float flDist);
	//Reports the AI state.;
	void ReportAIState();
	//Sets the current monster state.;
	void SetState(MONSTERSTATE state);
	//Sets the current sequence by name.;
	void SetSequenceByName(const string& in szSequence);
	//Sets the current gait activity.;
	void SetGaitActivity(Activity newActivity);
	//Sets the current activity.;
	void SetActivity(Activity newActivity);
	//Gets the ideal monster state.;
	MONSTERSTATE GetIdealState();
	//Gets the current task.;
	Task@ GetTask();
	//Stops playing its current sentence.;
	void SentenceStop();
	//Plays the given scripted sentence.;
	void PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener);
	//Plays the given sentence.;
	void PlaySentence(const string& in szSentence, float duration, float volume, float attenuation);
	//Returns whether this monster can play its sentence.;
	bool CanPlaySentence(const bool bDisregardState);
	//Returns whether this monster can play its sequence.;
	bool CanPlaySequence(const bool bDisregardState, int iInterruptLevel);
	//Called after the monster\'s schedule changes.;
	void ScheduleChange();
	//Gets the current schedule.;
	Schedule@ GetSchedule();
	//Gets one of the available schedules of the given type.;
	Schedule@ GetScheduleOfType(int iType);
	//Runs the given task.;
	void RunTask(Task@ pTask);
	//Starts the given task.;
	void StartTask(Task@ pTask);
	//Maintains the monster\'s schedule.;
	void MaintainSchedule();
	//Returns the schedule with name szName if it exists, NULL otherwise.;
	Schedule@ ScheduleFromName(const string& in szName);
	//Returns the schedule with name szName if it\'s in the list, NULL otherwise.;
	Schedule@ ScheduleInList(const string& in szName, array<Schedule@>@ pArray);
	//Moves to the next scheduled task.;
	bool NextScheduledTask();
	//Changes this monster\'s schedule.;
	void ChangeSchedule(Schedule@ pNewSchedule);
	//Returns whether this monster\'s schedule is done.;
	bool FScheduleDone();
	//Clears this monster\'s schedule.;
	void ClearSchedule();
	//Returns whether this monster\'s schedule is valid.;
	bool FScheduleValid();
	//Returns whether this monster has a schedule.;
	bool FHaveSchedule();
	//Checks whether the monster can use a func_tank. Return true if possible.;
	bool CheckTankUsage();
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack2_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack2(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack1_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack1(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack2_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack2(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack1_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack1(float flDot, float flDist);
	//This will stop animation until you call ResetSequenceInfo() at some point in the future;
	void StopAnimation();
	//Stops this monster moving;
	void Stop();
	//Gets the stopped activity;
	Activity GetStoppedActivity();
	//Returns whether this monster should advance its route;
	bool ShouldAdvanceRoute(float flWaypointDist);
	//Starts the monster;
	void MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval);
	//Starts the monster;
	void Move(float flInterval = 0.1f);
	//finds best visible enemy for attack;
	int CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false);
	//see if given location is in monster\'s view cone;
	bool FInViewCone(const Vector& in vecOrigin);
	//see if pEntity is in monster\'s view cone;
	bool FInViewCone(CBaseEntity@ pEntity);
	//finds best visible enemy for attack;
	void BestVisibleEnemy();
	//Starts the monster;
	void StartMonster();
	//Revives the monster;
	void Revive();
	//Makes the monster become dead;
	void BecomeDead(float flSavedHealth);
	//Call after animation/pose is set up;
	void MonsterInitDead();
	//Initializes the monster;
	void MonsterInit();
	//use this overridden to make some other friendly monsters;
	void SetupFriendly();
	//Returns the amount of force applied to this monster when the given amount of damage is done.;
	float DamageForce(float flDamage);
	//returns the difference ( in degrees ) between monster\'s current yaw and ideal_yaw.\nPositive result is left turn, negative is right turn.;
	float FlYawDiff();
	//turns a directional vector into a yaw value that points down that vector.;
	float VecToYaw(Vector vecDir);
	//turns a monster towards its ideal_yaw;
	float ChangeYaw(int iSpeed);
	//Returns whether this monster should fade on death.;
	bool ShouldFadeOnDeath();
	//Listens for anything that is within audible distance.;
	void Listen();
	//Runs this monster\'s AI.;
	void RunAI();
	//Look - Base class monster function to find enemies or\nfood by sight. iDistance is distance ( in units ) that the\nmonster can see.\nSets the sight bits of the m_afConditions mask to indicate\nwhich types of entities were sighted.\nFunction also sets the Looker\'s m_pLink\nto the head of a link list that contains all visible ents.\n(linked via each ent\'s m_pLink field);
	void Look(int iDistance);
	//Will make a monster angry at whomever activated it.;
	void MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED.;
	int8& m_rgbTimeBasedDamage(size_t uiIndex);
	//Positions of movement. Index must be between 0 and ROUTE_SIZE;
	Waypoint& m_Route(size_t uiIndex);
	//Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES.;
	Vector& m_vecOldEnemy(size_t uiIndex);
	//Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES.;
	EHandle& m_hOldEnemy(size_t uiIndex);
	//The inventory rules.;
	InventoryRules@ get_m_pInventoryRules() const;
	//Returns whether this entity is locked by its master.\nSeparate from IsLockedByMaster due to limitations.;
	bool IsToggleLockedByMaster();
	//Performs angular movement.;
	void AngularMove(Vector vecDestAngle, float flSpeed);
	//Performs linear movement.;
	void LinearMove(Vector vecDest, float flSpeed);
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//Implicitly casts to base type.;
	CBaseAnimating@ opImplCast();
	//Implicitly casts to base type.;
	CBaseToggle@ opImplCast();
	//Damage modifier (%);
	float m_flEffectDamage;
	//Movement speed modifier (%);
	float m_flEffectSpeed;
	//Movement friction modifier (%);
	float m_flEffectFriction;
	//Gravity modifier (%);
	float m_flEffectGravity;
	//Extra/less breathing time underwater in seconds;
	float m_flEffectRespiration;
	//is non-solid;
	int m_iEffectNonSolid;
	//is invisible (render + non-targetable);
	int m_iEffectInvisible;
	//is invulnerable (god mode);
	int m_iEffectInvulnerable;
	//Monster can\'t use weapons.;
	int m_iEffectBlockWeapons;
	//Glow shell.;
	Vector m_vecEffectGlowColor;
	//Guard entity name.;
	string_t m_iszGuardEntName;
	//Monster will guard this entity and turn down follow requests.;
	EHandle m_hGuardEnt;
	//Current fall speed.;
	float m_flFallVelocity;
	//How long an npc will attempt to fire full auto.;
	float m_flAutomaticAttackTime;
	//Whether this monster can fear creatures.;
	bool m_fCanFearCreatures;
	//Current texture type.\nSee TextureType enum.;
	int8 m_chTextureType;
	//The formatted name.\nFor better name outputs. E.g. Alien Slave rather than alien_slave.;
	string_t m_FormattedName;
	//Don\'t allow +USE until this time.;
	float m_useTime;
	//Entity that is blocking cinematic execution.;
	EHandle m_hCineBlocker;
	//Cinematic entity.;
	EHandle m_hCine;
	//internal cinematic state.;
	SCRIPTSTATE m_scriptState;
	//HACK until we can query end of gun.;
	Vector m_HackedGunPos;
	//Name of target that should be fired.;
	string_t m_iszTriggerTarget;
	//for scripted AI, this is the condition that will cause the activation of the monster\'s TriggerTarget.;
	int m_iTriggerCondition;
	//distance monster sees (Default 2048).;
	float m_flDistLook;
	//if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy.;
	float m_flDistTooFar;
	//Time based damage inflictor.;
	float m_flHungryTime;
	//Schedule type to choose if current schedule fails.;
	int m_failSchedule;
	//Time based damage inflictor.;
	entvars_t@ pevTimeBasedInflictor;
	//Time-based damage timer.;
	float m_tbdPrev;
	//how much damage did monster (player) last take.;
	float m_lastDamageAmount;
	//what types of damage has monster (player) taken.;
	int m_bitsDamageType;
	//cannot attack again until this time.;
	float m_flNextAttack;
	//tells us what a monster can/can\'t do, while moving.;
	int m_afMoveShootCap;
	//tells us what a monster can/can\'t do.;
	int m_afCapability;
	//how much ammo is in the weapon (used to trigger reload anim sequences).;
	int m_cAmmoLoaded;
	//last known position of enemy. (enemy\'s origin).;
	Vector m_vecEnemyLKP;
	//keeps track of monster\'s maximum health value (for re-healing, etc).;
	int m_iMaxHealth;
	//color of blood particles.;
	int m_bloodColor;
	//Monster memory.;
	int m_afMemory;
	//this is the hint node that the monster is moving towards or performing active idle on..;
	int m_iHintNode;
	//monster sometimes wants to return to where it started after an operation..;
	Vector m_vecLastPosition;
	//Sound types that can be heard.;
	int m_afSoundTypes;
	//first index of a linked list of sounds that the monster can hear.;
	int m_iAudibleList;
	//When moving, set this activity.;
	Activity m_movementActivity;
	//Kept around for node graph moves, so we know our ultimate goal.;
	Vector m_vecMoveGoal;
	//Minimum radius.;
	float m_moveradius;
	//How long I should wait for something to move.;
	float m_moveWaitTime;
	//Index into m_Route[].;
	int m_iRouteIndex;
	//Goal that defines route.;
	int m_movementGoal;
	//Schedule index.;
	int m_iScheduleIndex;
	//For land_on_ground schedules (remember last schedule and continue).;
	Schedule@ m_pScheduleSaved;
	//Current schedule.;
	Schedule@ m_pSchedule;
	//Task status.;
	int m_iTaskStatus;
	//monster should change to this state.;
	MONSTERSTATE m_IdealMonsterState;
	//monster\'s current state.;
	MONSTERSTATE m_MonsterState;
	//the last body region that took damage.;
	int m_LastHitGroup;
	//gaitsequence.;
	Activity m_GaitActivity;
	//monster should switch to this activity.;
	Activity m_IdealActivity;
	//what the monster is doing (animation).;
	Activity m_Activity;
	//if we\'re told to wait before moving, this is the time that the wait will be over.;
	float m_flMoveWaitFinished;
	//if we\'re told to wait, this is the time that the wait will be over.;
	float m_flWaitFinished;
	//width of monster\'s field of view ( dot product ).;
	float m_flFieldOfView;
	//Target tank to control.;
	EHandle m_hTargetTank;
	//the entity that the monster is trying to reach.;
	EHandle m_hTargetEnt;
	//the entity that the monster is fighting.;
	EHandle m_hEnemy;
	//This entity\'s master, if any.;
	string_t m_sMaster;
	//DMG_ damage type that the door or trigger does.;
	int m_bitsDamageInflict;
	//Final angle.;
	Vector m_vecFinalAngle;
	//Final destination.;
	Vector m_vecFinalDest;
	//Open angle.;
	Vector m_vecAngle2;
	//Closed angle.;
	Vector m_vecAngle1;
	//Open position.;
	Vector m_vecPosition2;
	//Closed position.;
	Vector m_vecPosition1;
	//Handle to the activator.;
	EHandle m_hActivator;
	//Height.;
	float m_flHeight;
	//Trigger_counter only: # of activations remaining.;
	int m_cTriggersLeft;
	//For plats.;
	float m_flTLength;
	//For plats.;
	float m_flTWidth;
	//How much to stick out of a wall. Will recede further into walls if negative.;
	float m_flLip;
	//How long to wait before resetting.;
	float m_flWait;
	//How far a door should slide or rotate.;
	float m_flMoveDistance;
	//Current toggle state.;
	TOGGLE_STATE m_toggle_state;
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Grenade class;
class CGrenade {
	//Makes this grenade explode;
	void Explode(Vector vecSrc, Vector vecAim);
	//Reset all effect modifiers;
	void ResetEffects();
	//Re-calculate compounded effect modifiers and apply to the monster;
	void ApplyEffects();
	//Clears this monster\'s list of enemies;
	void ClearEnemyList();
	//The inventory items this monster has;
	InventoryList@ get_m_pInventory() const;
	//Medic call sound.;
	void MedicCallSound(float flDistance = 0.0f);
	//Current texture name we\'re standing on.;
	string m_szTextureName();
	//Stops following a player.;
	void StopPlayerFollowing(const bool bClearSchedule);
	//Starts following a given player.;
	void StartPlayerFollowing(CBaseEntity@ pLeader);
	//Returns whether this monster can follow a player.;
	bool CanPlayerFollow();
	//Returns whether this monster is following a player.;
	bool IsPlayerFollowing();
	//Use method for following players (set only if friendly);
	void FollowerPlayerUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue);
	//Turns the shock glow effect on or off.;
	void ShockGlowEffect(bool fMode);
	//Drops the given item from the given position at the given angle.;
	CBaseEntity@ DropItem(const string& in szItemName, const Vector& in vecPos, const Vector& in vecAng);
	//Cleans up after a cinematic event.;
	bool CineCleanup();
	//Exits the scripted sequence this monster is currently in, if any.;
	bool ExitScriptedSequence();
	//Returns whether this monster remembers all of the given memories.;
	bool HasAllMemories(int iMemory) const;
	//Returns whether this monster remembers any of the given memories.;
	bool HasMemory(int iMemory) const;
	//Makes this monster forget the given memories.;
	void Forget(int iMemory);
	//Makes this monster remember the given memories.;
	void Remember(int iMemory);
	//Stops following its target.;
	void StopPlayerFollowing(const bool clearSchedule, bool bSilent = false);
	//Starts following its target.;
	void StartPlayerFollowing(CBaseEntity@ pLeader, bool bSilent = false);
	//Plays this monster\'s pain sound.;
	void PainSound();
	//Plays this monster\'s idle sound.;
	void IdleSound();
	//Plays this monster\'s alert sound.;
	void AlertSound();
	//Plays this monster\'s death sound.;
	void DeathSound();
	//;
	Vector GetGunPosition();
	//Shoots at the specified location.;
	Vector ShootAtEnemy(const Vector& in vecShootOrigin);
	//Fades this monster.\nNote: does not kill the monster.;
	void FadeMonster();
	//Returns whether this monster has alien gibs.;
	bool HasAlienGibs();
	//Returns whether this monster has human gibs.;
	bool HasHumanGibs();
	//Determines whether to gib or fade this monster, and acts accordingly.;
	void CallGibMonster();
	//Returns whether the monster should be gibbed given the gib type.\nSee GIB enum.;
	bool ShouldGibMonster(int iGib);
	//Gibs the monster.;
	void GibMonster();
	//Tries to find the best suitable enemy for this monster.;
	bool GetEnemy();
	//Returns whether attacking the target location at this time would result in friendly fire;
	bool NoFriendlyFireToPos(Vector vecPos);
	//Returns whether attacking the given target at this time from the given location would result in friendly fire;
	bool NoFriendlyFire(Vector vecPos, CBaseEntity@ pTarget);
	//Returns whether attacking at this time from the given location would result in friendly fire;
	bool NoFriendlyFire(Vector vecPos);
	//Returns whether attacking at this time would result in friendly fire;
	bool NoFriendlyFire();
	//Checks and, if necessary, fires the monster\'s trigger target.;
	bool FCheckAITrigger();
	//Make the monster \'full\' for a while.;
	void Eat(float flFullDuration);
	//Returns whether this monster should eat.;
	bool FShouldEat();
	//Returns a pointer to the sound the monster should react to.;
	CSound@ PBestSound();
	//Returns whether this monster has all of the given AI conditions.;
	bool HasAllConditions(int iConditions) const;
	//Returns whether this monster has any of the given AI conditions.;
	bool HasConditions(int iConditions) const;
	//Clears AI conditions.;
	void ClearConditions(int iConditions);
	//Sets AI conditions.;
	void SetConditions(int iConditions);
	//Determine if we should ignore damage.;
	bool CheckAttacker(CBaseEntity@ pAttacker);
	//Returns the MOVEGOAL for the given move flag.;
	int RouteClassify(int iMoveFlag);
	//Allows different yaw_speeds for each activity.;
	void SetYawSpeed();
	//gets a yaw value for the caller that would\nface the supplied vector. Value is stuffed into the monster\'s\nideal_yaw.;
	void MakeIdealYaw(Vector vecTarget);
	//Returns an integer with all Conditions\nbits that are currently set and also set in the current\nschedule\'s Interrupt mask.;
	int IScheduleFlags();
	//Returns whether movement is complete.;
	bool MovementIsComplete();
	//Returns whether the task is complete.;
	bool TaskIsComplete();
	//Returns whether a task is running.;
	bool TaskIsRunning();
	//Sets the task status to running.;
	void TaskBegin();
	//Sets the condition bit for a failed task.;
	void TaskFail();
	//Called when movement has completed.;
	void MovementComplete();
	//Sets the task status to complete.;
	void TaskComplete();
	//TEST FGetNodeRoute.;
	bool TestFGetNodeRoute(Vector vecDest);
	//tries to build an entire node path from\nthe callers origin to the passed vector.\nIf this is  possible, ROUTE_SIZE waypoints will be copied into the callers m_Route.\ntrue is returned if the operation  succeeds (path is valid) or false if failed (no path  exists ).;
	bool FGetNodeRoute(Vector vecDest);
	//Try remembering the last few enemies.;
	bool PopEnemy();
	//Remember the last few enemies, always remember the player.;
	void PushEnemy(CBaseEntity@ pTarget, Vector& in vecLastKnownPos);
	//part of the Condition collection process, gets and stores data and conditions pertaining to a monster\'s enemy.\nReturns true if Enemy LKP was updated.;
	bool CheckEnemy(CBaseEntity@ pEnemy);
	//Check whether attacks are possible from the given position.;
	bool CheckAttacksFromPosition(CBaseEntity@ pTarget, float flDist, Vector vecPos);
	//Check attacks to the given enemy at the given distance while moving.;
	void CheckAttacks_Move(CBaseEntity@ pTarget, float flDist);
	//Check attacks to the given enemy at the given distance.;
	void CheckAttacks(CBaseEntity@ pTarget, float flDist);
	//Reports the AI state.;
	void ReportAIState();
	//Sets the current monster state.;
	void SetState(MONSTERSTATE state);
	//Sets the current sequence by name.;
	void SetSequenceByName(const string& in szSequence);
	//Sets the current gait activity.;
	void SetGaitActivity(Activity newActivity);
	//Sets the current activity.;
	void SetActivity(Activity newActivity);
	//Gets the ideal monster state.;
	MONSTERSTATE GetIdealState();
	//Gets the current task.;
	Task@ GetTask();
	//Stops playing its current sentence.;
	void SentenceStop();
	//Plays the given scripted sentence.;
	void PlayScriptedSentence(const string& in szSentence, float duration, float volume, float attenuation, const bool bConcurrent, CBaseEntity@ pListener);
	//Plays the given sentence.;
	void PlaySentence(const string& in szSentence, float duration, float volume, float attenuation);
	//Returns whether this monster can play its sentence.;
	bool CanPlaySentence(const bool bDisregardState);
	//Returns whether this monster can play its sequence.;
	bool CanPlaySequence(const bool bDisregardState, int iInterruptLevel);
	//Called after the monster\'s schedule changes.;
	void ScheduleChange();
	//Gets the current schedule.;
	Schedule@ GetSchedule();
	//Gets one of the available schedules of the given type.;
	Schedule@ GetScheduleOfType(int iType);
	//Runs the given task.;
	void RunTask(Task@ pTask);
	//Starts the given task.;
	void StartTask(Task@ pTask);
	//Maintains the monster\'s schedule.;
	void MaintainSchedule();
	//Returns the schedule with name szName if it exists, NULL otherwise.;
	Schedule@ ScheduleFromName(const string& in szName);
	//Returns the schedule with name szName if it\'s in the list, NULL otherwise.;
	Schedule@ ScheduleInList(const string& in szName, array<Schedule@>@ pArray);
	//Moves to the next scheduled task.;
	bool NextScheduledTask();
	//Changes this monster\'s schedule.;
	void ChangeSchedule(Schedule@ pNewSchedule);
	//Returns whether this monster\'s schedule is done.;
	bool FScheduleDone();
	//Clears this monster\'s schedule.;
	void ClearSchedule();
	//Returns whether this monster\'s schedule is valid.;
	bool FScheduleValid();
	//Returns whether this monster has a schedule.;
	bool FHaveSchedule();
	//Checks whether the monster can use a func_tank. Return true if possible.;
	bool CheckTankUsage();
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack2_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack2(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack1_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckMeleeAttack1(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack2_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack2(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack1_Move(float flDot, float flDist);
	//this function will survey conditions and set appropriate conditions bits for attack types.;
	bool CheckRangeAttack1(float flDot, float flDist);
	//This will stop animation until you call ResetSequenceInfo() at some point in the future;
	void StopAnimation();
	//Stops this monster moving;
	void Stop();
	//Gets the stopped activity;
	Activity GetStoppedActivity();
	//Returns whether this monster should advance its route;
	bool ShouldAdvanceRoute(float flWaypointDist);
	//Starts the monster;
	void MoveExecute(CBaseEntity@ pTargetEnt, const Vector& in vecDir, float flInterval);
	//Starts the monster;
	void Move(float flInterval = 0.1f);
	//finds best visible enemy for attack;
	int CheckLocalMove(const Vector& in vecStart, const Vector& in vecEnd,CBaseEntity@ pTarget, float& out flDist, Vector& out vecEndPosition, bool fOriginalCheck = false);
	//see if given location is in monster\'s view cone;
	bool FInViewCone(const Vector& in vecOrigin);
	//see if pEntity is in monster\'s view cone;
	bool FInViewCone(CBaseEntity@ pEntity);
	//finds best visible enemy for attack;
	void BestVisibleEnemy();
	//Starts the monster;
	void StartMonster();
	//Revives the monster;
	void Revive();
	//Makes the monster become dead;
	void BecomeDead(float flSavedHealth);
	//Call after animation/pose is set up;
	void MonsterInitDead();
	//Initializes the monster;
	void MonsterInit();
	//use this overridden to make some other friendly monsters;
	void SetupFriendly();
	//Returns the amount of force applied to this monster when the given amount of damage is done.;
	float DamageForce(float flDamage);
	//returns the difference ( in degrees ) between monster\'s current yaw and ideal_yaw.\nPositive result is left turn, negative is right turn.;
	float FlYawDiff();
	//turns a directional vector into a yaw value that points down that vector.;
	float VecToYaw(Vector vecDir);
	//turns a monster towards its ideal_yaw;
	float ChangeYaw(int iSpeed);
	//Returns whether this monster should fade on death.;
	bool ShouldFadeOnDeath();
	//Listens for anything that is within audible distance.;
	void Listen();
	//Runs this monster\'s AI.;
	void RunAI();
	//Look - Base class monster function to find enemies or\nfood by sight. iDistance is distance ( in units ) that the\nmonster can see.\nSets the sight bits of the m_afConditions mask to indicate\nwhich types of entities were sighted.\nFunction also sets the Looker\'s m_pLink\nto the head of a link list that contains all visible ents.\n(linked via each ent\'s m_pLink field);
	void Look(int iDistance);
	//Will make a monster angry at whomever activated it.;
	void MonsterUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//time based damage counters, decr. 1 per 2 seconds. Index must be between 0 and CMG_TIMEBASED.;
	int8& m_rgbTimeBasedDamage(size_t uiIndex);
	//Positions of movement. Index must be between 0 and ROUTE_SIZE;
	Waypoint& m_Route(size_t uiIndex);
	//Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES.;
	Vector& m_vecOldEnemy(size_t uiIndex);
	//Target tank to control. Index must be between 0 and MAX_OLD_ENEMIES.;
	EHandle& m_hOldEnemy(size_t uiIndex);
	//The inventory rules.;
	InventoryRules@ get_m_pInventoryRules() const;
	//Returns whether this entity is locked by its master.\nSeparate from IsLockedByMaster due to limitations.;
	bool IsToggleLockedByMaster();
	//Performs angular movement.;
	void AngularMove(Vector vecDestAngle, float flSpeed);
	//Performs linear movement.;
	void LinearMove(Vector vecDest, float flSpeed);
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//Implicitly casts to base type.;
	CBaseAnimating@ opImplCast();
	//Implicitly casts to base type.;
	CBaseToggle@ opImplCast();
	//Implicitly casts to base type.;
	CBaseMonster@ opImplCast();
	//Damage modifier (%);
	float m_flEffectDamage;
	//Movement speed modifier (%);
	float m_flEffectSpeed;
	//Movement friction modifier (%);
	float m_flEffectFriction;
	//Gravity modifier (%);
	float m_flEffectGravity;
	//Extra/less breathing time underwater in seconds;
	float m_flEffectRespiration;
	//is non-solid;
	int m_iEffectNonSolid;
	//is invisible (render + non-targetable);
	int m_iEffectInvisible;
	//is invulnerable (god mode);
	int m_iEffectInvulnerable;
	//Monster can\'t use weapons.;
	int m_iEffectBlockWeapons;
	//Glow shell.;
	Vector m_vecEffectGlowColor;
	//Guard entity name.;
	string_t m_iszGuardEntName;
	//Monster will guard this entity and turn down follow requests.;
	EHandle m_hGuardEnt;
	//Current fall speed.;
	float m_flFallVelocity;
	//How long an npc will attempt to fire full auto.;
	float m_flAutomaticAttackTime;
	//Whether this monster can fear creatures.;
	bool m_fCanFearCreatures;
	//Current texture type.\nSee TextureType enum.;
	int8 m_chTextureType;
	//The formatted name.\nFor better name outputs. E.g. Alien Slave rather than alien_slave.;
	string_t m_FormattedName;
	//Don\'t allow +USE until this time.;
	float m_useTime;
	//Entity that is blocking cinematic execution.;
	EHandle m_hCineBlocker;
	//Cinematic entity.;
	EHandle m_hCine;
	//internal cinematic state.;
	SCRIPTSTATE m_scriptState;
	//HACK until we can query end of gun.;
	Vector m_HackedGunPos;
	//Name of target that should be fired.;
	string_t m_iszTriggerTarget;
	//for scripted AI, this is the condition that will cause the activation of the monster\'s TriggerTarget.;
	int m_iTriggerCondition;
	//distance monster sees (Default 2048).;
	float m_flDistLook;
	//if enemy farther away than this, bits_COND_ENEMY_TOOFAR set in CheckEnemy.;
	float m_flDistTooFar;
	//Time based damage inflictor.;
	float m_flHungryTime;
	//Schedule type to choose if current schedule fails.;
	int m_failSchedule;
	//Time based damage inflictor.;
	entvars_t@ pevTimeBasedInflictor;
	//Time-based damage timer.;
	float m_tbdPrev;
	//how much damage did monster (player) last take.;
	float m_lastDamageAmount;
	//what types of damage has monster (player) taken.;
	int m_bitsDamageType;
	//cannot attack again until this time.;
	float m_flNextAttack;
	//tells us what a monster can/can\'t do, while moving.;
	int m_afMoveShootCap;
	//tells us what a monster can/can\'t do.;
	int m_afCapability;
	//how much ammo is in the weapon (used to trigger reload anim sequences).;
	int m_cAmmoLoaded;
	//last known position of enemy. (enemy\'s origin).;
	Vector m_vecEnemyLKP;
	//keeps track of monster\'s maximum health value (for re-healing, etc).;
	int m_iMaxHealth;
	//color of blood particles.;
	int m_bloodColor;
	//Monster memory.;
	int m_afMemory;
	//this is the hint node that the monster is moving towards or performing active idle on..;
	int m_iHintNode;
	//monster sometimes wants to return to where it started after an operation..;
	Vector m_vecLastPosition;
	//Sound types that can be heard.;
	int m_afSoundTypes;
	//first index of a linked list of sounds that the monster can hear.;
	int m_iAudibleList;
	//When moving, set this activity.;
	Activity m_movementActivity;
	//Kept around for node graph moves, so we know our ultimate goal.;
	Vector m_vecMoveGoal;
	//Minimum radius.;
	float m_moveradius;
	//How long I should wait for something to move.;
	float m_moveWaitTime;
	//Index into m_Route[].;
	int m_iRouteIndex;
	//Goal that defines route.;
	int m_movementGoal;
	//Schedule index.;
	int m_iScheduleIndex;
	//For land_on_ground schedules (remember last schedule and continue).;
	Schedule@ m_pScheduleSaved;
	//Current schedule.;
	Schedule@ m_pSchedule;
	//Task status.;
	int m_iTaskStatus;
	//monster should change to this state.;
	MONSTERSTATE m_IdealMonsterState;
	//monster\'s current state.;
	MONSTERSTATE m_MonsterState;
	//the last body region that took damage.;
	int m_LastHitGroup;
	//gaitsequence.;
	Activity m_GaitActivity;
	//monster should switch to this activity.;
	Activity m_IdealActivity;
	//what the monster is doing (animation).;
	Activity m_Activity;
	//if we\'re told to wait before moving, this is the time that the wait will be over.;
	float m_flMoveWaitFinished;
	//if we\'re told to wait, this is the time that the wait will be over.;
	float m_flWaitFinished;
	//width of monster\'s field of view ( dot product ).;
	float m_flFieldOfView;
	//Target tank to control.;
	EHandle m_hTargetTank;
	//the entity that the monster is trying to reach.;
	EHandle m_hTargetEnt;
	//the entity that the monster is fighting.;
	EHandle m_hEnemy;
	//This entity\'s master, if any.;
	string_t m_sMaster;
	//DMG_ damage type that the door or trigger does.;
	int m_bitsDamageInflict;
	//Final angle.;
	Vector m_vecFinalAngle;
	//Final destination.;
	Vector m_vecFinalDest;
	//Open angle.;
	Vector m_vecAngle2;
	//Closed angle.;
	Vector m_vecAngle1;
	//Open position.;
	Vector m_vecPosition2;
	//Closed position.;
	Vector m_vecPosition1;
	//Handle to the activator.;
	EHandle m_hActivator;
	//Height.;
	float m_flHeight;
	//Trigger_counter only: # of activations remaining.;
	int m_cTriggersLeft;
	//For plats.;
	float m_flTLength;
	//For plats.;
	float m_flTWidth;
	//How much to stick out of a wall. Will recede further into walls if negative.;
	float m_flLip;
	//How long to wait before resetting.;
	float m_flWait;
	//How far a door should slide or rotate.;
	float m_flMoveDistance;
	//Current toggle state.;
	TOGGLE_STATE m_toggle_state;
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Generic item class;
class CItem {
	//The item\'s touch function.;
	bool MyTouch(CBasePlayer@ pPlayer);
	//Makes this entity visible and tangible.;
	void Materialize();
	//Item touch function;
	void ItemTouch(CBaseEntity@ pOther);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Item_inventory entity class\nCollection rules -- DENY/CAN\'T have rules take precedence over REQUIRE/MUST\nAll string filters can be tokenized with a semi-colon \';\';
class CItemInventory {
	//Prepares to remove effects from holder.;
	void RemoveItemEffects();
	//Prepares to add effects to holder.;
	void AddItemEffects();
	//Destroys this item.;
	void Destroy();
	//Returns this item to its original spawn location.;
	void Return();
	//Drops this item, if it\'s being carried.;
	bool Drop(bool fForce = false, CBaseEntity@ pCaller = null);
	//Returns whether this item can be collected by the given entity.;
	bool CanCollect(CBaseEntity@ pOther);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Item was just removed by force;
	bool m_fRemovedByForced;
	//Time the item was last dropped;
	float m_flDropTime;
	//Time the item was last collected;
	float m_flCollectTime;
	//Time the item was last touched;
	float m_flTouchedTime;
	//Number of times the item has been collected;
	int m_iCollectCount;
	//Damage modifier (%);
	float m_flEffectDamage;
	//Movement speed modifier (%);
	float m_flEffectSpeed;
	//Movement friction modifier (%);
	float m_flEffectFriction;
	//Gravity modifier (%);
	float m_flEffectGravity;
	//Extra/less breathing time underwater in seconds;
	float m_flEffectRespiration;
	//Holder is non-solid;
	bool m_fEffectNonSolid;
	//Holder is invisible (render + non-targetable);
	bool m_fEffectInvisible;
	//Holder is invulnerable (god mode);
	bool m_fEffectInvulnerable;
	//Holder can\'t use weapons;
	bool m_fEffectBlockWeapons;
	//Holder has a glow shell;
	Vector m_vecEffectGlowColor;
	//Holder keeps effects after dropping the item;
	bool m_fEffectsPermanent;
	//On destroy;
	string_t m_szTriggerOnDestroy;
	//On materialise after return;
	string_t m_szTriggerOnMaterialise;
	//On return (for everyone else);
	string_t m_szTriggerOnReturnOther;
	//On return (for collector\'s team);
	string_t m_szTriggerOnReturnTeam;
	//On return (for collector);
	string_t m_szTriggerOnReturnSelf;
	//On wearing out (for everyone else);
	string_t m_szTriggerOnWearingOutOther;
	//On wearing out (for collector\'s team);
	string_t m_szTriggerOnWearingOutTeam;
	//On wearing out (for collector);
	string_t m_szTriggerOnWearingOutSelf;
	//On use by trigger (for everyone else);
	string_t m_szTriggerOnUseOther;
	//On use by trigger (for collector\'s team);
	string_t m_szTriggerOnUseTeam;
	//On use by trigger (for collector);
	string_t m_szTriggerOnUseSelf;
	//On failed drop (for everyone else);
	string_t m_szTriggerOnCantDropOther;
	//On failed drop (for collector\'s team);
	string_t m_szTriggerOnCantDropTeam;
	//On failed drop (for collector);
	string_t m_szTriggerOnCantDropSelf;
	//On successful drop (for everyone else);
	string_t m_szTriggerOnDropOther;
	//On successful drop (for collector\'s team);
	string_t m_szTriggerOnDropTeam;
	//On successful drop (for collector);
	string_t m_szTriggerOnDropSelf;
	//On failed collection (for everyone else);
	string_t m_szTriggerOnCantCollectOther;
	//On failed collection (for collector\'s team);
	string_t m_szTriggerOnCantCollectTeam;
	//On failed collection (for collector);
	string_t m_szTriggerOnCantCollectSelf;
	//On successful collection (for everyone else);
	string_t m_szTriggerOnCollectOther;
	//On successful collection (for collector\'s team);
	string_t m_szTriggerOnCollectTeam;
	//On successful collection (for collector);
	string_t m_szTriggerOnCollectSelf;
	//Holder still has the item after respawning (only applies to players -- re-equip NPC\'s manually);
	bool m_fKeepOnRespawn;
	//Holder still has the item after dying (i.e. so they can keep it while being revived);
	bool m_fKeepOnDeath;
	//Delayed respawn on return (like with weapons/ammo/pickups);
	bool m_fDelayedRespawn;
	//How long this item returns to its\' original location when dropped (-1 = never, 0 = instant);
	float m_flReturnTime;
	//Holder is allowed to drop this item by choice;
	bool m_fCanBeDropped;
	//Perform a trigger prior to this item being forcibly dropped (0 = none);
	float m_flWearOutTime;
	//Limit to how long this item can be held for, forcibly dropped after (0 = no limit);
	float m_flMaximumHoldTime;
	//These item(s) must NOT have moved;
	string_t m_szItemNameNotMoved;
	//Number of item(s) from the can\'t have group(s) (0 = all);
	int m_iCantHaveItemGroupNum;
	//Must not have an item in these group(s);
	string_t m_szCantHaveItemGroup;
	//Must not have these item(s);
	string_t m_szCantHaveItemName;
	//These item(s) must have moved;
	string_t m_szItemNameMoved;
	//Number of item(s) from the required group(s) required (0 = all);
	int m_iRequiresItemGroupNum;
	//Require an item from these group(s);
	string_t m_szRequiresItemGroup;
	//Require these item(s);
	string_t m_szRequiresItemName;
	//NPC classification filter;
	int m_iAllowedNpcClassify;
	//Team filters;
	string_t m_szAllowedTeams;
	//CBaseEntity class name filters;
	string_t m_szAllowedClassNames;
	//CBaseEntity target name filters;
	string_t m_szAllowedTargetNames;
	//Model sequence number while CARRIED.;
	int m_iCarriedSequence;
	//Model sequence name while CARRIED.;
	string_t m_szCarriedSequenceName;
	//Model body while CARRIED.;
	int m_iCarriedBody;
	//Model skin while CARRIED.;
	int m_iCarriedSkin;
	//Model sequence number while IDLE.;
	int m_iIdleSequence;
	//Model sequence name while IDLE.;
	string_t m_szIdleSequenceName;
	//Model body while IDLE.;
	int m_iIdleBody;
	//Model skin while IDLE (not carried).;
	int m_iIdleSkin;
	//Model is hidden while it is being carried.;
	bool m_fHiddenWhenCarried;
	//How heavy the item is (0-100),\nholders can hold multiple items up to a total weight 100, think of this as KG if you like (though what person can carry 100KG!?).;
	float m_flWeight;
	//How many times the item can be picked up, destroyed when limit is reached (0 = infinite).;
	int m_iCollectLimit;
	//Friendly item description for client-side UI.;
	string_t m_szDescription;
	//Friendly item name for client-side UI.;
	string m_szDisplayName;
	//Group name referred to by triggers.;
	string_t m_szItemGroup;
	//Item name referred to by triggers, doesn\'t need to be unique -- remember the targetname refers to the entity itself only.;
	string_t m_szItemName;
	//Spawn-time move type.;
	int m_iMoveType;
	//Spawn-time angles.;
	Vector m_vecSpawnAngles;
	//Spawn-time origin.;
	Vector m_vecSpawnOrigin;
	//The monster or player holding this item.;
	EHandle m_hHolder;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Player ammo class;
class CBasePlayerAmmo {
	//Makes this entity visible and tangible.;
	void Materialize();
	//Adds ammo to the given entity.;
	bool AddAmmo(CBaseEntity@ pOther);
	//Default touch;
	void DefaultTouch(CBaseEntity@ pOther);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Player Weapon entity base class;
class CBasePlayerWeapon {
	//;
	void ChangeWeaponSkin(int16 skin);
	//0 means reset to default fov;
	void SetFOV(int iFOV);
	//Precaches custom models if needed.;
	void PrecacheCustomModels();
	//Gets the weapon\'s V model.;
	string GetV_Model(const string& in szAlternative);
	//Gets the weapon\'s V model.;
	string GetV_Model();
	//Gets the weapon\'s W model.;
	string GetW_Model(const string& in szAlternative);
	//Gets the weapon\'s W model.;
	string GetW_Model();
	//Gets the weapon\'s P model.;
	string GetP_Model(const string& in szAlternative);
	//Gets the weapon\'s P model.;
	string GetP_Model();
	//;
	void BurstSupplement();
	//Whether the client predicts this weapon;
	bool UseDecrement();
	//;
	bool ShouldWeaponIdle();
	//no more ammo for this gun, put it away.;
	void RetireWeapon();
	//called when no buttons pressed;
	void WeaponIdle();
	//Returns whether this weapon should reload automatically.;
	bool ShouldReload();
	//Finishes the reload for this weapon.;
	void FinishReload();
	//;
	void Reload();
	//do +ATTACK3;
	void TertiaryAttack();
	//do +ATTACK2;
	void SecondaryAttack();
	//do +ATTACK;
	void PrimaryAttack();
	//;
	bool DefaultReload(int iClipSize, int iAnim, float flDelay, int iSubModel = 0);
	//;
	bool DefaultReload(int iClipSize, int iAnim, float flDelay, int iSubModel, int iClip, int iAmmoType);
	//;
	bool DefaultDeploy(const string& in szViewModel, const string& in szWeaponModel, int iAnim, const string& in szAnimExt, int skiplocal = 0, int body = 0);
	//;
	bool IsUseable();
	//Universal code to determine player bullet accuracy based on speed/stance;
	Vector BulletAccuracy(const Vector& in vecMoving, const Vector& in vecStanding, const Vector& in vecCrouched);
	//skiplocal is 1 if client is predicting weapon animations;
	void SendWeaponAnim(int iAnim, int skiplocal = 0, int body = 0);
	//;
	void ResetEmptySound();
	//;
	bool PlayEmptySound();
	//;
	int AddSecondaryAmmo(int iCount, const string& in szName, int iMaxCarry);
	//;
	int AddPrimaryAmmo(int iCount, const string& in szName, int iMaxClip, int iMaxCarry);
	//;
	bool AddWeapon();
	//;
	bool ExtractClipAmmo(CBasePlayerWeapon@ pWeapon);
	//;
	bool ExtractAmmo(CBasePlayerWeapon@ pWeapon);
	//Can this weapon have duplicates added?;
	bool CanHaveDuplicates();
	//CBaseEntity to drop.\nBy default, this entity.;
	CBasePlayerItem@ DropItem();
	//Gets this item\'s respawn time (time from pickup to respawn).;
	float GetRespawnTime() const;
	//Gets the item flags.;
	int iFlags();
	//Gets the item weight.;
	int iWeight();
	//Gets the max clip amount.;
	int iMaxClip();
	//Gets the name of this item.;
	string pszName();
	//Gets the secondary ammo maximum.;
	int iMaxAmmo2();
	//Gets the name of the secondary ammo.;
	string pszAmmo2();
	//Gets the primary ammo maximum.;
	int iMaxAmmo1();
	//Gets the name of the primary ammo.;
	string pszAmmo1();
	//Gets the item position.;
	int iItemPosition();
	//Gets the slot this item is in. 0 to MAX_ITEMS_SLOTS.;
	int iItemSlot();
	//Gets this item as a weapon. Returns null if this is not a weapon.;
	CBasePlayerWeapon@ GetWeaponPtr();
	//Updates client data.;
	bool UpdateClientData(CBasePlayer@ pPlayer);
	//Gets the secondary ammo index, or -1 if this item doesn\'t use secondary ammo.;
	int SecondaryAmmoIndex();
	//Gets the primary ammo index, or -1 if this item doesn\'t use primary ammo.;
	int PrimaryAmmoIndex();
	//Attach this item to the given player.;
	void AttachToPlayer(CBasePlayer@ pPlayer);
	//Kills this item.;
	void Kill();
	//Load item sprites.;
	void LoadSprites(CBasePlayer@ pPlayer, const string& in szName);
	//Updates item info.;
	void UpdateItemInfo();
	//Holsters this weapon.;
	void Holster(int iSkipLocal = 0);
	//Can this weapon be put away right now?;
	bool CanHolster();
	//Returns if deploy was successful.;
	bool Deploy();
	//Returns whether this item can deploy.;
	bool CanDeploy();
	//Gets item info.;
	void GetItemInfo(ItemInfo& out info);
	//Check respawn.;
	void CheckRespawn();
	//Fall init.;
	void FallInit();
	//Copy a weapon.;
	CBasePlayerItem@ RespawnItem();
	//Think function. The weapon desires to become visible and tangible, if the game rules allow for it.;
	void AttemptToMaterialize();
	//Make a weapon visible and tangible.;
	void Materialize();
	//Think function. When an item is first spawned, this think is run to determine when the object has hit the ground.;
	void FallThink();
	//Default weapon use function.;
	void ItemUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue);
	//Touch function. Default touch.;
	void DefaultTouch(CBaseEntity@ pOther);
	//Attempts to let pOther collect this item.;
	void Collect(CBaseEntity@ pOther);
	//Think function. Destroys this item.;
	void DestroyItem();
	//returns true if this item wants the duplicate removed from the world.;
	bool AddDuplicate(CBasePlayerItem@ pItem);
	//Returns true if this item wants itself added to the player\'s inventory.;
	bool AddToPlayer(CBasePlayer@ pPlayer);
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//Implicitly casts to base type.;
	CBaseAnimating@ opImplCast();
	//Implicitly casts to base type.;
	CBasePlayerItem@ opImplCast();
	//The amount of secondary ammo you receive when you pick up this weapon as placed by a level designer.;
	int m_iDefaultSecAmmo;
	//The amount of primary ammo you receive when you pick up this weapon as placed by a level designer.;
	int m_iDefaultAmmo;
	//When the next burst round is to be fired;
	float m_flNextBurstRound;
	//Weapon is zoomed in;
	bool m_fInZoom;
	//Weapon is in \'akimbo\' mode;
	bool m_fIsAkimbo;
	//Per-entity weapon damage;
	float m_flCustomDmg;
	//Are we in the middle of a reload;
	bool m_fInReload;
	//number of shots left in the secondary weapon clip, -1 it not used;
	int m_iClip2;
	//number of shots left in the primary weapon clip, -1 it not used;
	int m_iClip;
	//secondary ammo index into players m_rgAmmo[];
	int m_iSecondaryAmmoType;
	//primary ammo index into players m_rgAmmo[];
	int m_iPrimaryAmmoType;
	//soonest time ItemPostFrame will call WeaponIdle;
	float m_flTimeWeaponIdle;
	//soonest time ItemPostFrame will call TertiaryAttack;
	float m_flNextTertiaryAttack;
	//soonest time ItemPostFrame will call SecondaryAttack;
	float m_flNextSecondaryAttack;
	//soonest time ItemPostFrame will call PrimaryAttack;
	float m_flNextPrimaryAttack;
	//True when the gun is empty and the player is still holding down the attack key(s);
	bool m_bFireOnEmpty;
	//Whether to play the empty sound when the player attempts to fire;
	bool m_bPlayEmptySound;
	//If set, as long as a player has this item, the player must keep this weapon selected.No more than one item with this set can be carried at one time.;
	bool m_bExclusiveHold;
	//The last bounce time.;
	float m_flLastBounce;
	//The item id.;
	const int m_iId;
	//Gets the next item. null if no next item.;
	EHandle m_hNextItem;
	//The owning player. null if no owner.;
	EHandle m_hPlayer;
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Player item base class;
class CBasePlayerItem {
	//Explicitly casts to sub type.;
	CBasePlayerWeapon@ opCast();
	//Can this weapon have duplicates added?;
	bool CanHaveDuplicates();
	//CBaseEntity to drop.\nBy default, this entity.;
	CBasePlayerItem@ DropItem();
	//Gets this item\'s respawn time (time from pickup to respawn).;
	float GetRespawnTime() const;
	//Gets the item flags.;
	int iFlags();
	//Gets the item weight.;
	int iWeight();
	//Gets the max clip amount.;
	int iMaxClip();
	//Gets the name of this item.;
	string pszName();
	//Gets the secondary ammo maximum.;
	int iMaxAmmo2();
	//Gets the name of the secondary ammo.;
	string pszAmmo2();
	//Gets the primary ammo maximum.;
	int iMaxAmmo1();
	//Gets the name of the primary ammo.;
	string pszAmmo1();
	//Gets the item position.;
	int iItemPosition();
	//Gets the slot this item is in. 0 to MAX_ITEMS_SLOTS.;
	int iItemSlot();
	//Gets this item as a weapon. Returns null if this is not a weapon.;
	CBasePlayerWeapon@ GetWeaponPtr();
	//Updates client data.;
	bool UpdateClientData(CBasePlayer@ pPlayer);
	//Gets the secondary ammo index, or -1 if this item doesn\'t use secondary ammo.;
	int SecondaryAmmoIndex();
	//Gets the primary ammo index, or -1 if this item doesn\'t use primary ammo.;
	int PrimaryAmmoIndex();
	//Attach this item to the given player.;
	void AttachToPlayer(CBasePlayer@ pPlayer);
	//Kills this item.;
	void Kill();
	//Load item sprites.;
	void LoadSprites(CBasePlayer@ pPlayer, const string& in szName);
	//Updates item info.;
	void UpdateItemInfo();
	//Holsters this weapon.;
	void Holster(int iSkipLocal = 0);
	//Can this weapon be put away right now?;
	bool CanHolster();
	//Returns if deploy was successful.;
	bool Deploy();
	//Returns whether this item can deploy.;
	bool CanDeploy();
	//Gets item info.;
	void GetItemInfo(ItemInfo& out info);
	//Check respawn.;
	void CheckRespawn();
	//Fall init.;
	void FallInit();
	//Copy a weapon.;
	CBasePlayerItem@ RespawnItem();
	//Think function. The weapon desires to become visible and tangible, if the game rules allow for it.;
	void AttemptToMaterialize();
	//Make a weapon visible and tangible.;
	void Materialize();
	//Think function. When an item is first spawned, this think is run to determine when the object has hit the ground.;
	void FallThink();
	//Default weapon use function.;
	void ItemUse(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue);
	//Touch function. Default touch.;
	void DefaultTouch(CBaseEntity@ pOther);
	//Attempts to let pOther collect this item.;
	void Collect(CBaseEntity@ pOther);
	//Think function. Destroys this item.;
	void DestroyItem();
	//returns true if this item wants the duplicate removed from the world.;
	bool AddDuplicate(CBasePlayerItem@ pItem);
	//Returns true if this item wants itself added to the player\'s inventory.;
	bool AddToPlayer(CBasePlayer@ pPlayer);
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//Implicitly casts to base type.;
	CBaseAnimating@ opImplCast();
	//If set, as long as a player has this item, the player must keep this weapon selected.No more than one item with this set can be carried at one time.;
	bool m_bExclusiveHold;
	//The last bounce time.;
	float m_flLastBounce;
	//The item id.;
	const int m_iId;
	//Gets the next item. null if no next item.;
	EHandle m_hNextItem;
	//The owning player. null if no owner.;
	EHandle m_hPlayer;
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//All entities that can be toggled derive from this;
class CBaseToggle {
	//Explicitly casts to sub type.;
	CBaseDoor@ opCast();
	//Explicitly casts to sub type.;
	CBaseButton@ opCast();
	//Explicitly casts to sub type.;
	CGrenade@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayer@ opCast();
	//Explicitly casts to sub type.;
	CCineMonster@ opCast();
	//Explicitly casts to sub type.;
	CBaseMonster@ opCast();
	//The inventory rules.;
	InventoryRules@ get_m_pInventoryRules() const;
	//Returns whether this entity is locked by its master.\nSeparate from IsLockedByMaster due to limitations.;
	bool IsToggleLockedByMaster();
	//Performs angular movement.;
	void AngularMove(Vector vecDestAngle, float flSpeed);
	//Performs linear movement.;
	void LinearMove(Vector vecDest, float flSpeed);
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//Implicitly casts to base type.;
	CBaseAnimating@ opImplCast();
	//This entity\'s master, if any.;
	string_t m_sMaster;
	//DMG_ damage type that the door or trigger does.;
	int m_bitsDamageInflict;
	//Final angle.;
	Vector m_vecFinalAngle;
	//Final destination.;
	Vector m_vecFinalDest;
	//Open angle.;
	Vector m_vecAngle2;
	//Closed angle.;
	Vector m_vecAngle1;
	//Open position.;
	Vector m_vecPosition2;
	//Closed position.;
	Vector m_vecPosition1;
	//Handle to the activator.;
	EHandle m_hActivator;
	//Height.;
	float m_flHeight;
	//Trigger_counter only: # of activations remaining.;
	int m_cTriggersLeft;
	//For plats.;
	float m_flTLength;
	//For plats.;
	float m_flTWidth;
	//How much to stick out of a wall. Will recede further into walls if negative.;
	float m_flLip;
	//How long to wait before resetting.;
	float m_flWait;
	//How far a door should slide or rotate.;
	float m_flMoveDistance;
	//Current toggle state.;
	TOGGLE_STATE m_toggle_state;
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//All entities that can animate derive from this;
class CBaseAnimating {
	//Explicitly casts to sub type.;
	CBaseDoor@ opCast();
	//Explicitly casts to sub type.;
	CBaseButton@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayerWeapon@ opCast();
	//Explicitly casts to sub type.;
	CGrenade@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayer@ opCast();
	//Explicitly casts to sub type.;
	CCineMonster@ opCast();
	//Explicitly casts to sub type.;
	CBaseMonster@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayerItem@ opCast();
	//Explicitly casts to sub type.;
	CBaseToggle@ opCast();
	//Gets activity for the given sequence.;
	int GetSequenceActivityName(int iSequence);
	//Sets the sequence box.;
	void SetSequenceBox();
	//Gets the number of attachments that the current model has.;
	int GetAttachmentCount();
	//Extracts the bounding box of the current model.;
	bool ExtractBbox(int iSequence, Vector& out mins, Vector& out maxs);
	//Gets the value of the given body group.;
	int GetBodygroup(int iGroup);
	//Sets the given body group to the given value.;
	void SetBodygroup(int iGroup, int iValue);
	//Gets the attachment position.;
	void GetAttachment(int iAttachment, Vector& out origin, Vector& out angles);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence);
	//Find the transition between 2 sequences.;
	int FindTransition(int iEndingSequence, int iGoalSequence, int& out iDir);
	//Gets automatic movement.;
	void GetAutomovement(Vector& out origin, Vector& out angles, float flInterval = 0.1f);
	//Gets the position of the given bone.;
	void GetBonePosition(int iBone, Vector& out origin, Vector& out angles);
	//Sets the given blending controller to the given value.;
	float SetBlending(int iBlender, float flValue);
	//Initializes bone controllers.;
	void InitBoneControllers();
	//Sets the specified bone controller to the given value.;
	float SetBoneController(int iController, float flValue);
	//Handle events that have happend since last time called up until X seconds into the future.;
	void DispatchAnimEvents(float flFutureInterval = 0.1f);
	//Resets gait sequence info.;
	void ResetGaitSequenceInfo();
	//Resets sequence info.;
	void ResetSequenceInfo();
	//Returns the index of the given sequence, or -1 if no such sequence exists.;
	int LookupSequence(const string& in szLabel);
	//Returns the index of the given activity that has the heaviest weight, or -1 if no such activity exists.;
	int LookupActivityHeaviest(int iActivity);
	//Returns the index of the given activity, or -1 if no such activity exists.;
	int LookupActivity(int iActivity);
	//Get sequence flags.;
	int GetSequenceFlags();
	//Accumulate animation frame time from last time called until now.;
	float StudioFrameAdvance(float flInterval = 0.0f);
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//Implicitly casts to base type.;
	CBaseDelay@ opImplCast();
	//True if the sequence loops.;
	bool m_fSequenceLoops;
	//Flag set when StudioAdvanceFrame moves across a frame boundry.;
	bool m_fSequenceFinished;
	//Last time the event list was checked.;
	float m_flLastGaitEventCheck;
	//Last time the event list was checked.;
	float m_flLastEventCheck;
	//Computed linear movement rate for current sequence.;
	float m_flGroundSpeed;
	//Computed FPS for current sequence.;
	float m_flFrameRate;
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//All entities that can trigger with a delay derive from this;
class CBaseDelay {
	//Explicitly casts to sub type.;
	CBaseDoor@ opCast();
	//Explicitly casts to sub type.;
	CBaseButton@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayerWeapon@ opCast();
	//Explicitly casts to sub type.;
	CGrenade@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayer@ opCast();
	//Explicitly casts to sub type.;
	CCineMonster@ opCast();
	//Explicitly casts to sub type.;
	CBaseMonster@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayerItem@ opCast();
	//Explicitly casts to sub type.;
	CBaseToggle@ opCast();
	//Explicitly casts to sub type.;
	CBaseAnimating@ opCast();
	//Think function. Used internally.;
	void DelayThink();
	//Causes this entity to trigger its targets with an optional delay.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Implicitly casts to base type.;
	CBaseEntity@ opImplCast();
	//The name of the kill target, if any.;
	string_t m_iszKillTarget;
	//Delay before fire.;
	float m_flDelay;
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//All entities derive from this;
class CBaseEntity {
	//Explicitly casts to sub type.;
	CGib@ opCast();
	//Explicitly casts to sub type.;
	CBaseDoor@ opCast();
	//Explicitly casts to sub type.;
	CBaseButton@ opCast();
	//Explicitly casts to sub type.;
	CItem@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayerAmmo@ opCast();
	//Explicitly casts to sub type.;
	CBaseTank@ opCast();
	//Explicitly casts to sub type.;
	CLaser@ opCast();
	//Explicitly casts to sub type.;
	CBeam@ opCast();
	//Explicitly casts to sub type.;
	CPathTrack@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayerWeapon@ opCast();
	//Explicitly casts to sub type.;
	CSprite@ opCast();
	//Explicitly casts to sub type.;
	CGrenade@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayer@ opCast();
	//Explicitly casts to sub type.;
	CCineMonster@ opCast();
	//Explicitly casts to sub type.;
	CBaseMonster@ opCast();
	//Explicitly casts to sub type.;
	CBasePlayerItem@ opCast();
	//Explicitly casts to sub type.;
	CBaseToggle@ opCast();
	//Explicitly casts to sub type.;
	CBaseAnimating@ opCast();
	//Explicitly casts to sub type.;
	CBaseDelay@ opCast();
	//Clears the user data on this entity. WARNING: clears all data.\nOnly map scripts can use this.;
	void ClearUserData();
	//Gets the user data stored under the specified key on this entity.\nDo not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionaryValue& GetUserData(const string& in szKey);
	//Gets the user data on this entity. Do not keep references to this data, the object might be removed from this entity.\nOnly map scripts can use this.;
	dictionary@ GetUserData();
	//Called when this entity should be revived. flTimeUntilRevive is the time until the revival should start.;
	void EndRevive(float flTimeUntilRevive);
	//Prepares this entity for revival. flTimeUntilRevive is the time until the revive action completes.;
	void BeginRevive(float flTimeUntilRevive);
	//Returns whether this entity is revivable at this time.;
	bool IsRevivable();
	//Entity destructor.;
	void OnDestroy();
	//Entity constructor.;
	void OnCreate();
	//Adds damage points to the inflicting entity.;
	void GetDamagePoints(entvars_t@ pevAttacker, entvars_t@ pevInflictor, float flDamage);
	//Returns the points received for damage done.;
	float GetPointsForDamage(float flDamage);
	//Returns whether this entity is facing the given entity, within the given view field.;
	bool IsFacing(entvars_t@ pevTest, float flDotProduct = VIEW_FIELD_ULTRA_NARROW);
	//Returns whether this entity is visible from the given origin.;
	bool FVisible(const Vector& in vecOrigin);
	//Returns whether this entity is visible to the given entity.;
	bool FVisible(CBaseEntity@ pEntity, bool fIgnoreGlass);
	//Returns this entity\'s illumination.;
	int Illumination();
	//Returns this entity\'s body target for shooting.;
	Vector BodyTarget(const Vector& in posSrc);
	//Returns this entity\'s ear position.;
	Vector EarPosition();
	//Returns this entity\'s eye position.;
	Vector EyePosition();
	//Returns this entity\'s center.;
	Vector Center();
	//Makes this entity become prone.;
	bool FBecomeProne(CBaseEntity@ pOther);
	//Respawns this entity.;
	CBaseEntity@ Respawn();
	//Updates this entity when removed.;
	void UpdateOnRemove();
	//Triggers this entity\'s blocked function.;
	void Blocked(CBaseEntity@ pOther);
	//Trigger\'s this entity\'s use function.;
	void Use(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f);
	//Triggers this entity\'s touch function.;
	void Touch(CBaseEntity@ pOther);
	//Makes this entity think. Do not call directly.;
	void Think();
	//Gets the next target to trigger.;
	CBaseEntity@ GetNextTarget();
	//Removes this entity in critical situations.;
	bool CriticalRemove();
	//Returns whether this is a machine.;
	bool IsMachine();
	//Returns whether this is a breakable brush entity.;
	bool IsBreakable();
	//Returns whether this is a point entity.;
	bool IsPointEnt();
	//Returns whether this is a net client.;
	bool IsNetClient();
	//Returns whether this entity is a player.;
	bool IsPlayer();
	//Returns whether this entity is a monster.;
	bool IsMonster();
	//Returns whether this entity is in the world.;
	bool IsInWorld();
	//Returns whether this entity reflects gauss shots.;
	bool ReflectGauss();
	//Returns whether this entity is a BSP model.;
	bool IsBSPModel();
	//Returns whether this entity is alive.;
	bool IsAlive();
	//Returns whether this entity is sneaking.;
	bool IsSneaking();
	//Reacts to controls set on the pev.;
	bool OnControls(entvars_t@ pev);
	//Stops sneaking.;
	void StopSneaking();
	//Starts sneaking.;
	void StartSneaking();
	//Sets this entity\'s toggle state.;
	void SetToggleState(int state);
	//Returns the damage decal\nSee decal_e.;
	int DamageDecal(int bitsDamageType);
	//Resets this entity.;
	void OverrideReset();
	//Returns whether this entity is moving.;
	bool IsMoving();
	//Gets this entity\'s trigger delay.;
	float GetDelay();
	//Removes the given player item to this entity.;
	bool RemovePlayerItem(CBasePlayerItem@ pItem);
	//Adds the given player item to this entity.;
	AddPlayerItemResult AddPlayerItem(CBasePlayerItem@ pItem);
	//Adds points to this entity\'s team.;
	void AddPointsToTeam(int score, const bool bAllowNegativeScore);
	//Adds points to this entity.;
	void AddPoints(int score, const bool bAllowNegativeScore);
	//Gets the toggle state.\nSee the TOGGLE_STATE enum.;
	int GetToggleState();
	//Sets up the model.;
	bool SetupModel();
	//Returns this entity\'s index.;
	int entindex();
	//Returns this entity\'s edict.;
	edict_t@ edict();
	//Returns whether this entity is locked by its master.;
	bool IsLockedByMaster();
	//Returns whether this entity is dormant.;
	bool IsDormant();
	//Makes this entity dormant.;
	void MakeDormant();
	//Returns whether this entity intersects with the given entity.;
	bool Intersects(CBaseEntity@ pOther);
	//Calls use on targets.;
	void SUB_UseTargets(CBaseEntity@ pActivator, USE_TYPE useType, float flValue);
	//Fires bullets. Must call CMath::MakeAimVectors with an angle vector first.;
	void FireBullets(uint cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread,float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t@ pevAttacker = null, FireBulletsDrawMode fDraw = FireBulletsDrawMode::FBDM_DRAW);
	//Returns whether this entity should toggle.;
	bool ShouldToggle(USE_TYPE useType, const bool currentState);
	//Think function. Calls use toggle on this entity.;
	void SUB_CallUseToggle();
	//Think function. Fades this entity.;
	void SUB_FadeOut();
	//Think function. Starts fading this entity.;
	void SUB_StartFadeOut();
	//Think function. Explicitly does nothing.;
	void SUB_DoNothing();
	//Think function. Delay-removes this entity.;
	void SUB_Remove();
	//Returns true if you should be blocked by the entity, false otherwise. Also deals blocking damage to the entity, if applicable.;
	bool BlockedByEntity(CBaseEntity@ pOther, float flDamage);
	//Gets this entity\'s custom keyvalues.;
	CustomKeyvalues@ GetCustomKeyvalues();
	//Returns this entity as its monster entity, if it is a monster.;
	CBaseMonster@ MyMonsterPointer();
	//Returns whether this entity is triggered by the given entity.;
	bool IsTriggered(CBaseEntity@ pActivator);
	//Returns the blood color. See the BLOOD_COLOR enum.;
	int BloodColor();
	//Tells this entity it\'s been killed. See the GIB enum for possible values.;
	void Killed(entvars_t@pevAtttacker, int iGibbed);
	//Takes armor from this entity. Note: flArmor is added to entity armor. Use negative values to subtract.If armor_cap is non-zero, won\'t add more than armor_cap. Returns 1 if it took damage, 0 otherwise.;
	bool TakeArmor(float flArmor, int bitsDamageType, int armor_cap = 0);
	//Takes health from this entity. Note: flHealth is added to entity health. Use negative values to subtract.If health_cap is non-zero, won\'t add more than health_cap. Returns true if it took damage, false otherwise.;
	bool TakeHealth(float flHealth, int bitsDamageType, int health_cap = 0);
	//Causes this entity to take damage. Returns 1 if it took damage, 0 otherwise.;
	int TakeDamage(entvars_t@ pevInflictor, entvars_t@ pevAttacker, float flDamage, int bitsDamageType);
	//Gets this entity\'s classification.;
	int Classify();
	//Gets the relationship between this entity and the given entity classification. See the RELATIONSHIP enum.;
	int IRelationshipByClass(CLASS iClass);
	//Gets the relationship between this entity and the given entity. See the RELATIONSHIP enum.;
	int IRelationship(CBaseEntity@ other, bool ignoreNoTarget = false);
	//Clears this entity\'s classification override.;
	void ClearClassification();
	//Sets this entity\'s classification override to the classification override set on the given entity. Can override the entity\'s player ally setting.;
	void SetClassificationFromEntity(CBaseEntity@ pEntity);
	//Sets this entity\'s classification override. Can override the entity\'s player ally setting.;
	void SetClassification(int cl);
	//Gets this entity\'s classification. Returns the given value if none is set. See the CLASSIFICATION enum.;
	int GetClassification(int cl);
	//Sets up the object collision box.;
	void SetObjectCollisionBox();
	//Gets this entity\'s objects caps. See the FCAP enum.;
	int ObjectCaps();
	//Precaches the entity. Do not call directly.;
	void Precache();
	//Compares 2 entities for equality.;
	bool opEquals(CBaseEntity@ pOther);
	//Sets this entity\'s player ally status.\nUse this only if you need the setting to be exactly what you give it (e.g. when copying from another monster);
	void SetPlayerAllyDirect(bool fState);
	//Sets this entity\'s player ally status.;
	void SetPlayerAlly(bool fState);
	//Returns whether this entity is allied to players.;
	bool IsPlayerAlly() const;
	//Finds monsters in the world;
	int FindMonstersInWorld(array<CBaseEntity@>@ pArray, int flagMask);
	//Find sound replacement for the given file.;
	string SOUNDREPLACEMENT_Find(const string& in szFilename);
	//Returns whether this entity is visible from the given position.;
	bool FVisibleFromPos(const Vector& in vecTarget, const Vector& in vecStart);
	//Returns this entity\'s target name.;
	string GetTargetname() const;
	//Returns this entity\'s classification name.;
	string GetClassificationName() const;
	//Returns this entity\'s classification tag.;
	string GetClassificationTag() const;
	//Returns this entity\'s class name.;
	string GetClassname() const;
	//Returns this entity\'s team ID.;
	string TeamID();
	//Returns whether this entity has the given target.;
	bool HasTarget(const string& in szTarget);
	//Gives ammo to this entity.;
	int GiveAmmo(int iAmount, const string& in szName, int iMax, const bool fFromWeapon = true);
	//Traces entity bleed event.;
	void TraceBleed(float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Traces an attack by the given entity to this entity.;
	void TraceAttack(entvars_t@ pevAttacker, float flDamage, const Vector& in vecDir, TraceResult& in traceResult, int bitsDamageType);
	//Sets keyvalue data on this entity;
	bool KeyValue(const string& in szKeyName, const string& in szValue);
	//Sets this entity\'s (absolute) origin;
	void SetOrigin(const Vector& in vecOrigin);
	//Gets the entity\'s (absolute) origin.;
	const Vector& GetOrigin() const;
	//Explicitly casts to sub type.;
	CItemInventory@ opCast();
	//Original render color.;
	Vector m_vecOriginalRenderColor;
	//Original render amount.;
	float m_flOriginalRenderAmount;
	//Original render FX.;
	int m_iOriginalRenderFX;
	//Original render model.;
	int m_iOriginalRenderMode;
	//Class name in filter type.;
	string_t classnameInFilterType;
	//Target name in filter type.;
	string_t targetnameInFilterType;
	//Class name out filter type.;
	string_t classnameOutFilterType;
	//Target name out filter type.;
	string_t targetnameOutFilterType;
	//Last origin vector;
	Vector m_vecLastOrigin;
	//Whether a custom model is used.;
	bool m_fCustomModel;
	//Whether fading can start.;
	bool m_fCanFadeStart;
	//Maximum fade wait time B.;
	float m_flMaximumFadeWaitB;
	//Maximum fade wait time.;
	float m_flMaximumFadeWait;
	//The overridden classification.;
	int m_iClassSelection;
	//Whether this entity overrides the classification.;
	bool m_fOverrideClass;
	//Entity variables;
	entvars_t@ pev;
}
//Dynamic decal manager;
class CDecals {
	//Gets the texture frame index of the given decal.;
	string GetIndex(decal_e decal) const;
	//Gets the name of the texture representing the given decal.;
	string GetName(decal_e decal) const;
}
//Networked entity variables;
class entvars_t {
	//Entity containing entity. pContainingEntity.vars equals this entvars instance.;
	edict_t@ get_pContainingEntity() const;
	//Returns whether the given flag(s) are set on the entvars flags variable;
	bool FlagBitSet(int iFlags);
	//Returns whether the given flag(s) are set on the entvars spawnflags variable;
	bool SpawnFlagBitSet(int iFlags);
	//Set entity blending by index (0..1, 0..255). Used by entities with models to set x or y axis blending.;
	void set_blending(uint, int8);
	//Get entity blending by index (0..1). Used by entities with models to get x or y axis blending.;
	int8 get_blending(uint);
	//Set entity controller by index (0..3, 0..255) Used by entities with studio models to set bone controller settings.;
	void set_controller(uint, int8);
	//Get entity controller by index (0..3). Used by entities with studio models to get bone controller settings.;
	int8 get_controller(uint);
	//Returns whether the given class name is this entity\'s class name;
	bool ClassNameIs(const string& in szClassName);
	//User variable 4 (Edict);
	edict_t@ euser4;
	//User variable 3 (Edict);
	edict_t@ euser3;
	//User variable 2 (Edict);
	edict_t@ euser2;
	//User variable 1 (Edict);
	edict_t@ euser1;
	//User variable 4 (Vector);
	Vector vuser4;
	//User variable 3 (Vector);
	Vector vuser3;
	//User variable 2 (Vector);
	Vector vuser2;
	//User variable 1 (Vector);
	Vector vuser1;
	//User variable 4 (float);
	float fuser4;
	//User variable 3 (float);
	float fuser3;
	//User variable 2 (float);
	float fuser2;
	//User variable 1 (float);
	float fuser1;
	//User variable 4 (integer);
	int iuser4;
	//User variable 3 (integer);
	int iuser3;
	//User variable 2 (integer);
	int iuser2;
	//User variable 1 (integer);
	int iuser1;
	//Entity group info. Used for internal operations.;
	int groupinfo;
	//Player old buttons. Previous frame\'s contents of buttons.;
	int oldbuttons;
	//Entity gamestate. Reserved for future use.;
	int gamestate;
	//Player fall velocity.;
	float flFallVelocity;
	//Entity step left flag. Used for internal operations.;
	int iStepLeft;
	//Entity duck time. Used for internal operations.;
	int flDuckTime;
	//Entity swim time. Used for internal operations.;
	int flSwimTime;
	//Entity time of step sound. Used for internal operations.;
	int flTimeStepSound;
	//Entity ducking flag. Used for internal operations.;
	int bInDuck;
	//Entity push milliseconds. Used for internal operations.;
	int pushmsec;
	//Player weapon animation;
	int weaponanim;
	//Player field of view;
	float fov;
	//Entity maximum speed;
	float maxspeed;
	//Entity player class. Reserved for future use.;
	int playerclass;
	//Entity radiation suit finished. Reserved for future use.;
	float radsuit_finished;
	//Player pain finished. Time at which the player can take damage again while drowning.;
	float pain_finished;
	//Player air finished. Time at which the player runs out of air when underwater.;
	float air_finished;
	//Entity speed;
	float speed;
	//Entity noise 3. Usually used to store a sound name.;
	string_t noise3;
	//Entity noise 2. Usually used to store a sound name.;
	string_t noise2;
	//Entity noise 1. Usually used to store a sound name.;
	string_t noise1;
	//Entity noise. Usually used to store a sound name.;
	string_t noise;
	//Entity damage time. Time at which this entity last took damage. Usually used to limit damage effects from being shown too often.;
	float dmgtime;
	//Entity damage. Usually stores how much damage this entity can do to other entities.;
	float dmg;
	//Entity damage save. Used for internal operations.;
	float dmg_save;
	//Entity damage take. Used for internal operations.;
	float dmg_take;
	//The entity message. Used for various things.;
	string_t message;
	//The entity net name. Used for various things, such as the player\'s name.;
	string_t netname;
	//The entity target name;
	string_t targetname;
	//The entity target. If set, is the name of one or more targets to trigger. Otherwise, is empty.;
	string_t target;
	//Player only. Contains the type of water contents the player is currently in. See CONTENTS enum.;
	int watertype;
	//Entity water level\nSee WATERLEVEL enum.;
	int waterlevel;
	//Entity armor value;
	float armorvalue;
	//Entity armor type. Represents maximum armor (similar to max_health).;
	float armortype;
	//Entity teleport time. Intended for internal operations.;
	float teleport_time;
	//Entity maximum health;
	float max_health;
	//Entity team. Reserved for future use.;
	int team;
	//Entity color map. Used for player model colors.;
	int colormap;
	//Entity flags\nSee EdictFlags enum.;
	int flags;
	//Entity spawn flags;
	int spawnflags;
	//Entity ground entity;
	edict_t@ groundentity;
	//Entity owner;
	edict_t@ owner;
	//Entity pointer when MOVETYPE_FOLLOW;
	edict_t@ aiment;
	//Entity enemy;
	edict_t@ enemy;
	//Entity damage inflictor;
	edict_t@ dmg_inflictor;
	//Entity pointer when linked into a linked list. Used for temporary lists.;
	edict_t@ chain;
	//Entity impulse bit vector. Used for various internal operations.;
	int impulse;
	//Entity button bit vector. Usually used to track which buttons the player is currently pressing.;
	int button;
	//Entity view offset. Used to set an eye offset.;
	Vector view_ofs;
	//Entity dead flag\nSee DEAD enum.;
	int deadflag;
	//Entity take damage flag\nSee DAMAGE enum.;
	float takedamage;
	//Entity weapons bit vector. Largely used by monsters to track which weapons they have, and by players for internal purposes.;
	int weapons;
	//Entity frags. Usually used for the number of kills or score.;
	float frags;
	//Entity health. Do not set directly unless you are absolutely sure you know what you are doing.;
	float health;
	//Entity render fx;
	int renderfx;
	//Entity render color (rgb);
	Vector rendercolor;
	//Entity render amount (0..255);
	float renderamt;
	//Entity render mode. See RenderModes enum.;
	int rendermode;
	//Entity rendering scale (0..255). Applies to studio and sprite models.;
	float scale;
	//Entity framerate. used by entities with studio models to control sequence frame rate.;
	float framerate;
	//Entity animation time. Used for internal operations.;
	float animtime;
	//Entity frame. Used by entities with studio models to set the current frame that a sequence is using. Automatically incremented.Used by brush models for animated textures: 1 for animated, 0 for off.;
	float frame;
	//Entity gait sequence. Used by entities with studio models for walking sequences.;
	int gaitsequence;
	//Entity sequence. Used by entities with studio models to set which sequence to use.;
	int sequence;
	//Player only light level. This is a single value between 0 and 255 inclusive. Use g_EngineFuncs.GetEntityIllum to retrieve this value.;
	int light_level;
	//Entity friction. Is a scalar between 0 and 1, inclusive.;
	float friction;
	//Entity gravity. Is a scalar between 0 and 1, inclusive.;
	float gravity;
	//Entity effects\nSee EFFECTS enum.;
	int effects;
	//Entity body index. Used by entities with studio models to set which body to use.;
	int body;
	//Entity skin index. Used by entities with studio models to set which skin to use.;
	int skin;
	//Entity solid flag\nSee SOLID enum.;
	int solid;
	//Entity movetype\nSee MOVETYPE enum.;
	int movetype;
	//Entity next think time. The next time this entity will execute its think function, as an absolute time value. Otherwise, is 0.;
	float nextthink;
	//Entity ltime. The last time this entity has executed its think function. Otherwise, is 0.;
	float ltime;
	//Entity size. Equivalent to maxs - mins;
	Vector size;
	//Entity maximum size. Relative to the player\'s origin.;
	Vector maxs;
	//Entity minimum size. Relative to the player\'s origin.;
	Vector mins;
	//Entity absolute maximum size. Is an absolute position in the world. Automatically updated by the engine.;
	Vector absmax;
	//Entity absolute minimum size. Is an absolute position in the world. Automatically updated by the engine.;
	Vector absmin;
	//Entity weapon model index. If this player has a visible weapon, is the name of that third person (p_) model. Otherwise, is an empty string.;
	string_t weaponmodel;
	//Player view model index. If this player has a visible weapon, is the name of that view (v_) model. Otherwise, is an empty string.;
	string_t viewmodel;
	//The entity model name. If this entity has a model, is the name of that model. Otherwise, is an empty string.Use g_EntityFuncs.SetModel to set this variable.;
	string_t model;
	//Entity model index. If this entity has a model, is the unique index of the model. Otherwise, is 0.;
	const int modelindex;
	//Entity yaw speed. See ideal_yaw.;
	float yaw_speed;
	//Entity ideal yaw. Used in conjunction with yaw_speed to interpolate the entity\'s current yaw angle to this value.;
	float ideal_yaw;
	//Entity pitch speed. See idealpitch.;
	float pitch_speed;
	//Entity ideal pitch. Used in conjunction with pitch_speed to interpolate the entity\'s current pitch angle to this value.;
	float idealpitch;
	//Entity fix angle. Engine uses this value to change player view angles, and then resets it to FAM_NOTHING. See FixAngleMode enum.;
	int fixangle;
	//Entity start time. Reserved for future use.;
	float starttime;
	//Entity impact time. Reserved for future use.;
	float impacttime;
	//Entity start position. Reserved for future use.;
	Vector startpos;
	//Entity end position. Reserved for future use.;
	Vector endpos;
	//Player view angle. These are the angles used for the player\'s view, and differ from the regular angles variable.;
	Vector v_angle;
	//Player punch angle. These angles are applied to players when they are \'punched\'.These angles are automatically interpolated back to the null vector over time.;
	Vector punchangle;
	//Entity angular velocity, in degrees/sec. Applied to the entity\'s angles.;
	Vector avelocity;
	//Entity angles, in degrees.;
	Vector angles;
	//Entity move direction. Used by some entities for movement directions, but some entities use it for other purposes.;
	Vector movedir;
	//Entity base velocity. Used when standing on another entity that applies velocity to entities standing on it, for instance conveyors.;
	Vector basevelocity;
	//Entity velocity;
	Vector velocity;
	//Old entity origin. Used by some entities to store off their original origin before moving to a different location.;
	Vector oldorigin;
	//Entity origin. Must be set using g_EntityFuncs.SetOrigin.;
	Vector origin;
	//The entity global name;
	string_t globalname;
	//The entity class name;
	const string_t classname;
}
//Entity dictionary structure;
class edict_t {
	//get leafnums;
	int16 get_leafnums(uint);
	//Entity variables instance;
	entvars_t vars;
	//When this edict was last freed;
	const float freetime;
	//Number of leafs;
	const int num_leafs;
	//Head node;
	const int headnode;
	//Serial number;
	const int serialnumber;
	//Flag telling whether this edict is free;
	const int free;
}
//Math functions;
class CMath {
	//Compares the given floating point variables and returns whether they are equal, considering certain variance (epsilon) between them.;
	bool Compare(double flLhs, double flRhs, double flEpsilon) const;
	//Compares the given floating point variables and returns whether they are equal, considering certain variance (epsilon) between them.;
	bool Compare(float flLhs, float flRhs, float flEpsilon) const;
	//Returns the given value in radians as degrees;
	float RadiansToDegrees(float flRadians) const;
	//Returns the given value in degrees as radians;
	float DegreesToRadians(float flDegrees) const;
	//Returns the float value, rounded up to the nearest whole number;
	float Ceil(float flValue) const;
	//Returns the float value, rounded down to the nearest whole number;
	float Floor(float flValue) const;
	//Clamps a value between a range;
	float clamp(float min, float max, float value) const;
	//Clamps a value between a range;
	int clamp(int min, int max, int value) const;
	//Returns the larger of the two values;
	float max(float lhs, float rhs) const;
	//Returns the larger of the two values;
	int64 max(int64 lhs, int64 rhs) const;
	//Returns the larger of the two values;
	uint64 max(uint64 lhs, uint64 rhs) const;
	//Returns the smaller of the two values;
	float min(float lhs, float rhs) const;
	//Returns the smaller of the two values;
	int64 min(int64 lhs, int64 rhs) const;
	//Returns the smaller of the two values;
	uint64 min(uint64 lhs, uint64 rhs) const;
	//Returns the distance between 2 angles;
	float AngleDistance(float flNext, float flCur);
	//Given a target and current angle value, and a rotation speed, all in degrees, returns a new angle that is either between value and target, or target, depending on whether the speed is high enough to reach that angle.;
	float ApproachAngle(float target, float value, float speed);
	//Returns the difference between 2 angles;
	float AngleDiff(float flDestAngle, float flSrcAngle);
	//Clamps the given angle between 0 and 360;
	float AngleMod(float flAngle);
	//Transforms a vector to an angle;
	Vector VecToAngles(const Vector& in vec);
	//Transforms a vector to a yaw value;
	float VecToYaw(const Vector& in vec);
	//Make inverted vectors;
	void MakeInvVectors(const Vector& in vecAngles);
	//Make aim vectors;
	void MakeAimVectors(const Vector& in vecAngles);
	//Rotate vector;
	Vector RotateVector(Vector& in vecToRotate,const Vector& in vecAngles, const Vector& in vecOffset);
	//Makes vectors;
	void MakeVectors(const Vector& in vecAngles);
	//Returns a random float between low and high;
	float RandomFloat(float low, float high);
	//Returns a random integer between low and high;
	int32 RandomLong(int32 low, int32 high);
	//PI;
	const double PI;
	//Double maximum positive value;
	const double DOUBLE_MAX;
	//Float maximum positive value;
	const float FLOAT_MAX;
	//Double minimum positive value;
	const double DOUBLE_MIN;
	//Float minimum positive value;
	const float FLOAT_MIN;
	//Size_t maximum value;
	const size_t SIZE_MAX;
	//Uint64 maximum value;
	const uint64 UINT64_MAX;
	//Uint32 maximum value;
	const uint32 UINT32_MAX;
	//Uint16 maximum value;
	const uint16 UINT16_MAX;
	//Uint8 maximum value;
	const uint8 UINT8_MAX;
	//Int64 maximum value;
	const int64 INT64_MAX;
	//Int32 maximum value;
	const int32 INT32_MAX;
	//Int16 maximum value;
	const int16 INT16_MAX;
	//Int8 maximum value;
	const int8 INT8_MAX;
	//Int64 minimum value;
	const int64 INT64_MIN;
	//Int32 minimum value;
	const int32 INT32_MIN;
	//Int16 minimum value;
	const int16 INT16_MIN;
	//Int8 minimum value;
	const int8 INT8_MIN;
}
//3D Vector;
class Vector {
	//Returns a string representation of this vector;
	string ToString() const;
	//Returns the 2D form of this vector;
	Vector2D Make2D() const;
	//Returns the normalized form of this vector;
	Vector Normalize() const;
	//Gets the length of this vector in 2D;
	float Length2D() const;
	//Gets the length of this vector;
	float Length() const;
	//Divide vectors;
	Vector opDiv(const Vector& in other) const;
	//Multiply vectors;
	Vector opMul(const Vector& in other) const;
	//Compare vectors;
	bool opEquals(const Vector& in other) const;
	//Index operator;
	float opIndex(size_t uiIndex) const;
	//Index operator;
	float& opIndex(size_t uiIndex);
	//Divide vector by value;
	Vector opDiv_r(float fl) const;
	//Divide vector by value;
	Vector opDiv(float fl) const;
	//Multiply vector by value;
	Vector opMul_r(float fl) const;
	//Multiply vector by value;
	Vector opMul(float fl) const;
	//Subtract vectors;
	Vector opSub(const Vector& in other) const;
	//Add vectors;
	Vector opAdd(const Vector& in other) const;
	//Negate vector;
	Vector opNeg() const;
	//Assign vector;
	Vector& opAssign(const Vector& in other);
	//Constructs a 3D vector from 3 floats;
	void Vector(float x, float y, float z);
	//Copy constructs a 3D vector;
	void Vector(const Vector& in vec);
	//Default constructs a 3D vector (0, 0, 0);
	void Vector();
	//Vector z variable;
	float z;
	//Vector y variable;
	float y;
	//Vector x variable;
	float x;
}
//2D Vector;
class Vector2D {
	//Returns a string representation of this vector;
	string ToString() const;
	//Returns the normalized form of this vector;
	Vector2D Normalize() const;
	//Gets the length of this vector;
	float Length() const;
	//Compare vectors;
	bool opEquals(const Vector2D& in other) const;
	//Divide vector by a value;
	Vector2D opDiv_r(float fl) const;
	//Divide vector by a value;
	Vector2D opDiv(float fl) const;
	//Multiply vector by a value;
	Vector2D opMul_r(float fl) const;
	//Multiply vector by a value;
	Vector2D opMul(float fl) const;
	//Subtract vectors;
	Vector2D opSub(const Vector2D& in other) const;
	//Add vectors;
	Vector2D opAdd(const Vector2D& in other) const;
	//Assign vector;
	Vector2D& opAssign(const Vector2D& in other);
	//Constructs a 2D vector from 2 floats;
	void Vector2D(float x, float y);
	//Copy constructs a 2D vector;
	void Vector2D(const Vector2D& in other);
	//Default constructs a 2D vector (0, 0);
	void Vector2D();
	//Vector2D y variable;
	float y;
	//Vector2D x variable;
	float x;
}
//Debugger;
class CDebugger {
	//Output statistics.;
	void OutputStatistics();
	//Output member variables.;
	void OutputMembers();
	//Output global variables.;
	void OutputGlobals();
	//Output local variables.;
	void OutputLocals();
	//Gets the current stack level.;
	uint32 GetCurrentStackLevel() const;
}
//Scheduler for calling functions.\nSupports up to 8 parameters for function or method calls.;
class CScheduler {
	//Removes all queued functions from the list of functions to call.;
	void ClearTimerList();
	//Returns the function currently being executed, if any.;
	CScheduledFunction@ GetCurrentFunction() const;
	//Removes the given function from the list of functions to call.;
	void RemoveTimer(CScheduledFunction@ pFunction);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime, int iRepeatCount);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount, ?& in);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime, int iRepeatCount);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nThe given function is called an infinite number of times.\nCalls object methods.;
	CScheduledFunction@ SetInterval(?& in thisObject, const string& in szFunction, float flRepeatTime);
	//Adds a timer that calls the given function every flRepeatTime seconds,\nfor iRepeatCount times (or infinite times if REPEAT_INFINITE_TIMES).\nThe given function is called an infinite number of times.;
	CScheduledFunction@ SetInterval(const string& in szFunction, float flRepeatTime);
	//Adds a timer that calls the given function after flDelay seconds. Calls object methods.;
	CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds. Calls object methods.;
	CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds. Calls object methods.;
	CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds. Calls object methods.;
	CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds. Calls object methods.;
	CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds. Calls object methods.;
	CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds. Calls object methods.;
	CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds. Calls object methods.;
	CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay, ?& in);
	//Adds a timer that calls the given function after flDelay seconds. Calls object methods.;
	CScheduledFunction@ SetTimeout(?& in thisObject, const string& in szFunction, float flDelay);
	//Adds a timer that calls the given function after flDelay seconds.;
	CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds.;
	CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds.;
	CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds.;
	CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds.;
	CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds.;
	CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds.;
	CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in, ?& in);
	//Adds a timer that calls the given function after flDelay seconds.;
	CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay, ?& in);
	//Adds a timer that calls the given function after flDelay seconds.;
	CScheduledFunction@ SetTimeout(const string& in szFunction, float flDelay);
	//If passed to AddTimer, causes the given function to be called infinite times;
	const int REPEAT_INFINITE_TIMES;
}
//Handle to a scheduled function;
class CScheduledFunction {
	//Returns whether this function has been removed from the scheduler or not;
	bool HasBeenRemoved() const;
	//Makes this an infinite repeat function;
	void MakeInfiniteRepeat();
	//Sets the repeat count. Must be a positive value (may be zero) or REPEAT_INFINITE_TIMES;
	void SetRepeatCount(const int iRepeatCount);
	//Returns whether this function repeats infinitely;
	bool IsInfiniteRepeat() const;
	//Gets the repeat count;
	int GetRepeatCount() const;
	//Sets the repeat time, in seconds. Must be a positive value (may be zero);
	void SetRepeatTime(const float flRepeatTime);
	//Gets the repeat time, in seconds;
	float GetRepeatTime() const;
	//Sets the next call time, in seconds. Is an absolute value (g_Engine.time + RepeatTime by default).Times in the past will result in a call on the next frame.;
	void SetNextCallTime(const float flNextCallTime);
	//Gets the next call time, in seconds;
	float GetNextCallTime() const;
}
//Virtual File System;
class CVirtualFileSystem {
	//Removes a file.;
	void RemoveFile(const string& in szFilename);
	//Opens a file. Returns nullptr if the file could not be opened.;
	File@ OpenFile(const string& in szFilename, const OpenFileFlags_t uiOpenFlags);
	//Gets the file system quota object. Do not store a handle to this object, as it may be replaced at any time.;
	const FileQuota@ GetFileQuota() const;
}
//Represents a quota that filesystems adhere to when handling write operations.;
class FileQuota {
	//Returns the size that is left after the given amount of bytes have been written.;
	size_t SizeLeftAfterWrite(size_t uiSizeInBytes) const;
	//Returns whether the given amount of bytes can be written.;
	bool CanWriteAmount(size_t uiSizeInBytes) const;
	//Gets the amount of size, in bytes, left that can be written to.;
	size_t GetSizeLeft() const;
	//Gets the size, in bytes, that is in use.;
	size_t GetSizeInUse() const;
	//Gets the total size, in bytes, that is allowed to be used by filesystems using this quota object.;
	size_t GetTotalSize() const;
}
//File class.\nIs used to read from/write to files in disk.;
class File {
	//Writes a blob to the file.;
	void Write(const BLOB@ pBlob);
	//Writes a string to the file.;
	void Write(const string& in szString);
	//Reads as much as possible data into a BLOB.;
	BLOB@ ReadBlob();
	//Reads a number of bytes into a BLOB.;
	BLOB@ ReadBlob(size_t uiSizeInBytes, bool fCanResize = true);
	//Reads as much as possible data into the given BLOB.;
	bool Read(BLOB@ pBlob);
	//Reads a number of bytes into the given BLOB.;
	bool Read(BLOB@ pBlob, size_t uiSizeInBytes);
	//Reads a line from the file.;
	void ReadLine(string& out szOutLine, const string& in szDelim = '\n');
	//Reads a single character.;
	string ReadCharacter();
	//Returns whether end of file was reached.;
	bool EOFReached() const;
	//Sets the read/write pointer to a new position. Returns the new position within the file.;
	size_t Seek(const size_t uiPosition, const SeekFileFlags_t uiSeekMode);
	//Tells the position of the read/write pointer.;
	size_t Tell() const;
	//Returns the size of the file.;
	size_t GetSize() const;
	//Removes the file. The file must be open, and you must have write access.;
	void Remove();
	//Closes the file if it is open.;
	void Close();
	//Returns whether the file was successfully opened.;
	bool IsOpen() const;
}
//Binary Large OBject class used for storing arbitrary amounts of binary data.;
class BLOB {
	//Clears this BLOB of all data and allocated memory. All flags are reset to their default values.;
	void Clear();
	//Shrinks this BLOB to fit the data that was written to it.;
	void ShrinkToFit();
	//Reserves the given amount of space, if needed.;
	void Reserve(size_t uiMinimumSize);
	//Resizes this BLOB. Data may be lost because of this.;
	void Resize(size_t uiNewSize);
	//Writes a variable length string to this BLOB. Returns true if the write succeeded.;
	bool Write(const string& in szString);
	//Writes a fixed length string to this BLOB. Returns true if the write succeeded.;
	bool Write(const string& in szString, size_t uiSizeInBytes);
	//Writes a double to this BLOB. Returns true if the write succeeded.;
	bool Write(double data);
	//Writes a float to this BLOB. Returns true if the write succeeded.;
	bool Write(float data);
	//Writes a uint64 to this BLOB. Returns true if the write succeeded.;
	bool Write(uint64 data);
	//Writes a uint32 to this BLOB. Returns true if the write succeeded.;
	bool Write(uint32 data);
	//Writes a uint16 to this BLOB. Returns true if the write succeeded.;
	bool Write(uint16 data);
	//Writes a uint8 to this BLOB. Returns true if the write succeeded.;
	bool Write(uint8 data);
	//Writes an int64 to this BLOB. Returns true if the write succeeded.;
	bool Write(int64 data);
	//Writes an int32 to this BLOB. Returns true if the write succeeded.;
	bool Write(int32 data);
	//Writes an int16 to this BLOB. Returns true if the write succeeded.;
	bool Write(int16 data);
	//Writes an int8 to this BLOB. Returns true if the write succeeded.;
	bool Write(int8 data);
	//Writes a given value until the given end offset to this BLOB. Returns true if the write succeeded.;
	bool WriteBytesUntil(size_t uiEndOffset, int iValue = 0);
	//Writes a given value a number of bytes to this BLOB. Returns true if the write succeeded.;
	bool WriteBytes(size_t uiSizeInBytes, int iValue = 0);
	//Reads a variable length string from this BLOB.;
	string ReadString();
	//Reads a variable length string from this BLOB. fSuccess is true if the read succeeded.;
	string ReadString(bool& out fSuccess);
	//Reads a fixed length string from this BLOB. fSuccess is true if the read succeeded.;
	string ReadString(size_t uiSizeInBytes, bool& out fSuccess);
	//Reads a fixed length string from this BLOB.;
	string ReadString(size_t uiSizeInBytes);
	//Reads a double from this BLOB. fSuccess is true if the read succeeded.;
	double ReadDouble(bool& out fSuccess);
	//Reads a float from this BLOB. fSuccess is true if the read succeeded.;
	float ReadFloat(bool& out fSuccess);
	//Reads a uint64 from this BLOB. fSuccess is true if the read succeeded.;
	int64 ReadUInt64(bool& out fSuccess);
	//Reads a uint32 from this BLOB. fSuccess is true if the read succeeded.;
	int32 ReadUInt32(bool& out fSuccess);
	//Reads a uint16 from this BLOB. fSuccess is true if the read succeeded.;
	int16 ReadUInt16(bool& out fSuccess);
	//Reads a uint8 from this BLOB. fSuccess is true if the read succeeded.;
	uint8 ReadUInt8(bool& out fSuccess);
	//Reads an int64 from this BLOB. fSuccess is true if the read succeeded.;
	int64 ReadInt64(bool& out fSuccess);
	//Reads an int32 from this BLOB. fSuccess is true if the read succeeded.;
	int32 ReadInt32(bool& out fSuccess);
	//Reads an int16 from this BLOB. fSuccess is true if the read succeeded.;
	int16 ReadInt16(bool& out fSuccess);
	//Reads an int8 from this BLOB. fSuccess is true if the read succeeded.;
	int8 ReadInt8(bool& out fSuccess);
	//Reads a double from this BLOB.;
	double ReadDouble();
	//Reads a float from this BLOB.;
	float ReadFloat();
	//Reads a uint64 from this BLOB.;
	int64 ReadUInt64();
	//Reads a uint32 from this BLOB.;
	int32 ReadUInt32();
	//Reads a uint16 from this BLOB.;
	int16 ReadUInt16();
	//Reads a uint8 from this BLOB.;
	uint8 ReadUInt8();
	//Reads an int64 from this BLOB.;
	int64 ReadInt64();
	//Reads an int32 from this BLOB.;
	int32 ReadInt32();
	//Reads an int16 from this BLOB.;
	int16 ReadInt16();
	//Reads an int8 from this BLOB.;
	int8 ReadInt8();
	//Sets whether this BLOB is allowed to resize its buffer.;
	void SetCanResize(bool fState);
	//Returns whether this BLOB is allowed to resize its buffer.;
	bool CanResize() const;
	//Gets the number of bytes left that can be written to. This may change if a write operation causes the buffer to be resized.;
	size_t GetWriteBytesLeft() const;
	//Returns whether the given amount of bytes can be written to this BLOB.;
	bool CanWriteSize(size_t uiSizeInBytes) const;
	//Gets the write offset, in bytes. This is the number of bytes written to this buffer.;
	size_t GetWriteOffset() const;
	//Returns whether the given amount of bytes can be read from this BLOB.;
	bool ReadSizeValid(size_t uiSizeInBytes) const;
	//Returns whether the last read operation reached the end of data that was written to this BLOB.;
	bool ReadReachedEnd() const;
	//Gets the read offset, in bytes.;
	size_t GetReadOffset() const;
	//Gets the size of this BLOB, in bytes.;
	size_t GetSizeInBytes() const;
	//Returns whether this instance has allocated a buffer.;
	bool HasAllocatedBuffer() const;
}
namespace Regex {
//Regular expression match results;
class MatchResults {
	//Swaps these match results with the given results.;
	void Swap(MatchResults@ other);
	//Gets the length of the given submatch;
	string Format(const string& in szFormat, MatchFlagType flags = MatchFlagType::match_default) const;
	//Gets the given submatch as a string;
	string GetString(size_t uiIndex = 0) const;
	//Gets the position of the given submatch;
	int GetPosition(size_t uiIndex = 0) const;
	//Gets the length of the given submatch;
	int GetLength(size_t uiIndex = 0) const;
	//Gets the suffix submatch;
	SubMatch GetSuffix() const;
	//Gets the prefix submatch;
	SubMatch GetPrefix() const;
	//Returns the sub match object at the given index;
	SubMatch opIndex(size_t uiIndex) const;
	//Returns the maximum size;
	size_t GetMaxSize() const;
	//Returns the number of matches;
	size_t GetSize() const;
	//Returns whether this match results object is empty or not;
	bool IsEmpty() const;
	//Copy constructor;
	MatchResults@ MatchResults(const MatchResults@ pOther);
	//Constructor;
	MatchResults@ MatchResults();
}
}
namespace Regex {
//Regular expression submatch;
class SubMatch {
	//Compares this submatch to a string;
	int Compare(const string& in szString) const;
	//Compares this submatch to another;
	int Compare(const SubMatch& in other) const;
	//Gets this submatch as a string;
	string GetString() const;
	//Gets the length of the submatch;
	int GetLength() const;
	//Copy constructor;
	void SubMatch(const SubMatch& in other);
	//Constructor. Do not use.;
	void SubMatch();
}
}
namespace Regex {
//Represents a regular expression;
class Regex {
	//Swaps this regular expression\'s contents with the given expression;
	void Swap(Regex@ other);
	//Gets this regex\'s flags;
	FlagType GetFlags() const;
	//Gets the mark count;
	uint GetMarkCount() const;
	//Assigns the given regular expression to this one.;
	Regex& Assign(const string& in szExpression, FlagType flags = FlagType::ECMAScript);
	//Assigns the given regular expression to this one.;
	Regex& Assign(const Regex@ pOther);
	//Initialization Constructor;
	Regex@ Regex(const string& in szExpression, FlagType flags = FlagType::ECMAScript);
	//Copy Constructor;
	Regex@ Regex(const Regex@ pOther);
	//Default Constructor;
	Regex@ Regex();
}
}
namespace Reflection {
//Reflection global used for generial purpose needs.;
class CReflection {
	//Module group;
	IReflectionGroup Module;
	//Engine group;
	IReflectionGroup Engine;
}
}
namespace Reflection {
//Reflection group. Represents a group of reflectable objects.;
class IReflectionGroup {
	//Gets the object type at the given index.;
	ObjectType@ GetObjectTypeByIndex(uint uiIndex) const;
	//Gets the number of object types.;
	uint GetObjectTypeCount() const;
	//Finds an object type. Searches by name by default, searches by declaration if fSearchByDecl is set to true.;
	ObjectType@ FindObjectType(const string& in szName, bool fSearchByDecl = false);
	//Gets the global function at the given index.;
	Function@ GetGlobalFunctionByIndex(uint uiIndex);
	//Gets the number of global functions.;
	uint GetGlobalFunctionCount() const;
	//Finds a global function. Searches by name by default, searches by declaration if fSearchByDecl is set to true.;
	Function@ FindGlobalFunction(const string& in szName, bool fSearchByDecl = false);
}
}
namespace Reflection {
//Represents an object type;
class ObjectType {
	//Returns whether this object derives from the given type.;
	bool DerivesFrom(const ObjectType@ pObjectType) const;
	//Returns whether this object derives from the given type.;
	bool DerivesFrom(const string& in szName) const;
	//Returns whether the given object type is compatible with this one.;
	bool IsCompatible(const ObjectType@ pObjectType) const;
	//Returns whether the given object type is identical to this one.;
	bool Equals(const ObjectType@ pObjectType) const;
	//Gets a method by declaration.;
	bool MethodExists(const string& in szFunctionSignature);
	//Gets a method by declaration.;
	Method@ GetMethod(const string& in szFunctionSignature);
	//Gets the method at the given index.;
	Method@ GetMethodByIndex(uint uiIndex) const;
	//Gets the number of methods this object type has.;
	uint GetMethodCount() const;
}
}
namespace Reflection {
//Reflection method class. Can be used to call object methods.;
class Method {
	//Calls this method.;
	ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Calls this method.;
	ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Calls this method.;
	ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Calls this method.;
	ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Calls this method.;
	ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in, ?& in);
	//Calls this method.;
	ReturnValue@ Call(?& in thisObject, ?& in, ?& in, ?& in);
	//Calls this method.;
	ReturnValue@ Call(?& in thisObject, ?& in, ?& in);
	//Calls this method.;
	ReturnValue@ Call(?& in thisObject, ?& in);
	//Calls this method.;
	ReturnValue@ Call(?& in thisObject);
	//Calls this method. pArguments must be valid.;
	ReturnValue@ Call(?& in thisObject, Arguments@ pArguments);
	//Returns whether the given object type is compatible with this one.;
	bool IsCompatible(const Callable@ pCallable) const;
	//Returns whether the given callable type is identical to this one.;
	bool Equals(const Callable@ pCallable) const;
	//Gets this instance\'s name.;
	string GetName() const;
	//Gets this instance\'s namespace.;
	string GetNamespace() const;
	//Implicitly casts to base type.;
	Callable@ opImplCast();
}
}
namespace Reflection {
//Reflection function class. Can be used to call global functions.;
class Function {
	//Calls this function.;
	ReturnValue@ Call(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Calls this function.;
	ReturnValue@ Call(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Calls this function.;
	ReturnValue@ Call(?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Calls this function.;
	ReturnValue@ Call(?& in, ?& in, ?& in, ?& in, ?& in);
	//Calls this function.;
	ReturnValue@ Call(?& in, ?& in, ?& in, ?& in);
	//Calls this function.;
	ReturnValue@ Call(?& in, ?& in, ?& in);
	//Calls this function.;
	ReturnValue@ Call(?& in, ?& in);
	//Calls this function.;
	ReturnValue@ Call(?& in);
	//Calls this function.;
	ReturnValue@ Call();
	//Calls this function. pArguments must be valid.;
	ReturnValue@ Call(Arguments@ pArguments);
	//Returns whether the given object type is compatible with this one.;
	bool IsCompatible(const Callable@ pCallable) const;
	//Returns whether the given callable type is identical to this one.;
	bool Equals(const Callable@ pCallable) const;
	//Gets this instance\'s name.;
	string GetName() const;
	//Gets this instance\'s namespace.;
	string GetNamespace() const;
	//Implicitly casts to base type.;
	Callable@ opImplCast();
}
}
namespace Reflection {
//Reflection base class for callable objects.;
class Callable {
	//Explicitly casts to sub type.;
	Method@ opCast();
	//Explicitly casts to sub type.;
	Function@ opCast();
	//Returns whether the given object type is compatible with this one.;
	bool IsCompatible(const Callable@ pCallable) const;
	//Returns whether the given callable type is identical to this one.;
	bool Equals(const Callable@ pCallable) const;
	//Gets this instance\'s name.;
	string GetName() const;
	//Gets this instance\'s namespace.;
	string GetNamespace() const;
}
}
namespace Reflection {
//Reflection return value.;
class ReturnValue {
	//Returns the return value as an any instance, if there was a return value.;
	any@ ToAny() const;
	//Returns whether there is a return value or not.;
	bool HasReturnValue() const;
}
}
namespace Reflection {
//This class can hold arguments for a function or method call.;
class Arguments {
	//Sets the arguments this instance contains.;
	bool SetArguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Sets the arguments this instance contains.;
	bool SetArguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Sets the arguments this instance contains.;
	bool SetArguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Sets the arguments this instance contains.;
	bool SetArguments(?& in, ?& in, ?& in, ?& in, ?& in);
	//Sets the arguments this instance contains.;
	bool SetArguments(?& in, ?& in, ?& in, ?& in);
	//Sets the arguments this instance contains.;
	bool SetArguments(?& in, ?& in, ?& in);
	//Sets the arguments this instance contains.;
	bool SetArguments(?& in, ?& in);
	//Sets the arguments this instance contains.;
	bool SetArguments(?& in);
	//Sets the arguments this instance contains.;
	bool SetArguments();
	//Clears this instance\'s data.;
	void Clear();
	//Returns whether this instance holds any arguments.;
	bool HasArguments() const;
	//Gets number of arguments.;
	size_t GetCount() const;
	//Assignment operator;
	Arguments& opAssign(const Arguments& in other);
	//Constructs a Arguments instance with the given arguments.;
	Arguments@ Arguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Constructs a Arguments instance with the given arguments.;
	Arguments@ Arguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Constructs a Arguments instance with the given arguments.;
	Arguments@ Arguments(?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
	//Constructs a Arguments instance with the given arguments.;
	Arguments@ Arguments(?& in, ?& in, ?& in, ?& in, ?& in);
	//Constructs a Arguments instance with the given arguments.;
	Arguments@ Arguments(?& in, ?& in, ?& in, ?& in);
	//Constructs a Arguments instance with the given arguments.;
	Arguments@ Arguments(?& in, ?& in, ?& in);
	//Constructs a Arguments instance with the given arguments.;
	Arguments@ Arguments(?& in, ?& in);
	//Constructs a Arguments instance with the given arguments.;
	Arguments@ Arguments(?& in);
	//Constructs a Arguments instance with the given arguments.;
	Arguments@ Arguments();
	//Copy constructor;
	Arguments@ Arguments(const Arguments& in other);
	//Default constructor;
	Arguments@ Arguments();
}
}
//Opaque handle to a pooled string.;
class string_t {
	//Converts this string_t to an integer.;
	int opImplConv() const;
	//Converts this string_t to a string.;
	string opImplConv() const;
	//Assignment operator;
	string_t& opAssign(int str);
	//Assignment operator;
	string_t& opAssign(const string& in str);
	//Assignment operator;
	string_t& opAssign(const string_t& in str);
	//Construct a string_t from an integer;
	void string_t(int str);
	//Construct a string_t from a string;
	void string_t(const string& in str);
	//Copy Constructor;
	void string_t(const string_t& in str);
	//Default Constructor;
	void string_t();
}
//Char value type;
class char {
	//Compares this char with the given character.;
	bool opEquals(const string& in szString) const;
	//Assigns the first character of the given string to this character.;
	char opAssign(const string& in szString);
	//Implicitly converts this character to an unsigned 32 bit integer.;
	uint32 opImplConv() const;
	//Assigns one character to another.;
	char opAssign(const char& in character);
	//Copy constructor;
	void char(const string& in szString);
	//Copy constructor;
	void char(const char& in character);
	//Default constructor;
	void char();
}
//String type;
class string {
	//Splits this string by the given delimiter.;
	array<string>@ Split(const string& in szDelimiter) const;
	//Returns a copy of this string with the given character appended.;
	string opAdd(char character) const;
	//Returns a copy of this string with the given boolean appended.;
	string opAdd(bool bValue) const;
	//Returns a copy of this string with the given 64 bit unsigned integer appended.;
	string opAdd(uint64 uiValue) const;
	//Returns a copy of this string with the given 64 bit integer appended.;
	string opAdd(int64 iValue) const;
	//Returns a copy of this string with the given double appended.;
	string opAdd(double flValue) const;
	//Returns a copy of this string with the given string appended.;
	string opAdd(const string& in szString) const;
	//Truncates the string to uiMaxLength characters.;
	void Truncate(const size_t uiMaxLength);
	//Replaces the given substring with the given replacement string.;
	string& Replace(const string& in szSubstring, const string& in szReplacement, const String::CompareType compareType = String::DEFAULT_COMPARE);
	//Returns a substring of this string.;
	string SubString(uint startIndex = 0, uint count = String::INVALID_INDEX) const;
	//Converts this string to upper case.;
	string& ToUppercase();
	//Converts this string to lower case.;
	string& ToLowercase();
	//Get the next token of the given string.\nReturns String::NO_MORE_TOKENS if none remaining.;
	string Tokenize(const string& in delimiter) const;
	//Find the first instance of the given string, searching in reverse.\nReturns String::INVALID_INDEX if not found.;
	uint FindLastNotOf(const string& in szString, uint startIndex = String::INVALID_INDEX, const String::CompareType compareType = String::DEFAULT_COMPARE) const;
	//Find the first instance of the given string.\nReturns String::INVALID_INDEX if not found.;
	uint FindFirstNotOf(const string& in szString, uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const;
	//Find the last instance of any character in the given string.\nReturns String::INVALID_INDEX if not found.;
	uint FindLastOf(const string& in szString, const uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const;
	//Find the first instance of any character in the given string.\nReturns String::INVALID_INDEX if not found.;
	uint FindFirstOf(const string& in szString, const uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const;
	//Find the first instance of the given string, searching in reverse.\nReturns String::INVALID_INDEX if not found.;
	uint RFind(const string& in szString, uint startIndex = String::INVALID_INDEX, const String::CompareType compareType = String::DEFAULT_COMPARE) const;
	//Find the first instance of the given string.\nReturns String::INVALID_INDEX if not found.;
	uint Find(const string& in szString, const uint startIndex = 0, const String::CompareType compareType = String::DEFAULT_COMPARE) const;
	//Returns true if the string ends with the given string.;
	bool EndsWith(const string& in szString, const String::CompareType compareType = String::DEFAULT_COMPARE) const;
	//Returns true if the string starts with the given string.;
	bool StartsWith(const string& in szString, const String::CompareType compareType = String::DEFAULT_COMPARE) const;
	//Trims leading and trailing whitespace, or a given character.;
	void Trim(const string& in szCharacter = ' ');
	//Returns whether strings are equal.;
	bool opEquals(const string& in szString) const;
	//Compares strings up to amount characters case-insensitively.;
	int ICompareN(const string& in szString, const uint amount) const;
	//Compares strings case-insensitively.;
	int ICompare(const string& in szString) const;
	//Compares strings up to amount characters.;
	int CompareN(const string& in szString, const uint amount) const;
	//Compares strings.;
	int Compare(const string& in szString) const;
	//Compares strings.;
	int opCmp(const string& in szString) const;
	//Appends the given character to this string.;
	string& opAddAssign(char character);
	//Appends the given boolean to this string.;
	string& opAddAssign(bool bValue);
	//Appends the given 64 bit unsigned integer to this string.;
	string& opAddAssign(uint64 uiValue);
	//Appends the given 64 bit integer to this string.;
	string& opAddAssign(int64 iValue);
	//Appends the given double to this string.;
	string& opAddAssign(double flValue);
	//Appends the given string to this one.;
	string& opAddAssign(const string& in szString);
	//Sets a character by index.;
	void SetCharAt(uint uiIndex, char character);
	//Gets a character by index.;
	char opIndex(uint uiIndex) const;
	//Clears the contents of this string.;
	void Clear();
	//Reserves at least iMinimum characters worth of capacity. If bKeepData is true, the original string is kept.;
	void Reserve(uint iMinimum, bool bKeepData = true);
	//Shrinks this string to uiSize. If bKeepData is true, the original string is kept.;
	void Resize(uint uiSize, bool bKeepData = true);
	//Returns whether this string is empty.;
	bool IsEmpty() const;
	//Gets the length of this string.;
	uint Length() const;
	//Assigns a character to this string.;
	string& opAssign(char character);
	//Assigns a boolean to this string.;
	string& opAssign(bool bValue);
	//Assigns a 64 bit unsigned int to this string.;
	string& opAssign(uint64 uiValue);
	//Assigns a 64 bit integer to this string.;
	string& opAssign(int64 iValue);
	//Assigns a double to this string.;
	string& opAssign(double flValue);
	//Assigns a string to this one.;
	string& opAssign(const string& in szString);
	//Assigns a string to this, copying up to uiCount characters.;
	string& Assign(const string& in szString, uint uiBegin, uint uiCount);
	//Construct a string from a char.;
	void string(char character);
	//Construct a string from a boolean.;
	void string(bool bValue);
	//Construct a string from a 64 bit unsigned integer.;
	void string(uint64 uiValue);
	//Construct a string from a 64 bit integer.;
	void string(int64 iValue);
	//Construct a string from a double.;
	void string(double flValue);
	//Copy constructor;
	void string(const string& in szString);
	//Constructor;
	void string();
}
//Hook function return codes.;
enum HookReturnCode {
	//Returned when a hook function has handled the call;
	HOOK_HANDLED = 1,
	//Returned when a hook function has not handled the call;
	HOOK_CONTINUE = 0 
}
//Type of say the client used;
enum ClientSayType {
	//Say team;
	CLIENTSAY_SAYTEAM = 1,
	//Say;
	CLIENTSAY_SAY = 0 
}
namespace ConCommandFlag {
//Console command flags;
enum ConCommandFlag {
	//If set, the invoking player (if any) must have cheat access.;
	Cheat = 2,
	//If set, the invoking player (if any) must have admin access.;
	AdminOnly = 1,
	//No flags to set;
	None = 0 
}
}
namespace ConCommandKind {
//Console command kind.;
enum Type {
	//This console command is a cvar;
	CVar = 3,
	//This console command is a client command;
	ClientCommand = 2,
	//This console command is a command;
	ConCommand = 1 
}
}
namespace NetworkMessages {
//Network message types;
enum NetworkMessageType {
	//User message;
	VModelPos = 145,
	//User message;
	UpdateTime = 144,
	//User message;
	TimeDisplay = 143,
	//User message;
	UpdateNum = 142,
	//User message;
	NumDisplay = 141,
	//User message;
	CustSpr = 140,
	//User message;
	ToggleElem = 139,
	//User message;
	WeaponSpr = 138,
	//User message;
	ClassicMode = 137,
	//User message;
	Flamethwr = 136,
	//User message;
	ViewMode = 135,
	//User message;
	Concuss = 134,
	//User message;
	InvRemove = 133,
	//User message;
	InvAdd = 132,
	//User message;
	PrintKB = 131,
	//User message;
	ASScriptName = 130,
	//User message;
	PrtlUpdt = 129,
	//User message;
	Fog = 128,
	//User message;
	CameraMouse = 127,
	//User message;
	WeatherFX = 126,
	//User message;
	ServerBuild = 125,
	//User message;
	ServerVer = 124,
	//User message;
	TeamNames = 123,
	//User message;
	ServerName = 122,
	//User message;
	VGUIMenu = 121,
	//User message;
	Playlist = 120,
	//User message;
	ShieldRic = 119,
	//User message;
	RampSprite = 118,
	//User message;
	SRPrimedOff = 117,
	//User message;
	SRPrimed = 116,
	//User message;
	SRDetonate = 115,
	//User message;
	TracerDecal = 114,
	//User message;
	SporeTrail = 113,
	//User message;
	GargSplash = 112,
	//User message;
	CreateBlood = 111,
	//User message;
	ShkFlash = 110,
	//User message;
	ToxicCloud = 109,
	//User message;
	SoundList = 108,
	//User message;
	StartSound = 107,
	//User message;
	NextMap = 106,
	//User message;
	VoteMenu = 105,
	//User message;
	EndVote = 104,
	//User message;
	CbElec = 103,
	//User message;
	MapList = 102,
	//User message;
	TimeEnd = 101,
	//User message;
	Speaksent = 100,
	//User message;
	TE_CUSTOM = 99,
	//User message;
	Spectator = 98,
	//User message;
	Gib = 97,
	//User message;
	AmmoX = 96,
	//User message;
	ScreenFade = 95,
	//User message;
	ScreenShake = 94,
	//User message;
	ShowMenu = 93,
	//User message;
	SetFOV = 92,
	//User message;
	HideHUD = 91,
	//User message;
	ItemPickup = 90,
	//User message;
	WeapPickup = 89,
	//User message;
	AmmoPickup = 88,
	//User message;
	MOTD = 87,
	//User message;
	GameMode = 86,
	//User message;
	TeamScore = 85,
	//User message;
	TeamInfo = 84,
	//User message;
	ScoreInfo = 83,
	//User message;
	DeathMsg = 82,
	//User message;
	GameTitle = 81,
	//User message;
	CdAudio = 80,
	//User message;
	InitHUD = 79,
	//User message;
	ResetHUD = 78,
	//User message;
	CustWeapon = 77,
	//User message;
	WeaponList = 76,
	//User message;
	TextMsg = 75,
	//User message;
	SayText = 74,
	//User message;
	HudText = 73,
	//User message;
	Train = 72,
	//User message;
	Battery = 71,
	//User message;
	Damage = 70,
	//User message;
	Health = 69,
	//User message;
	FlashBat = 68,
	//User message;
	Flashlight = 67,
	//User message;
	Geiger = 66,
	//User message;
	CurWeapon = 65,
	//User message;
	SelAmmo = 64,
	//Executes command on the client side.;
	SVC_STUFFTEXT = 9,
	//Enables intermission for clients.;
	SVC_INTERMISSION = 30,
	//Creates temporary entities on the client side.;
	SVC_TEMPENTITY = 23 
}
}
//Temporary entity types. Used in network messages of type SVC_TEMPENTITY.;
enum TempEntityType {
	//Larger message than the standard tracer, but allows some customization.;
	TE_USERTRACER = 127,
	//Much more compact shotgun message;
	TE_MULTIGUNSHOT = 126,
	//Will expire all TENTS attached to a player.;
	TE_KILLPLAYERATTACHMENTS = 125,
	//Attaches a TENT to a player (this is a high-priority tent);
	TE_PLAYERATTACHMENT = 124,
	//Makes a field of fire.;
	TE_FIREFIELD = 123,
	//Very similar to lavasplash.;
	TE_PARTICLEBURST = 122,
	//Sprites emit from a player\'s bounding box (ONLY use for players!);
	TE_PLAYERSPRITES = 121,
	//Throws a shower of sprites or models;
	TE_SPRAY = 120,
	//Makes a projectile (like a nail) (this is a high-priority tent);
	TE_PROJECTILE = 119,
	//Same as TE_DECAL, but the texture index was greater than 256;
	TE_DECALHIGH = 118,
	//Decal (with texture index > 256) applied to world brush;
	TE_WORLDDECALHIGH = 117,
	//Decal applied to the world brush;
	TE_WORLDDECAL = 116,
	//Spray of opaque sprite1\'s that fall, single sprite2 for 1..2 secs (this is a high-priority tent);
	TE_BLOODSPRITE = 115,
	//Create alpha sprites along a line, float upwards;
	TE_BUBBLETRAIL = 114,
	//Create alpha sprites inside of box, float upwards;
	TE_BUBBLES = 113,
	//Draw a player decal (spray paint);
	TE_PLAYERDECAL = 112,
	//Quick spark sprite, client ricochet sound. ;
	TE_ARMOR_RICOCHET = 111,
	//Spray of alpha sprites;
	TE_SPRITE_SPRAY = 110,
	//Decal and ricochet sound;
	TE_GUNSHOTDECAL = 109,
	//Box of models or sprites;
	TE_BREAKMODEL = 108,
	//Spherical shower of models, picks from sets;
	TE_EXPLODEMODEL = 107,
	//Create a moving model that bounces and makes a sound when it hits;
	TE_MODEL = 106,
	//Create alpha sprites inside of entity, float upwards;
	TE_FIZZ = 105,
	//Decal applied to a brush entity (not the world);
	TE_DECAL = 104,
	//Particle spray;
	TE_BLOOD = 103,
	//Line of particles every 5 units, dies in 30 seconds;
	TE_SHOWLINE = 102,
	//Particle spray;
	TE_BLOODSTREAM = 101,
	//Creates a large funnel;
	TE_LARGEFUNNEL = 100,
	//Kill all beams attached to entity;
	TE_KILLBEAM = 99,
	//Draws a box;
	TE_BOX = 31,
	//Draws a line;
	TE_LINE = 30,
	//Text message;
	TE_TEXTMESSAGE = 29,
	//Point entity light, no world effect;
	TE_ELIGHT = 28,
	//Dynamic light effect;
	TE_DLIGHT = 27,
	//Oriented shower of tracers;
	TE_STREAK_SPLASH = 25,
	//Connect a beam ring to two entities;
	TE_BEAMRING = 24,
	//Glowing sprite;
	TE_GLOWSPRITE = 23,
	//Create a line of decaying beam segments until entity stops moving;
	TE_BEAMFOLLOW = 22,
	//Cylinder that expands to max radius over lifetime;
	TE_BEAMCYLINDER = 21,
	//Disk that expands to max radius over lifetime;
	TE_BEAMDISK = 20,
	//Screen aligned beam ring, expands to max radius over lifetime;
	TE_BEAMTORUS = 19,
	//A beam with a sprite at the end;
	TE_BEAMSPRITE = 18,
	//Additive sprite, plays 1 cycle;
	TE_SPRITE = 17,
	//Line of moving glow sprites with gravity, fadeout, and collisions;
	TE_SPRITETRAIL = 15,
	//Tracers moving toward a point;
	TE_IMPLOSION = 14,
	//Decal from the .BSP file ;
	TE_BSPDECAL = 13,
	//Explosion effect;
	TE_EXPLOSION2 = 12,
	//Teleport effect;
	TE_TELEPORT = 11,
	//Lava splash effect;
	TE_LAVASPLASH = 10,
	//Spark effect;
	TE_SPARKS = 9,
	//Beam effect between two entities;
	TE_BEAMENTS = 8,
	//TE_BEAMPOINTS with simplified parameters;
	TE_LIGHTNING = 7,
	//Tracer effect from point to point;
	TE_TRACER = 6,
	//Alphablend sprite, move vertically 30 pps;
	TE_SMOKE = 5,
	//Quake1 tarbaby explosion with sound;
	TE_TAREXPLOSION = 4,
	//Additive sprite, 2 dynamic lights, flickering particles, explosion sound, move vertically 8 pps;
	TE_EXPLOSION = 3,
	//Particle effect plus ricochet sound;
	TE_GUNSHOT = 2,
	//Beam effect between point and entity;
	TE_BEAMENTPOINT = 1,
	//Beam effect between two points;
	TE_BEAMPOINTS = 0 
}
//TE_FIREFIELD flags;
enum TE_FireFieldFlag {
	//If set, sprite is rendered non-opaque with additive;
	TEFIRE_FLAG_ADDITIVE = 32,
	//If set, all fire sprites have same initial Z instead of randomly filling a cube. ;
	TEFIRE_FLAG_PLANAR = 16,
	//If set, sprite is rendered alpha blended at 50% else, opaque;
	TEFIRE_FLAG_ALPHA = 8,
	//If set, sprite plays at 15 fps, otherwise plays at whatever rate stretches the animation over the sprite\'s duration.;
	TEFIRE_FLAG_LOOP = 4,
	//Some of the sprites will drift upwards. (50% chance);
	TEFIRE_FLAG_SOMEFLOAT = 2,
	//All sprites will drift upwards as they animate;
	TEFIRE_FLAG_ALLFLOAT = 1 
}
//TE_EXPLOSION flags;
enum TE_ExplosionFlag {
	//Do not draw particles;
	TE_EXPLFLAG_NOPARTICLES = 8,
	//Do not play client explosion sound;
	TE_EXPLFLAG_NOSOUND = 4,
	//Do not render dynamic lights;
	TE_EXPLFLAG_NODLIGHTS = 2,
	//Sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite);
	TE_EXPLFLAG_NOADDITIVE = 1,
	//All flags clear makes default Half-Life explosion;
	TE_EXPLFLAG_NONE = 0 
}
//Network message destination types.;
enum NetworkMessageDest {
	//Sends to all spectator proxies;
	MSG_SPEC = 9,
	//Send to one client, but don\'t put in reliable stream, put in unreliable datagram ( could be dropped );
	MSG_ONE_UNRELIABLE = 8,
	//Reliable to PAS;
	MSG_PAS_R = 7,
	//Reliable to PVS;
	MSG_PVS_R = 6,
	//Ents in PAS of org;
	MSG_PAS = 5,
	//Ents in PVS of org;
	MSG_PVS = 4,
	//write to the init string;
	MSG_INIT = 3,
	//reliable to all;
	MSG_ALL = 2,
	//reliable to one (msg_entity);
	MSG_ONE = 1,
	//unreliable to all;
	MSG_BROADCAST = 0 
}
//Global state values;
enum GLOBALESTATE {
	//Global state when removed;
	GLOBAL_DEAD = 2,
	//Global state when on;
	GLOBAL_ON = 1,
	//Global state when off;
	GLOBAL_OFF = 0 
}
//Flags used by custom time displays.;
enum HUD_TIME {
	//Count down.;
	HUD_TIME_COUNT_DOWN = 8388608,
	//Freeze the displayed value.;
	HUD_TIME_FREEZE = 4194304,
	//Draw hours even if the value is zero.;
	HUD_TIME_ZERO_HOURS = 2097152,
	//Draw milliseconds.;
	HUD_TIME_MILLISECONDS = 1048576,
	//Draw seconds.;
	HUD_TIME_SECONDS = 524288,
	//Draw minutes.;
	HUD_TIME_MINUTES = 262144,
	//Draw hours.;
	HUD_TIME_HOURS = 131072,
	//Draw right aligned element.;
	HUD_TIME_RIGHT_ALIGN = 65536 
}
//Flags used by custom numeric displays.;
enum HUD_NUM {
	//Draw sign for positive values.;
	HUD_NUM_PLUS_SIGN = 2097152,
	//Allow negative values.;
	HUD_NUM_NEGATIVE_NUMBERS = 1048576,
	//Draw leading zeros.;
	HUD_NUM_LEADING_ZEROS = 524288,
	//Hide the element if the value is zero.;
	HUD_NUM_DONT_DRAW_ZERO = 262144,
	//Draw separator.;
	HUD_NUM_SEPARATOR = 131072,
	//Draw right aligned element.;
	HUD_NUM_RIGHT_ALIGN = 65536 
}
//Flags used by custom HUD sprites.;
enum HUD_SPR {
	//Hide the sprite when the animation stops.;
	HUD_SPR_HIDE_WHEN_STOPPED = 524288,
	//Play the animation only once.;
	HUD_SPR_PLAY_ONCE = 262144,
	//Draw masked sprite.;
	HUD_SPR_MASKED = 131072,
	//Draw opaque sprite.;
	HUD_SPR_OPAQUE = 65536 
}
//Common flags used by all custom HUD elements.;
enum HUD_ELEM {
	//Use the default client-side HUD alpha and flash the element when updated.;
	HUD_ELEM_DYNAMIC_ALPHA = 256,
	//Use the default client-side HUD alpha (hud_defaultalpha).;
	HUD_ELEM_DEFAULT_ALPHA = 128,
	//Play the effect only once.;
	HUD_ELEM_EFFECT_ONCE = 64,
	//Create a hidden element.;
	HUD_ELEM_HIDDEN = 32,
	//Ignore the client-side HUD border (hud_bordersize).;
	HUD_ELEM_NO_BORDER = 16,
	//Y position relative to the center of the screen.;
	HUD_ELEM_SCR_CENTER_Y = 8,
	//X position relative to the center of the screen.;
	HUD_ELEM_SCR_CENTER_X = 4,
	//Y position in pixels.;
	HUD_ELEM_ABSOLUTE_Y = 2,
	//X position in pixels.;
	HUD_ELEM_ABSOLUTE_X = 1 
}
//HUD element effects.;
enum HUD_EFFECT {
	//Sine pulse from color1 through zero to color2.;
	HUD_EFFECT_SINE_PULSE = 8,
	//Toggle between color1 and color2.;
	HUD_EFFECT_TOGGLE = 7,
	//Cosine ramp up and ramp down from color1 through color2 back to color1.;
	HUD_EFFECT_COSINE = 6,
	//Cosine ramp down from color2 to color1.;
	HUD_EFFECT_COSINE_DOWN = 5,
	//Cosine ramp up from color1 to color2.;
	HUD_EFFECT_COSINE_UP = 4,
	//Linear ramp up and ramp down from color1 through color2 back to color1.;
	HUD_EFFECT_TRIANGLE = 3,
	//Linear ramp down from color2 to color1.;
	HUD_EFFECT_RAMP_DOWN = 2,
	//Linear ramp up from color1 to color2.;
	HUD_EFFECT_RAMP_UP = 1,
	//No effect.;
	HUD_EFFECT_NONE = 0 
}
//Used to dictate where client print commands print the given text.;
enum HUD {
	//Print to center of screen;
	HUD_PRINTCENTER = 4,
	//Print to chat;
	HUD_PRINTTALK = 3,
	//Print to console;
	HUD_PRINTCONSOLE = 2,
	//Print notify;
	HUD_PRINTNOTIFY = 1 
}
//Fade flags for CPlayerFuncs::ScreenFade and ScreenFadeAll;
enum FFADE {
	//ignores the duration, stays faded out until new ScreenFade message received;
	FFADE_STAYOUT = 4,
	//Modulate (don\'t blend);
	FFADE_MODULATE = 2,
	//Fade out (not in);
	FFADE_OUT = 1,
	//Just here so we don\'t pass 0 into the function;
	FFADE_IN = 0 
}
//Admin levels;
enum AdminLevel_t {
	//Server owner (applies to a listenserver host player);
	ADMIN_OWNER = 2,
	//Server administrator;
	ADMIN_YES = 1,
	//Not an administrator;
	ADMIN_NO = 0,
	//Level on connect, tells functions not to use cached level;
	ADMIN_INIT = -1 
}
//Pitch values. Other values are possible. Range: 0 - 255, where 255 is very high.;
enum PITCH {
	//high pitch;
	PITCH_HIGH = 120,
	//low pitch;
	PITCH_LOW = 95,
	//non-pitch shifted;
	PITCH_NORM = 100 
}
//Audio channels;
enum SOUND_CHANNEL {
	//;
	CHAN_MUSIC = 7,
	//allocate channel from the static area;
	CHAN_STATIC = 6,
	//allocate stream channel from the static or dynamic area;
	CHAN_STREAM = 5,
	//;
	CHAN_BODY = 4,
	//;
	CHAN_ITEM = 3,
	//;
	CHAN_VOICE = 2,
	//;
	CHAN_WEAPON = 1,
	//Automatically selects a channel for use. You cannot stop sounds while using this channel with StopSound, or in conjunction with the SND_STOP flag.;
	CHAN_AUTO = 0 
}
//Sound flags;
enum SoundFlag {
	//Skip Origin and use entity flag;
	SND_SKIP_ORIGIN_USE_ENT = 8192,
	//Linear flag;
	SND_LINEAR = 4096,
	//Force loop flag;
	SND_FORCE_LOOP = 2048,
	//Force single flag;
	SND_FORCE_SINGLE = 1024,
	//Refresh flag;
	SND_REFRESH = 512,
	//Sentence flag;
	SND_SENTENCE = 256,
	//Change pitch flag;
	SND_CHANGE_PITCH = 128,
	//Change volume flag;
	SND_CHANGE_VOL = 64,
	//Stop flag;
	SND_STOP = 32,
	//Entity flag;
	SND_ENT = 16,
	//Origin flag;
	SND_ORIGIN = 8,
	//Attenuation flag;
	SND_ATTENUATION = 4,
	//Pitch flag;
	SND_PITCH = 2,
	//Volume flag;
	SND_VOLUME = 1 
}
//Alert type for console messages;
enum ALERT_TYPE {
	//Server print to console (only in multiplayer games);
	at_logged = 5,
	//Prints \'Error: <message>\';
	at_error = 4,
	//Prints \'Warning: <message>\';
	at_warning = 3,
	//Only shown if developer is 2 or larger;
	at_aiconsole = 2,
	//Outputs text to the console only if developer is larger than 0;
	at_console = 1,
	//Prints \'NOTICE: <message>\';
	at_notice = 0 
}
//Ignore glass options.\nFlag for certain trace functions.;
enum HULL_NUMBER {
	//Head hull.;
	head_hull = 3,
	//Large hull.;
	large_hull = 2,
	//Human sized hull.;
	human_hull = 1,
	//Point hull. No size.;
	point_hull = 0 
}
//Ignore glass options.\nFlag for certain trace functions.;
enum IGNORE_GLASS {
	//Don\'t ignore glass;
	dont_ignore_glass = 0,
	//Ignore glass;
	ignore_glass = 1 
}
//Ignore monsters options.\nFlag for certain trace functions.;
enum IGNORE_MONSTERS {
	//Object doing the trace is a missile;
	missile = 2,
	//Don\'t ignore monsters;
	dont_ignore_monsters = 0,
	//Ignore monsters;
	ignore_monsters = 1 
}
//func_tank spawn flags;
enum TankFlags {
	//If set, controlling player can\'t fire this tank.;
	SF_TANK_PLAYERCANTFIRE = 1024,
	//If set, uses the relationship specified when dealing with player targets. Otherwise, defaults to always attacking monsters.;
	SF_TANK_USERELATIONS = 512,
	//Whether this func_tank is controllable or not;
	SF_TANK_CANCONTROL = 32,
	//Whether to only attack if the tank has a direct line of sight of its target or continue firing.;
	SF_TANK_LINEOFSIGHT = 16,
	//Whether the tank is active or not;
	SF_TANK_ACTIVE = 1 
}
//func_tank bullet types;
enum TANKBULLET {
	//12 mm rounds;
	TANK_BULLET_12MM = 3,
	//MP5 rounds;
	TANK_BULLET_MP5 = 2,
	//9mm rounds;
	TANK_BULLET_9MM = 1,
	//No bullet. Nothing is fired when this is set;
	TANK_BULLET_NONE = 0 
}
//CBeam spawn flags;
enum CBeamSpawnflags {
	//Whether the beam is a temporary entity;
	SF_BEAM_TEMPORARY = 32768,
	//Whether to fade the beam out at its end point;
	SF_BEAM_SHADEOUT = 256,
	//Whether to fade the beam in at its start point;
	SF_BEAM_SHADEIN = 128,
	//Whether to create decals when the beam does damage to BSP models;
	SF_BEAM_DECALS = 64,
	//Whether to allow creation of sparks at the beam\'s end point;
	SF_BEAM_SPARKEND = 32,
	//Whether to allow creation of sparks at the beam\'s start point;
	SF_BEAM_SPARKSTART = 16,
	//Whether this beam is a ring between 2 points;
	SF_BEAM_RING = 8,
	//Whether beams are created to a randomly selected entity with the given target name;
	SF_BEAM_RANDOM = 4,
	//Whether the beam should be togglable by triggering it;
	SF_BEAM_TOGGLE = 2,
	//Whether the beam should start on;
	SF_BEAM_STARTON = 1 
}
//Beam flags used by CBeam::SetFlags;
enum BeamFlags {
	//Beam fades out at its end point;
	BEAM_FSHADEOUT = 128,
	//Beam fades in at its start point;
	BEAM_FSHADEIN = 64,
	//Beam is a solid shape;
	BEAM_FSOLID = 32,
	//Beam shape follows a sinus shape;
	BEAM_FSINE = 16 
}
//Beam types used by CBeam::SetType;
enum BeamType {
	//I don\'t even know what this does;
	BEAM_HOSE = 3,
	//Beam is a beam between entities;
	BEAM_ENTS = 2,
	//Beam is a beam between point and entity;
	BEAM_ENTPOINT = 1,
	//Beam is a beam between 2 points;
	BEAM_POINTS = 0 
}
//path_track spawnflags;
enum PathTrackSpawnFlags {
	//;
	SF_PATH_ALTERNATE = 32768,
	//;
	SF_PATH_DISABLE_TRAIN = 8,
	//;
	SF_PATH_ALTREVERSE = 4,
	//;
	SF_PATH_FIREONCE = 2,
	//;
	SF_PATH_DISABLED = 1 
}
//Weapon id values;
enum WeaponIds {
	//Maximum number of weapons that the game supports;
	MAX_WEAPONS = 256,
	//;
	WEAPON_DISPLACER = 29,
	//;
	WEAPON_SHOCKRIFLE = 28,
	//;
	WEAPON_DESERT_EAGLE = 27,
	//;
	WEAPON_SPORELAUNCHER = 26,
	//;
	WEAPON_M16 = 25,
	//;
	WEAPON_M249 = 24,
	//;
	WEAPON_SNIPERRIFLE = 23,
	//;
	WEAPON_GRAPPLE = 22,
	//;
	WEAPON_MINIGUN = 21,
	//;
	WEAPON_PIPEWRENCH = 20,
	//;
	WEAPON_CROWBAR_ELECTRIC = 19,
	//;
	WEAPON_MEDKIT = 18,
	//;
	WEAPON_UZI = 17,
	//;
	WEAPON_SNARK = 15,
	//;
	WEAPON_SATCHEL = 14,
	//;
	WEAPON_TRIPMINE = 13,
	//;
	WEAPON_HANDGRENADE = 12,
	//;
	WEAPON_HORNETGUN = 11,
	//;
	WEAPON_EGON = 10,
	//;
	WEAPON_GAUSS = 9,
	//;
	WEAPON_RPG = 8,
	//;
	WEAPON_SHOTGUN = 7,
	//;
	WEAPON_CROSSBOW = 6,
	//;
	WEAPON_CHAINGUN = 5,
	//;
	WEAPON_MP5 = 4,
	//;
	WEAPON_PYTHON = 3,
	//;
	WEAPON_GLOCK = 2,
	//;
	WEAPON_CROWBAR = 1,
	//Weapon id used for invalid weapon ids.;
	WEAPON_NONE = 0 
}
//Item flags used by ItemInfo::iFlags;
enum ItemFlag {
	//This weapon should not be dropped straight away when the player dies, only if he is gibbed or if he respawned.;
	ITEM_FLAG_ESSENTIAL = 128,
	//Ignore weaponstay settings when respawning this weapon.;
	ITEM_FLAG_IGNOREWEAPONSTAY = 64,
	//Use a special HUD ammo configuration unique to a dual wielded weapons.;
	ITEM_FLAG_DUALWIELD = 32,
	//A player can totally exhaust their ammo supply and lose this weapon.;
	ITEM_FLAG_EXHAUSTIBLE = 16,
	//If there are few entity slots left, this item will not respawn.;
	ITEM_FLAG_LIMITINWORLD = 8,
	//Don\'t automatically switch away from this weapon when it runs out of ammo.;
	ITEM_FLAG_NOAUTOSWITCHEMPTY = 4,
	//Don\'t automatically reload this weapon.;
	ITEM_FLAG_NOAUTORELOAD = 2,
	//Allow this weapon to be selected if it has no ammo.;
	ITEM_FLAG_SELECTONEMPTY = 1 
}
//Sound flags for monster schedules.;
enum bits_SOUND {
	//All sound flags;
	bits_ALL_SOUNDS = -1,
	//a bullet just hit at this location;
	bits_SOUND_BULLETHIT = 128,
	//trash cans, banana peels, old fast food bags.;
	bits_SOUND_GARBAGE = 64,
	//pending danger. Grenade that is about to explode, explosive barrel that is damaged, falling crate;
	bits_SOUND_DANGER = 32,
	//gib or pork chop;
	bits_SOUND_MEAT = 16,
	//dead body;
	bits_SOUND_CARCASS = 8,
	//all noises generated by player. walking, shooting, falling, splashing;
	bits_SOUND_PLAYER = 4,
	//door opening/closing, glass breaking;
	bits_SOUND_WORLD = 2,
	//gunshots, explosions;
	bits_SOUND_COMBAT = 1,
	//;
	bits_SOUND_NONE = 0 
}
//MoveToOrigin move type.;
enum MOVE_TYPE {
	//Moves in direction specified, no matter which way monster is facing.;
	MOVE_STRAFE = 1,
	//Normal move in the direction monster is facing.;
	MOVE_NORMAL = 0 
}
//Print type;
enum PRINT_TYPE {
	//Print to chat. Note: does not work. Use CPlayerFuncs::ClientPrint with HUD_PRINTTALK instead.;
	print_chat = 2,
	//Print to the center of the screen;
	print_center = 1,
	//Print to the console;
	print_console = 0 
}
//Console variable flags.;
enum FCVAR {
	//If this is a FCVAR_SERVER, don\'t log changes to the log file / console if we are creating a log;
	FCVAR_UNLOGGED = 256,
	//This cvar\'s string cannot contain unprintable characters (e.g. used for player name etc);
	FCVAR_PRINTABLEONLY = 128,
	//This cvar cannot be changed by clients connected to a multiplayer server.;
	FCVAR_SPONLY = 64,
	//It\'s a server cvar, but we don\'t send the data since it\'s a password, etc.;
	FCVAR_PROTECTED = 32,
	//Defined by the client dll.;
	FCVAR_CLIENTDLL = 16,
	//Defined by external dll.;
	FCVAR_EXTDLL = 8,
	//Notifies players when changed.;
	FCVAR_SERVER = 4,
	//Changes the client\'s info string.;
	FCVAR_USERINFO = 2,
	//Save this cvar.;
	FCVAR_ARCHIVE = 1 
}
//Contents of a spot in the world;
enum CONTENTS {
	//;
	CONTENTS_LADDER = -16,
	//;
	CONTENTS_SKY = -6,
	//;
	CONTENTS_LAVA = -5,
	//;
	CONTENTS_SLIME = -4,
	//;
	CONTENTS_WATER = -3,
	//;
	CONTENTS_SOLID = -2,
	//;
	CONTENTS_EMPTY = -1 
}
//Walk move types;
enum WALKMOVE {
	//move, but don\'t touch triggers;
	WALKMOVE_CHECKONLY = 2,
	//doesn\'t hit ANY entities, no matter what the solid type;
	WALKMOVE_WORLDONLY = 1,
	//normal walkmove;
	WALKMOVE_NORMAL = 0 
}
//Door flags.;
enum DoorFlag {
	//Don\'t make sure the doors are in-sync.;
	SF_DOOR_NO_LINK_CHECKING = 1024,
	//;
	SF_DOOR_SILENT = -2147483648,
	//Monster can\'t open;
	SF_DOOR_NOMONSTERS = 512,
	//door must be opened by player\'s use button.;
	SF_DOOR_USE_ONLY = 256,
	//;
	SF_DOOR_ROTATE_X = 128,
	//;
	SF_DOOR_ROTATE_Z = 64,
	//;
	SF_DOOR_NO_AUTO_RETURN = 32,
	//;
	SF_DOOR_ONEWAY = 16,
	//;
	SF_DOOR_PASSABLE = 8,
	//;
	SF_DOOR_ROTATE_BACKWARDS = 2,
	//;
	SF_DOOR_START_OPEN = 1,
	//;
	SF_DOOR_ROTATE_Y = 0 
}
//Button codes used by CBaseButton;
enum ButtonCode {
	//Return the button to its default state;
	BUTTON_RETURN = 2,
	//Activate the button;
	BUTTON_ACTIVATE = 1,
	//Do nothing;
	BUTTON_NOTHING = 0 
}
//Satchel codes;
enum SATCHELCODE {
	//Release all satches charges owner by a player from their owner;
	SATCHEL_RELEASE = 1,
	//Detonates all satchel charges owned by a player;
	SATCHEL_DETONATE = 0 
}
//Player hook flags. Used to skip execution of code when a hook performs an action that overrides built-in behavior.;
enum PlayerHookFlag {
	//Don\'t run +use checks;
	PlrHook_SkipUse = 2,
	//Don\'t run vehicle checks;
	PlrHook_SkipVehicles = 1 
}
//Player view mode.;
enum PlayerViewMode {
	//;
	ViewMode_ThirdPerson = 1,
	//;
	ViewMode_FirstPerson = 0 
}
//Player animations, set using CBasePlayer::SetAnimation.;
enum PLAYER_ANIM {
	//;
	PLAYER_BARNACLE_CHEW = 11,
	//;
	PLAYER_BARNACLE_CHOMP = 10,
	//;
	PLAYER_BARNACLE_PULL = 9,
	//;
	PLAYER_BARNACLE_HIT = 8,
	//;
	PLAYER_DEPLOY = 7,
	//;
	PLAYER_RELOAD = 6,
	//;
	PLAYER_ATTACK1 = 5,
	//;
	PLAYER_DIE = 4,
	//;
	PLAYER_SUPERJUMP = 3,
	//;
	PLAYER_JUMP = 2,
	//;
	PLAYER_WALK = 1,
	//;
	PLAYER_IDLE = 0 
}
//Player physics flags used in CBasePlayer::m_afPhysicsFlags;
enum PFLAG {
	//Looking through a trigger_camera;
	PFLAG_CAMERA = 128,
	//Toggle grapple use;
	PFLAG_GRAPPLE = 64,
	//player is locked in stationary cam mode. Spectators can move, observers can\'t.;
	PFLAG_OBSERVER = 32,
	//Using a continuous entity;
	PFLAG_USING = 16,
	//In the process of ducking, but totally squatted yet;
	PFLAG_DUCKING = 8,
	//;
	PFLAG_ONBARNACLE = 4,
	//;
	PFLAG_ONTRAIN = 2,
	//;
	PFLAG_ONSWING = 1,
	//;
	PFLAG_ONLADDER = 1 
}
//Train modes used by CBasePlayer::m_iTrain;
enum Train {
	//;
	TRAIN_BACK = 5,
	//;
	TRAIN_FAST = 4,
	//;
	TRAIN_MEDIUM = 3,
	//;
	TRAIN_SLOW = 2,
	//;
	TRAIN_NEUTRAL = 1,
	//;
	TRAIN_OFF = 0,
	//;
	TRAIN_NEW = 192,
	//;
	TRAIN_ACTIVE = 128 
}
//Bit field values for entvars_t.buttons.\nUsed by players to determine which buttons have been pressed;
enum In_Buttons {
	//Used by client.dll for when scoreboard is held down;
	IN_SCORE = 32768,
	//Tertiary attack;
	IN_ALT1 = 16384,
	//Reload;
	IN_RELOAD = 8192,
	//Run/Walk;
	IN_RUN = 4096,
	//Secondary attack;
	IN_ATTACK2 = 2048,
	//Move right;
	IN_MOVERIGHT = 1024,
	//Move left;
	IN_MOVELEFT = 512,
	//;
	IN_RIGHT = 256,
	//;
	IN_LEFT = 128,
	//;
	IN_CANCEL = 64,
	//Use;
	IN_USE = 32,
	//Move backward;
	IN_BACK = 16,
	//Move forward;
	IN_FORWARD = 8,
	//Duck;
	IN_DUCK = 4,
	//Jump;
	IN_JUMP = 2,
	//Primary attack;
	IN_ATTACK = 1 
}
//Observer modes;
enum ObserverMode {
	//Roaming;
	OBS_ROAMING = 2,
	//Free movement;
	OBS_CHASE_FREE = 1,
	//Chase locked;
	OBS_CHASE_LOCKED = 3,
	//Player not in observer mode;
	OBS_NONE = 0,
	//Player in the process of entering observer mode;
	OBS_ENTERING = -1 
}
//Key Codes;
enum KeyCode {
	//The last number in the range of key codes.;
	KEY_LAST = 103,
	//F12;
	KEY_F12 = 102,
	//F11;
	KEY_F11 = 101,
	//F10;
	KEY_F10 = 100,
	//F9;
	KEY_F9 = 99,
	//F8;
	KEY_F8 = 98,
	//F7;
	KEY_F7 = 97,
	//F6;
	KEY_F6 = 96,
	//F5;
	KEY_F5 = 95,
	//F4;
	KEY_F4 = 94,
	//F3;
	KEY_F3 = 93,
	//F2;
	KEY_F2 = 92,
	//F1;
	KEY_F1 = 91,
	//RIGHT;
	KEY_RIGHT = 90,
	//DOWN;
	KEY_DOWN = 89,
	//LEFT;
	KEY_LEFT = 88,
	//UP;
	KEY_UP = 87,
	//APP;
	KEY_APP = 86,
	//RWIN;
	KEY_RWIN = 85,
	//LWIN;
	KEY_LWIN = 84,
	//RCONTROL;
	KEY_RCONTROL = 83,
	//LCONTROL;
	KEY_LCONTROL = 82,
	//RALT;
	KEY_RALT = 81,
	//LALT;
	KEY_LALT = 80,
	//RSHIFT;
	KEY_RSHIFT = 79,
	//LSHIFT;
	KEY_LSHIFT = 78,
	//BREAK;
	KEY_BREAK = 77,
	//PAGEDOWN;
	KEY_PAGEDOWN = 76,
	//PAGEUP;
	KEY_PAGEUP = 75,
	//END;
	KEY_END = 74,
	//HOME;
	KEY_HOME = 73,
	//DELETE;
	KEY_DELETE = 72,
	//INSERT;
	KEY_INSERT = 71,
	//SCROLLLOCK;
	KEY_SCROLLLOCK = 70,
	//ESCAPE;
	KEY_ESCAPE = 69,
	//NUMLOCK;
	KEY_NUMLOCK = 68,
	//CAPSLOCK;
	KEY_CAPSLOCK = 67,
	//TAB;
	KEY_TAB = 66,
	//BACKSPACE;
	KEY_BACKSPACE = 65,
	//SPACE;
	KEY_SPACE = 64,
	//ENTER;
	KEY_ENTER = 63,
	//EQUAL;
	KEY_EQUAL = 62,
	//MINUS;
	KEY_MINUS = 61,
	//BACKSLASH;
	KEY_BACKSLASH = 60,
	//SLASH;
	KEY_SLASH = 59,
	//PERIOD;
	KEY_PERIOD = 58,
	//COMMA;
	KEY_COMMA = 57,
	//BACKQUOTE;
	KEY_BACKQUOTE = 56,
	//APOSTROPHE;
	KEY_APOSTROPHE = 55,
	//SEMICOLON;
	KEY_SEMICOLON = 54,
	//RBRACKET;
	KEY_RBRACKET = 53,
	//LBRACKET;
	KEY_LBRACKET = 52,
	//Numpad DECIMAL;
	KEY_PAD_DECIMAL = 51,
	//Numpad ENTER;
	KEY_PAD_ENTER = 50,
	//Numpad PLUS;
	KEY_PAD_PLUS = 49,
	//Numpad MINUS;
	KEY_PAD_MINUS = 48,
	//Numpad MULTIPLY;
	KEY_PAD_MULTIPLY = 47,
	//Numpad DIVIDE;
	KEY_PAD_DIVIDE = 46,
	//Numpad 9;
	KEY_PAD_9 = 45,
	//Numpad 8;
	KEY_PAD_8 = 44,
	//Numpad 7;
	KEY_PAD_7 = 43,
	//Numpad 6;
	KEY_PAD_6 = 42,
	//Numpad 5;
	KEY_PAD_5 = 41,
	//Numpad 4;
	KEY_PAD_4 = 40,
	//Numpad 3;
	KEY_PAD_3 = 39,
	//Numpad 2;
	KEY_PAD_2 = 38,
	//Numpad 1;
	KEY_PAD_1 = 37,
	//Numpad 0;
	KEY_PAD_0 = 36,
	//Z;
	KEY_Z = 35,
	//Y;
	KEY_Y = 34,
	//X;
	KEY_X = 33,
	//W;
	KEY_W = 32,
	//V;
	KEY_V = 31,
	//U;
	KEY_U = 30,
	//T;
	KEY_T = 29,
	//S;
	KEY_S = 28,
	//R;
	KEY_R = 27,
	//Q;
	KEY_Q = 26,
	//P;
	KEY_P = 25,
	//O;
	KEY_O = 24,
	//N;
	KEY_N = 23,
	//M;
	KEY_M = 22,
	//L;
	KEY_L = 21,
	//K;
	KEY_K = 20,
	//J;
	KEY_J = 19,
	//I;
	KEY_I = 18,
	//H;
	KEY_H = 17,
	//G;
	KEY_G = 16,
	//F;
	KEY_F = 15,
	//E;
	KEY_E = 14,
	//D;
	KEY_D = 13,
	//C;
	KEY_C = 12,
	//B;
	KEY_B = 11,
	//A;
	KEY_A = 10,
	//9;
	KEY_9 = 9,
	//8;
	KEY_8 = 8,
	//7;
	KEY_7 = 7,
	//6;
	KEY_6 = 6,
	//5;
	KEY_5 = 5,
	//4;
	KEY_4 = 4,
	//3;
	KEY_3 = 3,
	//2;
	KEY_2 = 2,
	//1;
	KEY_1 = 1,
	//0;
	KEY_0 = 0 
}
//Hit Group standards;
enum HITGROUP {
	//;
	HITGROUP_RIGHTLEG = 7,
	//;
	HITGROUP_LEFTLEG = 6,
	//;
	HITGROUP_RIGHTARM = 5,
	//;
	HITGROUP_LEFTARM = 4,
	//;
	HITGROUP_STOMACH = 3,
	//;
	HITGROUP_CHEST = 2,
	//;
	HITGROUP_HEAD = 1,
	//;
	HITGROUP_GENERIC = 0 
}
//Tells us what a monster can do.\nSee MonsterEntity::m_afCapability;
enum bits_CAPABILITY {
	//Combination of bits_CAP_USE, bits_CAP_AUTO_DOORS, and bits_CAP_OPEN_DOORS;
	bits_CAP_DOORS_GROUP = 832,
	//can take fall damage;
	bits_CAP_FALL_DAMAGE = 131072,
	//can use func_tanks;
	bits_CAP_USE_TANK = 65536,
	//can fly, move all around;
	bits_CAP_FLY = 32768,
	//can do a melee attack 2;
	bits_CAP_MELEE_ATTACK2 = 16384,
	//can do a melee attack 1;
	bits_CAP_MELEE_ATTACK1 = 8192,
	//can do a range attack 2;
	bits_CAP_RANGE_ATTACK2 = 4096,
	//can do a range attack 1;
	bits_CAP_RANGE_ATTACK1 = 2048,
	//can turn head, always bone controller 0;
	bits_CAP_TURN_HEAD = 1024,
	//can open manual doors;
	bits_CAP_OPEN_DOORS = 512,
	//can trigger auto doors;
	bits_CAP_AUTO_DOORS = 256,
	//can hear forced sounds;
	bits_CAP_HEAR = 128,
	//open doors/push buttons/pull levers;
	bits_CAP_USE = 64,
	//climb ladders/ropes;
	bits_CAP_CLIMB = 32,
	//proficiently navigate in water;
	bits_CAP_SWIM = 16,
	//can form squads;
	bits_CAP_SQUAD = 8,
	//strafe ( walk/run sideways);
	bits_CAP_STRAFE = 4,
	//jump/leap;
	bits_CAP_JUMP = 2,
	//crouch;
	bits_CAP_DUCK = 1 
}
//Monster event types;
enum MonsterEventType {
	//;
	MONSTER_EVENT_SWISHSOUND = 2010,
	//;
	MONSTER_EVENT_FOOTSTEP = 2003,
	//;
	MONSTER_EVENT_BODYDROP_HEAVY = 2002,
	//;
	MONSTER_EVENT_BODYDROP_LIGHT = 2001,
	//;
	EVENT_CLIENT = 5000,
	//;
	EVENT_SHARED = 2000,
	//;
	EVENT_SCRIPTED = 1000,
	//;
	EVENT_SPECIFIC = 0 
}
//Task types for the monster AI;
enum TASK_TYPE {
	//;
	LAST_COMMON_TASK = 112,
	//;
	TASK_PATH_WAYPOINT_DEPARTURE = 111,
	//;
	TASK_PATH_WAYPOINT_WAIT = 110,
	//;
	TASK_PATH_WAYPOINT_ARRIVAL = 109,
	//;
	TASK_PATH_WAYPOINT_ANGLES = 108,
	//;
	TASK_PATH_WAYPOINT_MOVEMENT = 107,
	//;
	TASK_PATH_WAYPOINT_INITIALIZE = 106,
	//;
	TASK_MOVE_TO_ENEMY = 105,
	//;
	TASK_GET_PATH_TO_BESTCOMBATSOUND = 104,
	//;
	TASK_FIND_COVER_DISTANCE_FROM_ENEMY = 103,
	//;
	TASK_RUN_TO_TANK = 102,
	//;
	TASK_USE_TANK = 101,
	//;
	TASK_PLAY_SEQUENCE_COWER = 100,
	//;
	TASK_MOVE_TO_TARGET_RANGE_FORCE = 99,
	//;
	TASK_WAIT_FOR_MOVEMENT_GRENADE = 98,
	//;
	TASK_FIND_ATTACKPOINT_TO_ENEMY = 97,
	//;
	TASK_WAIT_AT_TANK = 96,
	//;
	TASK_GET_PATH_TO_TANK = 95,
	//;
	TASK_FIND_TANK = 94,
	//;
	TASK_MOVE_AWAY_PLAYERPATH = 93,
	//;
	TASK_WALK_PLAYERPATH_FOR_UNITS = 92,
	//;
	TASK_WAIT_FOR_MOVEMENT_ENEMY_OCCLUDED = 91,
	//;
	TASK_WAIT_FOR_MOVEMENT_AP = 90,
	//;
	TASK_WAIT_FOR_MOVEMENT = 89,
	//;
	TASK_FORGET = 88,
	//;
	TASK_REMEMBER = 87,
	//;
	TASK_TURN_RIGHT = 86,
	//;
	TASK_TURN_LEFT = 85,
	//;
	TASK_STOP_MOVING = 84,
	//;
	TASK_WAIT_INDEFINITE = 83,
	//;
	TASK_WAIT_RANDOM = 82,
	//;
	TASK_FACE_SCRIPT = 81,
	//;
	TASK_PLANT_ON_SCRIPT = 80,
	//;
	TASK_ENABLE_SCRIPT = 79,
	//;
	TASK_PLAY_SCRIPT = 78,
	//;
	TASK_WAIT_FOR_SCRIPT = 77,
	//;
	TASK_DIE = 76,
	//;
	TASK_EAT = 75,
	//;
	TASK_FIND_COVER_FROM_ORIGIN = 74,
	//;
	TASK_FIND_FAR_NODE_COVER_FROM_ENEMY = 73,
	//;
	TASK_FIND_NEAR_NODE_COVER_FROM_ENEMY = 72,
	//;
	TASK_FIND_NODE_COVER_FROM_ENEMY = 71,
	//;
	TASK_FIND_LATERAL_COVER_FROM_ENEMY = 70,
	//;
	TASK_FIND_COVER_FROM_ENEMY = 69,
	//;
	TASK_FIND_COVER_FROM_BEST_SOUND = 68,
	//;
	TASK_SOUND_DIE = 67,
	//;
	TASK_SOUND_PAIN = 66,
	//;
	TASK_SOUND_WAKE = 65,
	//;
	TASK_SOUND_IDLE = 64,
	//;
	TASK_PLAY_SEQUENCE_FACE_TARGET = 63,
	//;
	TASK_PLAY_SEQUENCE_FACE_ENEMY = 62,
	//;
	TASK_PLAY_SEQUENCE = 61,
	//;
	TASK_CLEAR_FAIL_SCHEDULE = 60,
	//;
	TASK_SET_FAIL_SCHEDULE = 59,
	//;
	TASK_SET_SCHEDULE = 58,
	//;
	TASK_SET_ACTIVITY = 57,
	//;
	TASK_SOUND_DEATH = 56,
	//;
	TASK_SOUND_ANGRY = 55,
	//;
	TASK_DODGE_RIGHT = 54,
	//;
	TASK_DODGE_LEFT = 53,
	//;
	TASK_STEP_BACK = 52,
	//;
	TASK_STEP_FORWARD = 51,
	//;
	TASK_STEP_RIGHT = 50,
	//;
	TASK_STEP_LEFT = 49,
	//;
	TASK_GUARD = 48,
	//;
	TASK_STAND = 47,
	//;
	TASK_CROUCH = 46,
	//;
	TASK_SPECIAL_ATTACK2 = 45,
	//;
	TASK_SPECIAL_ATTACK1 = 44,
	//;
	TASK_RELOAD_NOTURN = 43,
	//;
	TASK_MELEE_ATTACK2_NOTURN = 42,
	//;
	TASK_MELEE_ATTACK1_NOTURN = 41,
	//;
	TASK_RANGE_ATTACK2_NOTURN = 40,
	//;
	TASK_RANGE_ATTACK1_NOTURN = 39,
	//;
	TASK_RELOAD = 38,
	//;
	TASK_MELEE_ATTACK2 = 37,
	//;
	TASK_MELEE_ATTACK1 = 36,
	//;
	TASK_RANGE_ATTACK2 = 35,
	//;
	TASK_RANGE_ATTACK1 = 34,
	//;
	TASK_FACE_LASTPOSITION = 33,
	//;
	TASK_FACE_TARGET = 32,
	//;
	TASK_FACE_HINTNODE = 31,
	//;
	TASK_FACE_ENEMY = 30,
	//;
	TASK_FACE_ROUTE = 29,
	//;
	TASK_FACE_IDEAL = 28,
	//;
	TASK_SMALL_FLINCH = 27,
	//;
	TASK_CLEAR_HINTNODE = 26,
	//;
	TASK_FIND_HINTNODE = 25,
	//;
	TASK_PLAY_ACTIVE_IDLE = 24,
	//;
	TASK_CLEAR_LASTPOSITION = 23,
	//;
	TASK_STORE_LASTPOSITION = 22,
	//;
	TASK_CLEAR_MOVE_WAIT = 21,
	//;
	TASK_STRAFE_PATH = 20,
	//;
	TASK_WALK_PATH = 19,
	//;
	TASK_RUN_PATH = 18,
	//;
	TASK_GET_PATH_TO_BESTSCENT = 17,
	//;
	TASK_GET_PATH_TO_BESTSOUND = 16,
	//;
	TASK_GET_PATH_TO_LASTPOSITION = 15,
	//;
	TASK_GET_PATH_TO_HINTNODE = 14,
	//;
	TASK_GET_PATH_TO_TARGET = 13,
	//;
	TASK_GET_PATH_TO_SPOT = 12,
	//;
	TASK_GET_PATH_TO_LEADER = 11,
	//;
	TASK_GET_PATH_TO_ENEMY_CORPSE = 10,
	//;
	TASK_GET_PATH_TO_ENEMY_LKP = 9,
	//;
	TASK_GET_PATH_TO_ENEMY = 8,
	//;
	TASK_MOVE_TO_TARGET_RANGE = 7,
	//;
	TASK_RUN_TO_TARGET = 6,
	//;
	TASK_WALK_TO_TARGET = 5,
	//;
	TASK_SUGGEST_STATE = 4,
	//;
	TASK_WAIT_PVS = 3,
	//;
	TASK_WAIT_FACE_ENEMY = 2,
	//;
	TASK_WAIT = 1,
	//;
	TASK_INVALID = 0 
}
//Schedule types for monster AI;
enum SCHEDULE_TYPE {
	//;
	LAST_COMMON_SCHEDULE = 57,
	//;
	SCHED_PATH_WAYPOINT = 56,
	//;
	SCHED_GUARD_POINT = 55,
	//;
	SCHED_TELEPORT_FALL = 54,
	//;
	SCHED_SMALL_FLINCH_SPECIAL = 53,
	//;
	SCHED_RANGE_ATTACK1_DEFAULT = 52,
	//;
	SCHED_LOSE_ENEMY = 51,
	//;
	SCHED_FIND_ATTACK_POINT = 50,
	//;
	SCHED_WAIT_AT_TANK = 49,
	//;
	SCHED_MOVE_TO_TANK = 48,
	//;
	SCHED_MOVE_AWAY_PLAYERFOLLOW = 47,
	//;
	SCHED_TARGET_PLAYERCHASE_FORCE = 46,
	//;
	SCHED_TARGET_PLAYERCHASE = 45,
	//;
	SCHED_TARGET_PLAYERFACE = 44,
	//;
	SCHED_FAIL = 43,
	//;
	SCHED_AISCRIPT = 42,
	//;
	SCHED_BARNACLE_VICTIM_CHOMP = 41,
	//;
	SCHED_BARNACLE_VICTIM_GRAB = 40,
	//;
	SCHED_WAKE = 39,
	//;
	SCHED_SLEEP = 38,
	//;
	SCHED_FOLLOW = 37,
	//;
	SCHED_WAIT_TILL_SEEN = 36,
	//;
	SCHED_WAIT_TRIGGER = 35,
	//;
	SCHED_DIE = 34,
	//;
	SCHED_AMBUSH = 33,
	//;
	SCHED_GUARD = 32,
	//;
	SCHED_RELOAD = 31,
	//;
	SCHED_ARM_WEAPON = 30,
	//;
	SCHED_STANDOFF = 29,
	//;
	SCHED_SPECIAL_ATTACK2 = 28,
	//;
	SCHED_SPECIAL_ATTACK1 = 27,
	//;
	SCHED_RANGE_ATTACK2 = 26,
	//;
	SCHED_RANGE_ATTACK1 = 25,
	//;
	SCHED_MELEE_ATTACK2 = 24,
	//;
	SCHED_MELEE_ATTACK1 = 23,
	//;
	SCHED_COWER = 22,
	//;
	SCHED_TAKE_COVER_FROM_ORIGIN = 21,
	//;
	SCHED_TAKE_COVER_FROM_BEST_SOUND = 20,
	//;
	SCHED_TAKE_COVER_FROM_ENEMY = 19,
	//;
	SCHED_SMALL_FLINCH = 18,
	//;
	SCHED_TARGET_CHASE = 17,
	//;
	SCHED_TARGET_FACE = 16,
	//;
	SCHED_VICTORY_DANCE = 15,
	//;
	SCHED_CHASE_ENEMY_FAILED = 14,
	//;
	SCHED_CHASE_ENEMY = 13,
	//;
	SCHED_COMBAT_STAND = 12,
	//;
	SCHED_COMBAT_FACE = 11,
	//;
	SCHED_INVESTIGATE_COMBAT = 10,
	//;
	SCHED_INVESTIGATE_SOUND = 9,
	//;
	SCHED_ALERT_STAND = 8,
	//;
	SCHED_ALERT_BIG_FLINCH = 7,
	//;
	SCHED_ALERT_SMALL_FLINCH = 6,
	//;
	SCHED_ALERT_FACE = 5,
	//;
	SCHED_WAKE_CALLED = 4,
	//;
	SCHED_WAKE_ANGRY = 3,
	//;
	SCHED_IDLE_WALK = 2,
	//;
	SCHED_IDLE_STAND = 1,
	//;
	SCHED_NONE = 0 
}
//trigger conditions for scripted AI;
enum AITRIGGER {
	//See Player, Not In Combat;
	AITRIGGER_SEEPLAYER_NOT_IN_COMBAT = 11,
	//See Player Unconditional;
	AITRIGGER_SEEPLAYER_UNCONDITIONAL = 10,
	//Hear Combat;
	AITRIGGER_HEARCOMBAT = 9,
	//Hear Player;
	AITRIGGER_HEARPLAYER = 8,
	//Hear World;
	AITRIGGER_HEARWORLD = 7,
	//Squad Leader Dead;
	AITRIGGER_SQUADLEADERDIE = 6,
	//Squad Member Dead;
	AITRIGGER_SQUADMEMBERDIE = 5,
	//Death;
	AITRIGGER_DEATH = 4,
	//50% Health Remaining;
	AITRIGGER_HALFHEALTH = 3,
	//Take Damage;
	AITRIGGER_TAKEDAMAGE = 2,
	//See Player;
	AITRIGGER_SEEPLAYER_ANGRY_AT_PLAYER = 1,
	//No Trigger;
	AITRIGGER_NONE = 0 
}
//these bits represent the monster\'s memory;
enum MonsterMemory {
	//Monster-specific memory;
	bits_MEMORY_CUSTOM1 = -2147483648,
	//Monster-specific memory;
	bits_MEMORY_CUSTOM2 = 1073741824,
	//Monster-specific memory;
	bits_MEMORY_CUSTOM3 = 536870912,
	//Monster-specific memory;
	bits_MEMORY_CUSTOM4 = 268435456,
	//Can only get there within radius;
	bits_MEMORY_MOVE_RADIUS_ONLY = 256,
	//HACKHACK -- remember that I\'ve already called my Killed();
	bits_MEMORY_KILLED = 128,
	//Has already flinched;
	bits_MEMORY_FLINCHED = 64,
	//Movement has already failed;
	bits_MEMORY_MOVE_FAILED = 32,
	//Moving on a path;
	bits_MEMORY_ON_PATH = 16,
	//Finished monster path (just used by big momma for now);
	bits_MEMORY_PATH_FINISHED = 8,
	//Ally is suspicious of the player, and will move to provoked more easily;
	bits_MEMORY_SUSPICIOUS = 4,
	//monster knows it is in a covered position.;
	bits_MEMORY_INCOVER = 2,
	//right now only used for houndeyes.;
	bits_MEMORY_PROVOKED = 1,
	//No memory.;
	MEMORY_CLEAR = 0 
}
//Damage over time types.;
enum CDMG {
	//Number of damage over time types;
	CDMG_TIMEBASED = 8,
	//;
	itbd_SlowFreeze = 7,
	//;
	itbd_SlowBurn = 6,
	//;
	itbd_Acid = 5,
	//;
	itbd_DrownRecover = 4,
	//;
	itbd_Radiation = 3,
	//;
	itbd_Poison = 2,
	//;
	itbd_NerveGas = 1,
	//;
	itbd_Paralyze = 0 
}
//these bits represent conditions that may befall the monster, of which some are allowed\nto interrupt certain schedules. ;
enum MonsterCondition {
	//;
	bits_COND_CAN_ATTACK = 15360,
	//;
	bits_COND_ALL_SPECIAL = 805306368,
	//This monster can use a func_tank now;
	bits_COND_CAN_USE_TANK = 16384,
	//;
	bits_COND_SCHEDULE_DONE = -2147483648,
	//;
	bits_COND_TASK_FAILED = 1073741824,
	//Defined by individual monster;
	bits_COND_SPECIAL2 = 536870912,
	//Defined by individual monster;
	bits_COND_SPECIAL1 = 268435456,
	//;
	bits_COND_CAN_MELEE_ATTACK2_MOVING = 67108864,
	//;
	bits_COND_CAN_RANGE_ATTACK2_MOVING = 33554432,
	//;
	bits_COND_CAN_MELEE_ATTACK1_MOVING = 16777216,
	//;
	bits_COND_CAN_RANGE_ATTACK1_MOVING = 8388608,
	//see my nemesis;
	bits_COND_SEE_NEMESIS = 4194304,
	//see a client;
	bits_COND_SEE_CLIENT = 2097152,
	//enemy was killed. If you get this in combat, try to find another enemy. If you get it in alert, victory dance.;
	bits_COND_ENEMY_DEAD = 1048576,
	//enemy is facing me;
	bits_COND_ENEMY_FACING_ME = 524288,
	//there is an interesting scent;
	bits_COND_SMELL = 262144,
	//there is an interesting sound;
	bits_COND_HEAR_SOUND = 131072,
	//;
	bits_COND_NEW_ENEMY = 65536,
	//;
	bits_COND_PROVOKED = 32768,
	//;
	bits_COND_CAN_MELEE_ATTACK2 = 8192,
	//;
	bits_COND_CAN_RANGE_ATTACK2 = 4096,
	//;
	bits_COND_CAN_MELEE_ATTACK1 = 2048,
	//;
	bits_COND_CAN_RANGE_ATTACK1 = 1024,
	//hurt a lot;
	bits_COND_HEAVY_DAMAGE = 512,
	//hurt a little;
	bits_COND_LIGHT_DAMAGE = 256,
	//;
	bits_COND_ENEMY_TOOFAR = 128,
	//;
	bits_COND_SMELL_FOOD = 64,
	//target entity occluded by the world;
	bits_COND_ENEMY_OCCLUDED = 32,
	//target entity is in full view.;
	bits_COND_SEE_ENEMY = 16,
	//see something that you dislike;
	bits_COND_SEE_DISLIKE = 8,
	//see something that you are afraid of;
	bits_COND_SEE_FEAR = 4,
	//see something that you hate;
	bits_COND_SEE_HATE = 2,
	//weapon needs to be reloaded!;
	bits_COND_NO_AMMO_LOADED = 1 
}
//these MoveFlag values are assigned to a WayPoint\'s TYPE in order to demonstrate the\ntype of movement the monster should use to get there.;
enum MoveFlag {
	//Elevator;
	bits_MF_TO_ELEVATOR = 2048,
	//Ladder...;
	bits_MF_TO_LADDER = 1024,
	//Jumping...;
	bits_MF_TO_JUMP = 512,
	//Don\'t let the route code simplify this waypoint;
	bits_MF_DONT_SIMPLIFY = 256,
	//this waypoint is the goal of the whole move.;
	bits_MF_IS_GOAL = 128,
	//local move to an arbitrary point;
	bits_MF_TO_LOCATION = 64,
	//local move to a node;
	bits_MF_TO_NODE = 32,
	//local move to a path corner;
	bits_MF_TO_PATHCORNER = 16,
	//local move to detour point.;
	bits_MF_TO_DETOUR = 8,
	//local move to a hiding place;
	bits_MF_TO_COVER = 4,
	//local move to enemy;
	bits_MF_TO_ENEMY = 2,
	//local move to targetent.;
	bits_MF_TO_TARGETENT = 1 
}
//These go in the flData member of TASK_WALK_TO_TARGET, TASK_RUN_TO_TARGET;
enum TaskData {
	//Move scripted;
	TARGET_MOVE_SCRIPTED = 1,
	//Move normally;
	TARGET_MOVE_NORMAL = 0 
}
//Current state of a monster;
enum MONSTERSTATE {
	//;
	MONSTERSTATE_DEAD = 8,
	//;
	MONSTERSTATE_PLAYDEAD = 7,
	//;
	MONSTERSTATE_SCRIPT = 6,
	//;
	MONSTERSTATE_PRONE = 5,
	//;
	MONSTERSTATE_HUNT = 4,
	//;
	MONSTERSTATE_ALERT = 3,
	//;
	MONSTERSTATE_COMBAT = 2,
	//;
	MONSTERSTATE_IDLE = 1,
	//;
	MONSTERSTATE_NONE = 0 
}
//Activity currently being played by a monster;
enum Activity {
	//;
	ACT_FLINCH_RIGHTLEG = 76,
	//;
	ACT_FLINCH_LEFTLEG = 75,
	//;
	ACT_FLINCH_RIGHTARM = 74,
	//;
	ACT_FLINCH_LEFTARM = 73,
	//;
	ACT_FLINCH_STOMACH = 72,
	//;
	ACT_FLINCH_CHEST = 71,
	//;
	ACT_FLINCH_HEAD = 70,
	//die, hit in back;
	ACT_DIE_BACKSHOT = 69,
	//die, hit in gut;
	ACT_DIE_GUTSHOT = 68,
	//die, hit in chest;
	ACT_DIE_CHESTSHOT = 67,
	//die, hit in head. ;
	ACT_DIE_HEADSHOT = 66,
	//killed a player, do a victory dance.;
	ACT_VICTORY_DANCE = 65,
	//;
	ACT_RUN_SCARED = 64,
	//;
	ACT_WALK_SCARED = 63,
	//agitated idle.;
	ACT_COMBAT_IDLE = 62,
	//;
	ACT_SPECIAL_ATTACK2 = 61,
	//very monster specific special attacks.;
	ACT_SPECIAL_ATTACK1 = 60,
	//for some reason, monster is excited. Sees something he really likes to eat, or whatever.;
	ACT_EXCITED = 59,
	//monster just saw something that it is afraid of;
	ACT_FEAR_DISPLAY = 58,
	//without attacking, monster demonstrates that it is angry. (Yell, stick out chest, etc );
	ACT_THREAT_DISPLAY = 57,
	//some large monsters can eat small things in one bite. This plays one time, EAT loops.;
	ACT_BITE = 56,
	//this is the act of actually sniffing an item in front of the monster;
	ACT_SNIFF = 55,
	//this means the monster smells a scent carried by the air;
	ACT_DETECT_SCENT = 54,
	//Turn right in flight;
	ACT_FLY_RIGHT = 53,
	//Turn left in flight;
	ACT_FLY_LEFT = 52,
	//Fly (don\'t flap);
	ACT_GLIDE = 51,
	//Idle while in flight;
	ACT_HOVER = 50,
	//limp  (loop);
	ACT_RUN_HURT = 49,
	//limp  (loop);
	ACT_WALK_HURT = 48,
	//alternate idle animation in which the monster is clearly agitated. (loop);
	ACT_IDLE_ANGRY = 47,
	//for active idles, look at something directly ahead of you ( doesn\'t HAVE to be a wall or on a wall );
	ACT_INSPECT_WALL = 46,
	//for active idles, look at something on or near the floor;
	ACT_INSPECT_FLOOR = 45,
	//;
	ACT_SLEEP = 44,
	//barnacle is holding the monster in its mouth ( loop );
	ACT_BARNACLE_CHEW = 43,
	//barnacle latches on to the monster;
	ACT_BARNACLE_CHOMP = 42,
	//barnacle is lifting the monster ( loop );
	ACT_BARNACLE_PULL = 41,
	//barnacle tongue hits a monster;
	ACT_BARNACLE_HIT = 40,
	//;
	ACT_DIEVIOLENT = 39,
	//;
	ACT_DIEFORWARD = 38,
	//;
	ACT_DIEBACKWARD = 37,
	//;
	ACT_DIESIMPLE = 36,
	//monster chowing on a large food item (loop);
	ACT_EAT = 35,
	//reholster gun;
	ACT_DISARM = 34,
	//pull out gun, for instance;
	ACT_ARM = 33,
	//;
	ACT_RELOAD = 32,
	//;
	ACT_MELEE_ATTACK2 = 31,
	//;
	ACT_MELEE_ATTACK1 = 30,
	//;
	ACT_RANGE_ATTACK2 = 29,
	//;
	ACT_RANGE_ATTACK1 = 28,
	//;
	ACT_BIG_FLINCH = 27,
	//;
	ACT_SMALL_FLINCH = 26,
	//;
	ACT_COWER = 25,
	//;
	ACT_TWITCH = 24,
	//;
	ACT_SIGNAL3 = 23,
	//;
	ACT_SIGNAL2 = 22,
	//;
	ACT_SIGNAL1 = 21,
	//;
	ACT_USE = 20,
	//the act of standing from a crouched position;
	ACT_STAND = 19,
	//holding body in crouched position (loops);
	ACT_CROUCHIDLE = 18,
	//the act of crouching down from a standing position;
	ACT_CROUCH = 17,
	//turn quickly right (stationary);
	ACT_TURN_RIGHT = 16,
	//turn quickly left (stationary);
	ACT_TURN_LEFT = 15,
	//tuck and roll, right;
	ACT_ROLL_RIGHT = 14,
	//tuck and roll, left;
	ACT_ROLL_LEFT = 13,
	//;
	ACT_STRAFE_RIGHT = 12,
	//;
	ACT_STRAFE_LEFT = 11,
	//;
	ACT_LAND = 10,
	//;
	ACT_FALL = 9,
	//long forward jump;
	ACT_LEAP = 8,
	//vertical jump;
	ACT_HOP = 7,
	//;
	ACT_SWIM = 6,
	//Fly (and flap if appropriate);
	ACT_FLY = 5,
	//;
	ACT_RUN = 4,
	//;
	ACT_WALK = 3,
	//;
	ACT_GUARD = 2,
	//;
	ACT_IDLE = 1,
	//Set m_Activity to this invalid value to force a reset to m_IdealActivity;
	ACT_RESET = 0 
}
//The state of a monster\'s script.;
enum SCRIPTSTATE {
	//Run to mark;
	SCRIPT_RUN_TO_MARK = 4,
	//Walk to mark;
	SCRIPT_WALK_TO_MARK = 3,
	//Cancelling the script / cleaning up;
	SCRIPT_CLEANUP = 2,
	//Waiting on everyone in the script to be ready;
	SCRIPT_WAIT = 1,
	//Playing the sequence;
	SCRIPT_PLAYING = 0 
}
//Material types supported by breakables;
enum Materials {
	//;
	matLastMaterial = 10,
	//;
	matNone = 9,
	//;
	matRocks = 8,
	//;
	matUnbreakableGlass = 7,
	//;
	matComputer = 6,
	//;
	matCeilingTile = 5,
	//;
	matCinderBlock = 4,
	//;
	matFlesh = 3,
	//;
	matMetal = 2,
	//;
	matWood = 1,
	//;
	matGlass = 0 
}
//Return values for CBaseEntity::AddPlayerItem;
enum AddPlayerItemResult {
	//Player picked up this item;
	APIR_Added = 3,
	//Player was able to add it as duplicate;
	APIR_DuplicateAdd = 2,
	//Player could not pick up this item;
	APIR_NotAdded = 0 
}
//bullet types;
enum Bullet {
	//;
	DECAL_SCORCH_MARK = 17,
	//Monster shotgun;
	BULLET_MONSTER_BUCKSHOT = 16,
	//;
	BULLET_MONSTER_SNIPER = 15,
	//;
	BULLET_MONSTER_EAGLE = 14,
	//;
	BULLET_MONSTER_12MM = 13,
	//;
	BULLET_MONSTER_SAW = 12,
	//;
	BULLET_MONSTER_MP5 = 11,
	//;
	BULLET_MONSTER_9MM = 10,
	//normal bullet with custom damage;
	BULLET_PLAYER_CUSTOMDAMAGE = 9,
	//;
	BULLET_PLAYER_CROWBAR = 8,
	//Shotgun;
	BULLET_PLAYER_BUCKSHOT = 7,
	//Desert eagle;
	BULLET_PLAYER_EAGLE = 6,
	//Python;
	BULLET_PLAYER_357 = 5,
	//;
	BULLET_PLAYER_SNIPER = 4,
	//;
	BULLET_PLAYER_SAW = 3,
	//mp5;
	BULLET_PLAYER_MP5 = 2,
	//Glock;
	BULLET_PLAYER_9MM = 1,
	//;
	BULLET_NONE = 0 
}
//Common entity flags used by various entities.;
enum CommonEntityFlags {
	//Don\'t allow default ammo to be set. Prevents players from getting too much ammo from cross map inventory;
	SF_NODEFAULTAMMO = 32768,
	//This item is being given to the player -- can\'t fall out of map;
	SF_GIVENITEM = 16384,
	//this flag indicates that a player thrown weapon should deal damage to things it hits;
	SF_DODAMAGE = 8192,
	//this flag indicates that this entity is a weapon created for players,\nas opposed to being created by being placed by a mapper;
	SF_CREATEDWEAPON = 4096,
	//A weapon will be removed from the map after 60sec;
	SF_DELAYREMOVE = 2048,
	//set this bit on guns and stuff that should never respawn.;
	SF_NORESPAWN = 1024 
}
//FireBullets draw mode options;
enum FireBulletsDrawMode {
	//Draw impact decal;
	FBDM_DRAW = 2,
	//Don\'t draw impact decal;
	FBDM_DONTDRAW = 0 
}
//Render FX modes (entvars_t::renderfx);
enum RenderFX {
	//Keep this sprite from getting very small (SPRITES only!);
	kRenderFxClampMinScale = 20,
	//Glowing Shell;
	kRenderFxGlowShell = 19,
	//Scale up really big!;
	kRenderFxExplode = 18,
	//kRenderAmt is the player index;
	kRenderFxDeadPlayer = 17,
	//kRenderFxDistort + distance fade;
	kRenderFxHologram = 16,
	//Distort/scale/translate flicker;
	kRenderFxDistort = 15,
	//;
	kRenderFxNoDissipation = 14,
	//;
	kRenderFxFlickerFast = 13,
	//;
	kRenderFxFlickerSlow = 12,
	//;
	kRenderFxStrobeFaster = 11,
	//;
	kRenderFxStrobeFast = 10,
	//;
	kRenderFxStrobeSlow = 9,
	//;
	kRenderFxSolidFast = 8,
	//;
	kRenderFxSolidSlow = 7,
	//;
	kRenderFxFadeFast = 6,
	//;
	kRenderFxFadeSlow = 5,
	//;
	kRenderFxPulseFastWide = 4,
	//;
	kRenderFxPulseSlowWide = 3,
	//;
	kRenderFxPulseFast = 2,
	//;
	kRenderFxPulseSlow = 1,
	//;
	kRenderFxNone = 0 
}
//Render modes used by entities (entvars_t::rendermode);
enum RenderModes {
	//src*a+dest;
	kRenderTransAdd = 5,
	//src*srca+dest*(1-srca);
	kRenderTransAlpha = 4,
	//src*a+dest -- No Z buffer checks;
	kRenderGlow = 3,
	//src*a+dest*(1-a);
	kRenderTransTexture = 2,
	//c*a+dest*(1-a);
	kRenderTransColor = 1,
	//src;
	kRenderNormal = 0 
}
//Temp entity bounce sound types;
enum TE_BOUNCE {
	//;
	TE_BOUNCE_SHOTSHELL = 2,
	//;
	TE_BOUNCE_SHELL = 1,
	//;
	TE_BOUNCE_NULL = 0 
}
//Break model defines for message SVC_TEMPENTITY::TE_BREAKMODEL;
enum BREAK {
	//Not used;
	BREAK_2 = 128,
	//;
	BREAK_CONCRETE = 64,
	//Model is transparent;
	BREAK_TRANS = 32,
	//Adds a smoke trail;
	BREAK_SMOKE = 16,
	//;
	BREAK_WOOD = 8,
	//;
	BREAK_FLESH = 4,
	//;
	BREAK_METAL = 2,
	//;
	BREAK_GLASS = 1,
	//Bit mask for all BREAK types.;
	BREAK_TYPEMASK = 79 
}
//Texture types used by the game.;
enum TextureType {
	//Snow;
	CHAR_TEX_SNOW = 'O',
	//Flesh;
	CHAR_TEX_FLESH = 'F',
	//Glass;
	CHAR_TEX_GLASS = 'Y',
	//Computer;
	CHAR_TEX_COMPUTER = 'P',
	//Wood;
	CHAR_TEX_WOOD = 'W',
	//Slosh;
	CHAR_TEX_SLOSH = 'S',
	//Tile;
	CHAR_TEX_TILE = 'T',
	//Grate;
	CHAR_TEX_GRATE = 'G',
	//Vent;
	CHAR_TEX_VENT = 'V',
	//Dirt;
	CHAR_TEX_DIRT = 'D',
	//Metal;
	CHAR_TEX_METAL = 'M',
	//Concrete (Default);
	CHAR_TEX_CONCRETE = 'C' 
}
//when calling Killed(), a value that governs gib behavior is expected to be one of these three values;
enum GIB {
	//No penalty applied to players that died;
	GIB_NOPENALTY = 3,
	//always gib ( Houndeye Shock, Barnacle Bite );
	GIB_ALWAYS = 2,
	//never gib, no matter how much death damage is done ( freezing, etc );
	GIB_NEVER = 1,
	//gib if entity was overkilled;
	GIB_NORMAL = 0 
}
//Dynamic decals used by code to place decals like scorch marks in the world;
enum decal_e {
	//Spore splat 3;
	DECAL_SPORESPLAT3 = 47,
	//Spore splat 2;
	DECAL_SPORESPLAT2 = 46,
	//Spore splat 1;
	DECAL_SPORESPLAT1 = 45,
	//Opposing force scorch 3;
	DECAL_OFSCORCH3 = 44,
	//Opposing force scorch 2;
	DECAL_OFSCORCH2 = 43,
	//Opposing force scorch 1;
	DECAL_OFSCORCH1 = 42,
	//Big momma splat;
	DECAL_MOMMASPLAT = 41,
	//Big momma birth splatter;
	DECAL_MOMMABIRTH = 40,
	//Small scorch 3;
	DECAL_SMALLSCORCH3 = 39,
	//Small scorch 2;
	DECAL_SMALLSCORCH2 = 38,
	//Small scorch 1;
	DECAL_SMALLSCORCH1 = 37,
	//gargantua stomp crack;
	DECAL_GARGSTOMP1 = 36,
	//Bulletproof glass decal;
	DECAL_BPROOF1 = 35,
	//Spit 2;
	DECAL_SPIT2 = 34,
	//Spit 1;
	DECAL_SPIT1 = 33,
	//Big shot 5;
	DECAL_BIGSHOT5 = 32,
	//Big shot 4;
	DECAL_BIGSHOT4 = 31,
	//Big shot 3;
	DECAL_BIGSHOT3 = 30,
	//Big shot 2;
	DECAL_BIGSHOT2 = 29,
	//Big shot 1;
	DECAL_BIGSHOT1 = 28,
	//Glass break 3;
	DECAL_GLASSBREAK3 = 27,
	//Glass break 2;
	DECAL_GLASSBREAK2 = 26,
	//Glass break 1;
	DECAL_GLASSBREAK1 = 25,
	//Yellow blood 6;
	DECAL_YBLOOD6 = 24,
	//Yellow blood 5;
	DECAL_YBLOOD5 = 23,
	//Yellow blood 4;
	DECAL_YBLOOD4 = 22,
	//Yellow blood 3;
	DECAL_YBLOOD3 = 21,
	//Yellow blood 2;
	DECAL_YBLOOD2 = 20,
	//Yellow blood 1;
	DECAL_YBLOOD1 = 19,
	//(Red) Blood 6;
	DECAL_BLOOD6 = 18,
	//(Red) Blood 5;
	DECAL_BLOOD5 = 17,
	//(Red) Blood 4;
	DECAL_BLOOD4 = 16,
	//(Red) Blood 3;
	DECAL_BLOOD3 = 15,
	//(Red) Blood 2;
	DECAL_BLOOD2 = 14,
	//(Red) Blood 1;
	DECAL_BLOOD1 = 13,
	//Scorch 1;
	DECAL_SCORCH2 = 12,
	//Scorch 1;
	DECAL_SCORCH1 = 11,
	//Lambda 6;
	DECAL_LAMBDA6 = 10,
	//Lambda 5;
	DECAL_LAMBDA5 = 9,
	//Lambda 4;
	DECAL_LAMBDA4 = 8,
	//Lambda 3;
	DECAL_LAMBDA3 = 7,
	//Lambda 2;
	DECAL_LAMBDA2 = 6,
	//Lambda 1;
	DECAL_LAMBDA1 = 5,
	//Gunshot 5;
	DECAL_GUNSHOT5 = 4,
	//Gunshot 4;
	DECAL_GUNSHOT4 = 3,
	//Gunshot 3;
	DECAL_GUNSHOT3 = 2,
	//Gunshot 2;
	DECAL_GUNSHOT2 = 1,
	//Gunshot 1;
	DECAL_GUNSHOT1 = 0 
}
//Blood color;
enum BLOOD_COLOR {
	//Green blood;
	BLOOD_COLOR_GREEN = 195,
	//Yellow blood;
	BLOOD_COLOR_YELLOW = 195,
	//Red blood;
	BLOOD_COLOR_RED = 247,
	//Don\'t bleed;
	DONT_BLEED = -1 
}
//Toggle state for entities that can be toggled.;
enum TOGGLE_STATE {
	//Entity is going down;
	TS_GOING_DOWN = 3,
	//Entity is going up;
	TS_GOING_UP = 2,
	//Entity is at bottom;
	TS_AT_BOTTOM = 1,
	//Entity is at top;
	TS_AT_TOP = 0 
}
//Damage types.;
enum DMG {
	//Shown on HUD. These are the damage types that have clien hud art.;
	DMG_SHOWNHUD = 7815448,
	//Gib corpse. These are the damage types that are allowed to gib corpses.;
	DMG_GIB_CORPSE = 993,
	//Shock glow. Flag for shock glow effect.;
	DMG_SHOCK_GLOW = 134217728,
	//Medkit heal. Medkit healing.;
	DMG_MEDKITHEAL = 33554432,
	//Sniper. Hit by a Sniper.;
	DMG_SNIPER = 16777216,
	//Mortar. Hit by air raid (done to distinguish grenade from mortar);
	DMG_MORTAR = 8388608,
	//Slow freeze. In a subzero freezer.;
	DMG_SLOWFREEZE = 4194304,
	//Slow burn. In an oven.;
	DMG_SLOWBURN = 2097152,
	//Acid. Toxic chemicals or acid burns.;
	DMG_ACID = 1048576,
	//Drown recover. Drowning recovery.;
	DMG_DROWNRECOVER = 524288,
	//Radiation. Radiation exposure.;
	DMG_RADIATION = 262144,
	//Poison. Blood poisoning.;
	DMG_POISON = 131072,
	//Nerve gas. Nerve toxins, very bad.;
	DMG_NERVEGAS = 65536,
	//Paralyze. Slows affected creature down.;
	DMG_PARALYZE = 32768,
	//Mash for time-based damage.;
	DMG_TIMEBASED = 16760832,
	//Drown. Drowning.;
	DMG_DROWN = 16384,
	//Launch. Launch into air.;
	DMG_LAUNCH = 67108864,
	//Always gib. With this bit OR\'d in, any damage type can be made to gib victims upon death.;
	DMG_ALWAYSGIB = 8192,
	//Never gib. With this bit OR\'d in, no damage type will be able to gib victims upon death.;
	DMG_NEVERGIB = 4096,
	//Energy beam. Laser or other high energy beam.;
	DMG_ENERGYBEAM = 1024,
	//Sonic. Sound pulse shockwave.;
	DMG_SONIC = 512,
	//Shock. Electric shock.;
	DMG_SHOCK = 256,
	//Club. Crowbar, punch, headbutt.;
	DMG_CLUB = 128,
	//Blast. Explosive blast damage.;
	DMG_BLAST = 64,
	//Fall. Fell too far.;
	DMG_FALL = 32,
	//Freeze. Frozen.;
	DMG_FREEZE = 16,
	//Burn. Heat burned.;
	DMG_BURN = 8,
	//Slash. Cut, clawed, stabbed.;
	DMG_SLASH = 4,
	//Bullet. Shot.;
	DMG_BULLET = 2,
	//Crush damage. By falling or moving object.;
	DMG_CRUSH = 1,
	//Generic damage.;
	DMG_GENERIC = 0 
}
//Relationship between (monster) entities;
enum RELATIONSHIP {
	//Fear. Will attack.;
	R_FR = 4,
	//Nemesis. A monster will ALWAYS attack its nemesis, no matter what.;
	R_NM = 3,
	//Hate. Will attack this character instead of any DISLIKE\'d characters.;
	R_HT = 2,
	//Dislike. Will attack.;
	R_DL = 1,
	//No relationship. Disregard.;
	R_NO = 0,
	//Ally. Good alternative to R_NO when applicable.;
	R_AL = -2 
}
//Entity classification\nCan be set on entities with KeyValue using key \'classify\'.;
enum CLASS {
	//Is Barnacle;
	CLASS_BARNACLE = 99,
	//Is on Team 4;
	CLASS_TEAM4 = 19,
	//Is on Team 3;
	CLASS_TEAM3 = 18,
	//Is on Team 2;
	CLASS_TEAM2 = 17,
	//Is on Team 1;
	CLASS_TEAM1 = 16,
	//Is X-Race shock trooper (also Voltigores);
	CLASS_XRACE_SHOCK = 15,
	//Is X-Race pitdrone;
	CLASS_XRACE_PITDRONE = 14,
	//Is alien bioweapon;
	CLASS_ALIEN_BIOWEAPON = 13,
	//Is player bioweapon;
	CLASS_PLAYER_BIOWEAPON = 12,
	//is player ally;
	CLASS_PLAYER_ALLY = 11,
	//Is insect;
	CLASS_INSECT = 10,
	//Is predator alien;
	CLASS_ALIEN_PREDATOR = 9,
	//Is prey alien;
	CLASS_ALIEN_PREY = 8,
	//Is monster alien;
	CLASS_ALIEN_MONSTER = 7,
	//Is passive alien;
	CLASS_ALIEN_PASSIVE = 6,
	//Is military alien;
	CLASS_ALIEN_MILITARY = 5,
	//Is military human;
	CLASS_HUMAN_MILITARY = 4,
	//Is passive human;
	CLASS_HUMAN_PASSIVE = 3,
	//Is player;
	CLASS_PLAYER = 2,
	//Is machine;
	CLASS_MACHINE = 1,
	//No classification;
	CLASS_NONE = 0,
	//Forces class override to none;
	CLASS_FORCE_NONE = -1 
}
//CBaseEntity caps (CBaseEntity::ObjectCaps());
enum FCAP {
	//Force transition;
	FCAP_FORCE_TRANSITION = 128,
	//Is a master;
	FCAP_MASTER = 128,
	//Directional use;
	FCAP_DIRECTIONAL_USE = 64,
	//On/off use;
	FCAP_ONOFF_USE = 32,
	//Continuous use;
	FCAP_CONTINUOUS_USE = 16,
	//Impulse use;
	FCAP_IMPULSE_USE = 8,
	//Don\'t save;
	FCAP_DONT_SAVE = -2147483648,
	//Must spawn;
	FCAP_MUST_SPAWN = 4,
	//Across transition;
	FCAP_ACROSS_TRANSITION = 2,
	//Custom save method;
	FCAP_CUSTOMSAVE = 1 
}
//Entity variable type;
enum Entvartype {
	//Custom type;
	VAR_CUSTOM = 8,
	//2 byte array type;
	VAR_BYTE2 = 7,
	//4 byte array type;
	VAR_BYTE4 = 6,
	//Edict type;
	VAR_EDICT = 5,
	//Integer type;
	VAR_INTEGER = 4,
	//Float type;
	VAR_FLOAT = 3,
	//Vector type;
	VAR_VECTOR = 2,
	//String type;
	VAR_STRING = 1,
	//Invalid type;
	VAR_INVALID = 0 
}
//Use type for entities. Not all entities support all use types.\nPassed to the Use method on entities.;
enum USE_TYPE {
	//Kills an entity;
	USE_KILL = 4,
	//Toggles the state of an entity;
	USE_TOGGLE = 3,
	//Sets the state of an entity (use float parameter in Use);
	USE_SET = 2,
	//Turns on an entity;
	USE_ON = 1,
	//Turns off an entity;
	USE_OFF = 0 
}
//entvars_t::fixangle modes;
enum FixAngleMode {
	//Add avelocity to player view angles;
	FAM_ADDAVELOCITY = 2,
	//Force player view angles to entvars_t::angles;
	FAM_FORCEVIEWANGLES = 1,
	//Do nothing;
	FAM_NOTHING = 0 
}
//entvars_t waterlevel values;
enum WATERLEVEL {
	//Head underwater (completely submerged);
	WATERLEVEL_HEAD = 3,
	//Waist underwater;
	WATERLEVEL_WAIST = 2,
	//Feet underwater;
	WATERLEVEL_FEET = 1,
	//Not in water;
	WATERLEVEL_DRY = 0 
}
//entvars_t::effects constants;
enum EFFECTS {
	//Use the value in pev->frame to set the texture on a brush entity;
	EF_FRAMEANIMTEXTURES = 512,
	//Don\'t animate brush entities;
	EF_NOANIMTEXTURES = 256,
	//don\'t draw decals on this entity;
	EF_NODECALS = 2048,
	//don\'t draw entity;
	EF_NODRAW = 128,
	//rocket flare glow sprite;
	EF_LIGHT = 64,
	//don\'t interpolate the next frame;
	EF_NOINTERP = 32,
	//get lighting from ceiling;
	EF_INVLIGHT = 16,
	//player flashlight;
	EF_DIMLIGHT = 8,
	//DLIGHT centered at entity origin;
	EF_BRIGHTLIGHT = 4,
	//single frame ELIGHT on entity attachment 0;
	EF_MUZZLEFLASH = 2,
	//swirling cloud of particles;
	EF_BRIGHTFIELD = 1 
}
//entvars_t::takedamage values;
enum DAMAGE {
	//allow auto-aim;
	DAMAGE_AIM = 2,
	//Allow damage;
	DAMAGE_YES = 1,
	//Don\'t allow damage;
	DAMAGE_NO = 0 
}
//Entity entvars_t::deadflag values;
enum DEAD {
	//No direct use of this;
	DEAD_DISCARDBODY = 4,
	//The player is in a state where they can be respawned.;
	DEAD_RESPAWNABLE = 3,
	//dead. lying still.;
	DEAD_DEAD = 2,
	//playing death animation or still falling off of a ledge waiting to hit ground;
	DEAD_DYING = 1,
	//alive;
	DEAD_NO = 0 
}
//entvars_t::solid constants.\nNOTE: Some movetypes will cause collisions independent of SOLID_NOT/SOLID_TRIGGER when the entity moves\nSOLID only effects OTHER entities colliding with this one when they move - UGH!;
enum SOLID {
	//bsp clip, touch on edge, block;
	SOLID_BSP = 4,
	//touch on edge, but not an onground;
	SOLID_SLIDEBOX = 3,
	//touch on edge, block;
	SOLID_BBOX = 2,
	//touch on edge, but not blocking;
	SOLID_TRIGGER = 1,
	//no interaction with other objects;
	SOLID_NOT = 0,
	//no interaction with other objects (forced by map);
	SOLID_NOT_EXPLICIT = -1 
}
//entvars_t::movetype constants;
enum MOVETYPE {
	//BSP model that needs physics/world collisions (uses nearest hull for world collision);
	MOVETYPE_PUSHSTEP = 13,
	//track movement of aiment;
	MOVETYPE_FOLLOW = 12,
	//bounce w/o gravity;
	MOVETYPE_BOUNCEMISSILE = 11,
	//Just like Toss, but reflect velocity when contacting surfaces;
	MOVETYPE_BOUNCE = 10,
	//extra size to monsters;
	MOVETYPE_FLYMISSILE = 9,
	//No gravity, no collisions, still do velocity/avelocity;
	MOVETYPE_NOCLIP = 8,
	//no clip to world, push and crush;
	MOVETYPE_PUSH = 7,
	//gravity/collisions;
	MOVETYPE_TOSS = 6,
	//No gravity, but still collides with stuff;
	MOVETYPE_FLY = 5,
	//gravity, special edge handling -- monsters use this;
	MOVETYPE_STEP = 4,
	//Player only - moving on the ground;
	MOVETYPE_WALK = 3,
	//never moves;
	MOVETYPE_NONE = 0,
	//never moves (forced by map);
	MOVETYPE_NONE_EXPLICIT = -1 
}
//entvars_t::flags constants;
enum EdictFlags {
	//Entity is dormant, no updates to client;
	FL_DORMANT = 2147483648,
	//This entity is marked for death -- This allows the engine to kill ents at the appropriate time;
	FL_KILLME = 1073741824,
	//This is a custom entity;
	FL_CUSTOMENTITY = 536870912,
	//This client is being denied weapon usage;
	FL_NOWEAPONS = 134217728,
	//This client is a spectator, don\'t run touch functions, etc.;
	FL_SPECTATOR = 67108864,
	//Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something);
	FL_WORLDBRUSH = 33554432,
	//Player is _controlling_ a train, so movement commands should be ignored on client during prediction.;
	FL_ONTRAIN = 16777216,
	//Only collide in with monsters who have FL_MONSTERCLIP set;
	FL_MONSTERCLIP = 8388608,
	//Base velocity has been applied this frame (used to convert base velocity into momentum);
	FL_BASEVELOCITY = 4194304,
	//Brush model flag -- call think every frame regardless of nextthink - ltime (for constantly changing velocity/path);
	FL_ALWAYSTHINK = 2097152,
	//This is a spectator proxy;
	FL_PROXY = 1048576,
	//If set, players don\'t take damage from lava;
	FL_IMMUNE_LAVA = 524288,
	//If set, players don\'t take damage from slime;
	FL_IMMUNE_SLIME = 262144,
	//If set, players don\'t take drown damage;
	FL_IMMUNE_WATER = 131072,
	//worldgraph has this ent listed as something that blocks a connection;
	FL_GRAPHED = 65536,
	//Apply floating force to this entity when in water;
	FL_FLOAT = 32768,
	//Player flag -- Player is fully crouched;
	FL_DUCKING = 16384,
	//JAC: fake client, simulated server side; don\'t send network messages to them;
	FL_FAKECLIENT = 8192,
	//Player is frozen for 3rd person camera;
	FL_FROZEN = 4096,
	//player jumping out of water;
	FL_WATERJUMP = 2048,
	//not all corners are valid;
	FL_PARTIALGROUND = 1024,
	//At rest / on the ground;
	FL_ONGROUND = 512,
	//Don\'t send entity to local host, it\'s predicting this entity itself;
	FL_SKIPLOCALHOST = 256,
	//If set, this entity will not be targeted by monster AI;
	FL_NOTARGET = 128,
	//If set, this entity is invincible. Only applies to players;
	FL_GODMODE = 64,
	//If set, this is a monster;
	FL_MONSTER = 32,
	//If set, this entity is in water. Only applies to players;
	FL_INWATER = 16,
	//If set, this is a player;
	FL_CLIENT = 8,
	//If set, entities standing on this entity are moved as if this were a conveyor;
	FL_CONVEYOR = 4,
	//Changes the SV_Movestep() behavior to not need to be on ground (but stay in water);
	FL_SWIM = 2,
	//Changes the SV_Movestep() behavior to not need to be on ground;
	FL_FLY = 1 
}
namespace SeekFile {
//Mode flags passed to File::Seek.;
enum SeekFile {
	//Seek from the end of the file.;
	END = 2,
	//Seek from the current offset in the file.;
	CUR = 1,
	//Seek from the start of the file.;
	SET = 0 
}
}
namespace OpenFile {
//Flags passed to FileSystem::OpenFile.;
enum OpenFile {
	//Open in binary mode.;
	BINARY = 8,
	//Open file for appending.;
	APPEND = 4,
	//Open file for writing.;
	WRITE = 2,
	//Open file for reading.;
	READ = 1 
}
}
namespace Regex {
//Match format flags. These can be bitwise OR\'d together to combine options.;
enum MatchFlagType {
	//;
	format_first_only = 4096,
	//;
	format_no_copy = 2048,
	//;
	format_sed = 1024,
	//;
	format_default = 0,
	//;
	match_prev_avail = 256,
	//;
	match_continuous = 64,
	//;
	match_not_null = 32,
	//;
	match_any = 16,
	//;
	match_not_eow = 8,
	//;
	match_not_bow = 4,
	//;
	match_not_eol = 2,
	//;
	match_not_bol = 1,
	//;
	match_default = 0 
}
}
namespace Regex {
//Regular expression flags. These can be bitwise OR\'d together to combine options.;
enum FlagType {
	//;
	egrep = 32,
	//;
	grep = 16,
	//;
	awk = 8,
	//;
	extended = 4,
	//;
	basic = 2,
	//;
	ECMAScript = 1,
	//;
	collate = 2048,
	//;
	optimize = 1024,
	//;
	nosubs = 512,
	//;
	icase = 256 
}
}
namespace Reflection {
//Which type a reflection argument is;
enum ArgumentType {
	//Argument is an enum type.;
	AT_ENUM = 32,
	//Argument is an object type.;
	AT_OBJECT = 24,
	//Argument is a primitive type.;
	AT_PRIMITIVE = 4,
	//Argument is void.;
	AT_VOID = 2,
	//Argument has no type. If an argument has this type it means something went wrong during parsing.;
	AT_NONE = 1 
}
}
namespace String {
//Compare type.;
enum CompareType {
	//;
	CaseInsensitive = 1,
	//;
	CaseSensitive = 0 
}
}
//Gets the current script\'s module.;
CModule@ g_Module;
CModule@ get_g_Module();
//Gets the current script\'s hook manager.;
CModuleHookManager@ g_Hooks;
CModuleHookManager@ get_g_Hooks();
//Gets the current time as a unix timestamp.;
time_t UnixTimestamp();
//Gets the map script\'s persistence manager.;
CPersistence@ g_Persistence;
CPersistence@ get_g_Persistence();
//;
CPathTrack@ PathTrackEntity_Instance(edict_t@ pEdict);
//Gets the current global sound manager entity;
CSoundEnt@ GetSoundEntInstance();
//Checks entvars for nullity;
bool FNullEnt(entvars_t@ pev);
//Checks edict for nullity;
bool FNullEnt(const edict_t@ pEnt);
//;
int TrainSpeed(int iSpeed, int iMax);
//Returns the cross product of the given vectors;
Vector CrossProduct(const Vector& in, const Vector& in);
//Returns the dot product of the given vectors;
float DotProduct(const Vector& in lhs, const Vector& in rhs);
//Returns a dot product of the given vectors;
float DotProduct(const Vector2D& in lhs, const Vector2D& in rhs);
//Gets the current script\'s scheduler.;
CScheduler@ get_g_Scheduler();
//Formats the open flags into a string that represents the flags.;
namespace FileSystem { bool FormatOpenFlags(OpenFileFlags_t uiOpenFlags, string& out szOutFlags); }
//Filters the given flags, removing unnecessary flags.;
namespace FileSystem { OpenFileFlags_t FilterFlags(OpenFileFlags_t uiOpenFlags); }
//Returns whether the given open flags are valid.;
namespace FileSystem { bool FlagsValid(const OpenFileFlags_t uiOpenFlags); }
//Makes a copy of the target sequence (the subject) with all matches of the regular expression pRegex (the pattern) replaced by szFormat (the replacement).;
namespace Regex { string Replace(const string& in szString, const Regex@ pRegex, const string& in szFormat, MatchFlagType flags = MatchFlagType::match_default); }
//Returns whether some sub-sequence in the target sequence (the subject) matches the regular expression pRegex.\npResults will contain the results of the operation, if any.;
namespace Regex { bool Search(const string& in szString, MatchResults@ pResults, const Regex@ pRegex, MatchFlagType flags = MatchFlagType::match_default); }
//Returns whether some sub-sequence in the target sequence (the subject) matches the regular expression pRegex.;
namespace Regex { bool Search(const string& in szString, const Regex@ pRegex, MatchFlagType flags = MatchFlagType::match_default); }
//Performs are regular expression matching operation.\nReturns true if the match succeeded, false otherwise.\npResults will contain the results of the operation, if any.;
namespace Regex { bool Match(const string& in szString, MatchResults@ pResults, const Regex@ pRegex, MatchFlagType flags = MatchFlagType::match_default); }
//Performs are regular expression matching operation.\nReturns true if the match succeeded, false otherwise;
namespace Regex { bool Match(const string& in szString, const Regex@ pRegex, MatchFlagType flags = MatchFlagType::match_default); }
//Prints the format string to the destination buffer. Uses SC printf formatting style.;
bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
//Prints the format string to the destination buffer. Uses SC printf formatting style.;
bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
//Prints the format string to the destination buffer. Uses SC printf formatting style.;
bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in);
//Prints the format string to the destination buffer. Uses SC printf formatting style.;
bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in);
//Prints the format string to the destination buffer. Uses SC printf formatting style.;
bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in);
//Prints the format string to the destination buffer. Uses SC printf formatting style.;
bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in);
//Prints the format string to the destination buffer. Uses SC printf formatting style.;
bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in);
//Prints the format string to the destination buffer. Uses SC printf formatting style.;
bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in);
//Prints the format string to the destination buffer. Uses SC printf formatting style.;
bool snprintf(string& out szOutBuffer, const string& in szFormat);
//Formats a double into a string.\nThe options string is a combination of the following characters:\n\'l\' = left justify\n\'0\' = pad with zeroes\n\'+\' = always include the sign, even if positive\n\' \' = add a space in case of positive number\n\'e\' = exponent character with small e\n\'E\' = exponent character with capital E\n;
string formatFloat(double value, const string &in options = "", uint width = 0, uint precision = 0);
//Formats a unsigned integer into a string.\nThe options string is a combination of the following characters:\n\'l\' = left justify\n\'0\' = pad with zeroes\n\'+\' = always include the sign, even if positive\n\' \' = add a space in case of positive number\n\'h\' = hexadecimal integer small letters\n\'H\' = hexadecimal integer capital letters\n;
string formatUInt(uint64 value, const string &in options = "", uint width = 0);
//Formats a signed integer into a string.\nThe options string is a combination of the following characters:\n\'l\' = left justify\n\'0\' = pad with zeroes\n\'+\' = always include the sign, even if positive\n\' \' = add a space in case of positive number\n\'h\' = hexadecimal integer small letters\n\'H\' = hexadecimal integer capital letters\n;
string formatInt(int64 value, const string &in options = "", uint width = 0);
//Converts the given character to upper case.;
string toupper(const string& in);
//Converts the given character to lower case.;
string tolower(const string& in);
//Returns whether character is xdigit.;
bool isxdigit(const string& in);
//Returns whether character is upper.;
bool isupper(const string& in);
//Returns whether character is space.;
bool isspace(const string& in);
//Returns whether character is punctuality.;
bool ispunct(const string& in);
//Returns whether character is print.;
bool isprint(const string& in);
//Returns whether character is lower.;
bool islower(const string& in);
//Returns whether character is graph.;
bool isgraph(const string& in);
//Returns whether character is digit.;
bool isdigit(const string& in);
//Returns whether character is control.;
bool iscntrl(const string& in);
//Returns whether character is alphabetic.;
bool isalpha(const string& in);
//Returns whether character is alphanumeric.;
bool isalnum(const string& in);
//Converts the given string to a boolean. fIsValid is true if the given string was a valid boolean value.;
bool atobool(const string& in, bool& out fIsValid);
//Converts the given string to a boolean.;
bool atobool(const string& in);
//Converts the given string to a 64 bit unsigned integer.;
uint64 atoui64(const string& in, int radix = 10);
//Converts the given string to an unsigned integer.;
uint atoui(const string& in, int radix = 10);
//Converts the given string to a 64 bit integer.;
int64 atoi64(const string& in, int radix = 10);
//Converts the given string to an integer.;
int atoi(const string& in, int radix = 10);
//Converts the given string to a double.;
double atod(const string& in);
//Converts the given string to a float.;
float atof(const string& in);
//Converts the given character to upper case.;
char toupper(char character);
//Converts the given character to lower case.;
char tolower(char character);
//Returns whether character is a hexadecimal numeric character.;
bool isxdigit(char character);
//Returns whether character is upper.;
bool isupper(char character);
//Returns whether character is space.;
bool isspace(char character);
//Returns whether character is punctuality.;
bool ispunct(char character);
//Returns whether character is print.;
bool isprint(char character);
//Returns whether character is lower.;
bool islower(char character);
//Returns whether character is graph.;
bool isgraph(char character);
//Returns whether character is a decimal digit character.;
bool isdigit(char character);
//Returns whether character is control.;
bool iscntrl(char character);
//Returns whether character is alphabetic.;
bool isalpha(char character);
//Returns whether character is alphanumeric.;
bool isalnum(char character);
//Called when the map changes. This happens when the world is destroyed. There may still be entities that exist at this point.;
namespace Hooks::Game { const uint32 MapChange; }
//Called when a new entity is created. At this point the entity is not spawned yet and may not be fully initialized.;
namespace Hooks::Game { const uint32 EntityCreated; }
//Called when a player disconnects. Note that this is only called if the player was fully connected, meaning the player went through ClientPutInServer. This is never called for the local host.;
namespace Hooks::Player { const uint32 ClientDisconnect; }
//Called when a player has finished connecting and is put into the world. It is safe to send network messages to the player at this point.;
namespace Hooks::Player { const uint32 ClientPutInServer; }
//Called when a player says something in game chat. The SayParameters class can be used to manipulate input and veto the message.;
namespace Hooks::Player { const uint32 ClientSay; }
//Called when a player connects to the server, and the number of slots left on the server is <= the number of reserved slots. Set bAllowJoin to true to allow the player to join (default false).;
namespace Hooks::Player { const uint32 CanPlayerUseReservedSlot; }
//Called when a pickup object is about to be collected by a player. Note that basic checks are done before this hook is called.;
namespace Hooks::PickupObject { const uint32 CanCollect; }
//Called when a pickup object materializes.;
namespace Hooks::PickupObject { const uint32 Materialize; }
//Called when a pickup object is collected by a player. ;
namespace Hooks::PickupObject { const uint32 Collected; }
//Called when a player connects to the server. if bDisallowJoin is set to false, the player is disconnected. szRejectReason is shown to the player if disconnected. The maximum length of the reject reason string is 127 characters.;
namespace Hooks::Player { const uint32 ClientConnected; }
//Called when a player (re)spawns.;
namespace Hooks::Player { const uint32 PlayerSpawn; }
//Called when the game wants to know if the player should be able to respawn or not.Set bCanRespawn to false to disallow, default true.;
namespace Hooks::Player { const uint32 PlayerCanRespawn; }
//Called when a player takes damage. Note that the victim entity can\'t be changed at this point.;
namespace Hooks::Player { const uint32 PlayerTakeDamage; }
//Called when a player is killed.;
namespace Hooks::Player { const uint32 PlayerKilled; }
//Called when a player enters observer mode.;
namespace Hooks::Player { const uint32 PlayerEnteredObserver; }
//Called when a player leaves observer mode.;
namespace Hooks::Player { const uint32 PlayerLeftObserver; }
//Called when the game is processing player use input. Note that this occurs even if the player has not pressed their use key.;
namespace Hooks::Player { const uint32 PlayerUse; }
//Called when the player is processing pre think events.;
namespace Hooks::Player { const uint32 PlayerPreThink; }
//Called when the player is processing post think events.;
namespace Hooks::Player { const uint32 PlayerPostThink; }
//Called when a player is about to get a spawn point before (re)spawning.;
namespace Hooks::Player { const uint32 GetPlayerSpawnSpot; }
//Called when a player is spraypainting a decal onto a surface. The given trace result contains the surface information. ;
namespace Hooks::Player { const uint32 PlayerDecal; }
//Called when a player attempts to spraypaint a decal onto a surface. The given trace result contains the surface information. Set bResult to false if the player shouldn\'t be able to spray. ;
namespace Hooks::Player { const uint32 PlayerPreDecal; }
//Called when a player fires a weapon\'s primary attack.;
namespace Hooks::Weapon { const uint32 WeaponPrimaryAttack; }
//Called when a player fires a weapon\'s secondary attack.;
namespace Hooks::Weapon { const uint32 WeaponSecondaryAttack; }
//Called when a player fires a weapon\'s tertiary attack.;
namespace Hooks::Weapon { const uint32 WeaponTertiaryAttack; }
//Survival Mode global instance.;
CSurvivalMode g_SurvivalMode;
//Classic Mode global instance.;
CClassicMode g_ClassicMode;
//CConCommandSystem global instance;
CConCommandSystem g_ConCommandSystem;
//Log global instance;
CLog g_Log;
//CAdminControl instance for plugins;
CAdminControl g_AdminControl;
//Text menu manager global instance;
CTextMenus g_TextMenus;
//Player start inventory manager instance;
CStartInventory g_StartInventory;
//Plugin manager global instance.;
CPluginManager g_PluginManager;
//Map state variables instance;
CMap g_Map;
//Map cycle manager instance;
CMapCycle g_MapCycle;
//Angelscript debugging functions instance;
CAngelscript g_Angelscript;
//Global state manager instance;
CGlobalState g_GlobalState;
//Weapon functions global instance.;
CWeaponFuncs g_WeaponFuncs;
//Global player functions instance;
CPlayerFuncs g_PlayerFuncs;
//Sven Co-op HUD color;
const RGBA RGBA_SVENCOOP;
//Orange;
const RGBA RGBA_ORANGE;
//Yellow;
const RGBA RGBA_YELLOW;
//Blue;
const RGBA RGBA_BLUE;
//Green;
const RGBA RGBA_GREEN;
//Red;
const RGBA RGBA_RED;
//Black;
const RGBA RGBA_BLACK;
//White;
const RGBA RGBA_WHITE;
//Global entity functions instance;
CEntityFuncs g_EntityFuncs;
//Goes into g_Engine.trace_flags\nTraceline with a simple box;
const uint FTRACE_SIMPLEBOX;
//Engine global variables instance;
CEngine g_Engine;
//Sound engine instance;
CSoundEngine g_SoundSystem;
//Volume value normal;
const float VOL_NORM;
//;
const float ATTN_STATIC;
//;
const float ATTN_IDLE;
//;
const float ATTN_NORM;
//;
const float ATTN_NONE;
//Game functions instance;
CGame g_Game;
//Utility methods instance;
CUtility g_Utility;
//Custom entity functions global instance.;
CCustomEntityFuncs g_CustomEntityFuncs;
//Entity loader global instance;
CEntityLoader g_EntityLoader;
//Item registry global instance.;
CItemRegistry g_ItemRegistry;
//Used for clips that don\'t use ammo.;
const int WEAPON_NOCLIP;
//;
const Vector VECTOR_CONE_20DEGREES;
//;
const Vector VECTOR_CONE_15DEGREES;
//;
const Vector VECTOR_CONE_10DEGREES;
//;
const Vector VECTOR_CONE_9DEGREES;
//;
const Vector VECTOR_CONE_8DEGREES;
//;
const Vector VECTOR_CONE_7DEGREES;
//;
const Vector VECTOR_CONE_6DEGREES;
//;
const Vector VECTOR_CONE_5DEGREES;
//;
const Vector VECTOR_CONE_4DEGREES;
//;
const Vector VECTOR_CONE_3DEGREES;
//;
const Vector VECTOR_CONE_2DEGREES;
//;
const Vector VECTOR_CONE_1DEGREES;
//Parameter for CSoundEnt::InsertSound iVolume;
const int WEAPON_ACTIVITY_VOLUME;
//Parameter for CSoundEnt::InsertSound iVolume;
const int SMALL_EXPLOSION_VOLUME;
//Parameter for CSoundEnt::InsertSound iVolume;
const int NORMAL_EXPLOSION_VOLUME;
//Parameter for CSoundEnt::InsertSound iVolume;
const int BIG_EXPLOSION_VOLUME;
//Value used in CBasePlayer::m_iWeaponFlash;
const int DIM_GUN_FLASH;
//Value used in CBasePlayer::m_iWeaponFlash;
const int NORMAL_GUN_FLASH;
//Value used in CBasePlayer::m_iWeaponFlash;
const int BRIGHT_GUN_FLASH;
//Parameter for CSoundEnt::InsertSound iVolume;
const int QUIET_GUN_VOLUME;
//Parameter for CSoundEnt::InsertSound iVolume;
const int NORMAL_GUN_VOLUME;
//Parameter for CSoundEnt::InsertSound iVolume;
const int LOUD_GUN_VOLUME;
//Inventory misc functions instance;
CInventoryMisc g_InventoryMisc;
//With this set as a sound\'s ExpireTime, the sound will never expire.\nSee CSoundEnt.;
const int SOUND_NEVER_EXPIRE;
//Identifiers passed to functions that can operate on either list, to indicate which list to operate on.\nSee CSoundEnt.;
const int SOUNDLISTTYPE_ACTIVE;
//Identifiers passed to functions that can operate on either list, to indicate which list to operate on.\nSee CSoundEnt.;
const int SOUNDLISTTYPE_FREE;
//Indicates that the sound list is empty.\nSee CSoundEnt.;
const int SOUNDLIST_EMPTY;
//maximum number of sounds handled by the world at one time.\nSee CSoundEnt.;
const size_t MAX_WORLD_SOUNDS;
//Model functions instance;
CModelFuncs g_ModelFuncs;
//Engine functions instance;
CEngineFuncs g_EngineFuncs;
//Time between player vocal client commands;
const float PLAYERCOMMAND_WAIT;
//Autoaim;
const float AUTOAIM_10DEGREES;
//Autoaim;
const float AUTOAIM_8DEGREES;
//Autoaim;
const float AUTOAIM_5DEGREES;
//Autoaim;
const float AUTOAIM_2DEGREES;
//HUD item selection slots;
const size_t MAX_ITEM_TYPES;
//Maximum number of ammo types;
const size_t MAX_AMMO_TYPES;
//Hull view offset while ducking.;
const Vector VEC_DUCK_VIEW;
//Hull maximum while ducking. Used with CEntityFuncs::SetSize;
const Vector VEC_DUCK_HULL_MAX;
//Hull minimum while ducking. Used with CEntityFuncs::SetSize;
const Vector VEC_DUCK_HULL_MIN;
//View offset.;
const Vector VEC_VIEW;
//Default human hull maximum while ducking. Used with CEntityFuncs::SetSize;
const Vector VEC_HUMAN_HULL_DUCK;
//Default human hull maximum while standing. Used with CEntityFuncs::SetSize;
const Vector VEC_HUMAN_HULL_MAX;
//Default human hull maximum. Used with CEntityFuncs::SetSize;
const Vector VEC_HUMAN_HULL_MIN;
//Default hull maximum. Used with CEntityFuncs::SetSize;
const Vector VEC_HULL_MAX;
//Default hull minimum. Used with CEntityFuncs::SetSize;
const Vector VEC_HULL_MIN;
//How many waypoints a monster can store at one time;
const size_t ROUTE_SIZE;
//How many old enemies to remember;
const size_t MAX_OLD_ENEMIES;
//;
namespace Schedules { Schedule slFail; }
//;
namespace Schedules { Schedule slTakeCoverFromBestSound; }
//;
namespace Schedules { Schedule slWaitScript; }
//;
namespace Schedules { Schedule slRunToScript; }
//;
namespace Schedules { Schedule slWalkToScript; }
//;
namespace Schedules { Schedule slError; }
//;
namespace Schedules { Schedule slDie; }
//;
namespace Schedules { Schedule slSmallFlinch; }
//;
namespace Schedules { Schedule slChaseEnemy; }
//;
namespace Schedules { Schedule slRangeAttack2; }
//;
namespace Schedules { Schedule slRangeAttack1; }
//;
namespace Schedules { Schedule slReload; }
//;
namespace Schedules { Schedule slCombatFace; }
//;
namespace Schedules { Schedule slCombatStand; }
//;
namespace Schedules { Schedule slAlertStand; }
//;
namespace Schedules { Schedule slAlertFace; }
//;
namespace Schedules { Schedule slWakeAngry; }
//;
namespace Schedules { Schedule slIdleWalk; }
//;
namespace Schedules { Schedule slIdleTrigger; }
//;
namespace Schedules { Schedule slIdleStand; }
//Activity map instance;
CActivityMap g_ActivityMap;
//Dynamic decal manager instance;
CDecals g_Decals;
//Ultra narrow view field;
const float VIEW_FIELD_ULTRA_NARROW;
//Narrow view field;
const float VIEW_FIELD_NARROW;
//Wide view field;
const float VIEW_FIELD_WIDE;
//Full view field;
const float VIEW_FIELD_FULL;
//Math functions instance;
CMath Math;
//Zero vector (0, 0, 0);
const Vector g_vecZero;
//Debugger instance.;
 CDebugger g_Debugger;
//Global file system instance;
CVirtualFileSystem g_FileSystem;
//Reflection global class instance.;
namespace Reflection { CReflection g_Reflection; }
//Sentinel value used by string tokenization when there are no tokens remaining.;
namespace String { const size_t NO_MORE_TOKENS; }
//Sentinel value used by string methods.;
namespace String { const size_t INVALID_INDEX; }
//A string that contains one instance of every whitespace character.;
namespace String { const string WHITESPACE_CHARACTERS; }
//Empty string. Useful when a reference to a string is needed.;
namespace String { const string EMPTY_STRING; }
//Default comparison type.;
namespace String { const CompareType DEFAULT_COMPARE; }
//Distance from the world origin to the world boundary in a single axis;
const float WORLD_BOUNDARY;
//Called when the map changes. This happens when the world is destroyed. There may still be entities that exist at this point.;
funcdef HookReturnCode MapChangeHook();
//Called when a new entity is created. At this point the entity is not spawned yet and may not be fully initialized.;
funcdef HookReturnCode EntityCreatedHook(CBaseEntity@);
//Called when a player disconnects. Note that this is only called if the player was fully connected, meaning the player went through ClientPutInServer. This is never called for the local host.;
funcdef HookReturnCode ClientDisconnectHook(CBasePlayer@);
//Called when a player has finished connecting and is put into the world. It is safe to send network messages to the player at this point.;
funcdef HookReturnCode ClientPutInServerHook(CBasePlayer@);
//Called when a player says something in game chat. The SayParameters class can be used to manipulate input and veto the message.;
funcdef HookReturnCode ClientSayHook(SayParameters@);
//Called when a player connects to the server, and the number of slots left on the server is <= the number of reserved slots. Set bAllowJoin to true to allow the player to join (default false).;
funcdef HookReturnCode CanPlayerUseReservedSlotHook(edict_t@, const string& in, const string& in, bool& out);
//Called when a pickup object is about to be collected by a player. Note that basic checks are done before this hook is called.;
funcdef HookReturnCode CanCollectHook(CBaseEntity@, CBaseEntity@, bool& out);
//Called when a pickup object materializes.;
funcdef HookReturnCode MaterializeHook(CBaseEntity@);
//Called when a pickup object is collected by a player. ;
funcdef HookReturnCode CollectedHook(CBaseEntity@, CBaseEntity@);
//Called when a player connects to the server. if bDisallowJoin is set to false, the player is disconnected. szRejectReason is shown to the player if disconnected. The maximum length of the reject reason string is 127 characters.;
funcdef HookReturnCode ClientConnectedHook(edict_t@, const string& in, const string& in, bool& out, string& out);
//Called when a player (re)spawns.;
funcdef HookReturnCode PlayerSpawnHook(CBasePlayer@);
//Called when the game wants to know if the player should be able to respawn or not.Set bCanRespawn to false to disallow, default true.;
funcdef HookReturnCode PlayerCanRespawnHook(CBasePlayer@, bool& out);
//Called when a player takes damage. Note that the victim entity can\'t be changed at this point.;
funcdef HookReturnCode PlayerTakeDamageHook(DamageInfo@);
//Called when a player is killed.;
funcdef HookReturnCode PlayerKilledHook(CBasePlayer@, CBaseEntity@, int);
//Called when a player enters observer mode.;
funcdef HookReturnCode PlayerEnteredObserverHook(CBasePlayer@);
//Called when a player leaves observer mode.;
funcdef HookReturnCode PlayerLeftObserverHook(CBasePlayer@);
//Called when the game is processing player use input. Note that this occurs even if the player has not pressed their use key.;
funcdef HookReturnCode PlayerUseHook(CBasePlayer@, uint& out);
//Called when the player is processing pre think events.;
funcdef HookReturnCode PlayerPreThinkHook(CBasePlayer@, uint& out);
//Called when the player is processing post think events.;
funcdef HookReturnCode PlayerPostThinkHook(CBasePlayer@);
//Called when a player is about to get a spawn point before (re)spawning.;
funcdef HookReturnCode GetPlayerSpawnSpotHook(CBasePlayer@ pPlayer, CBaseEntity@& out ppEntSpawnSpot);
//Called when a player is spraypainting a decal onto a surface. The given trace result contains the surface information. ;
funcdef HookReturnCode PlayerDecalHook(CBasePlayer@, const TraceResult& in);
//Called when a player attempts to spraypaint a decal onto a surface. The given trace result contains the surface information. Set bResult to false if the player shouldn\'t be able to spray. ;
funcdef HookReturnCode PlayerPreDecalHook(CBasePlayer@, const TraceResult& in, bool& out bResult);
//Called when a player fires a weapon\'s primary attack.;
funcdef HookReturnCode WeaponPrimaryAttackHook(CBasePlayer@, CBasePlayerWeapon@);
//Called when a player fires a weapon\'s secondary attack.;
funcdef HookReturnCode WeaponSecondaryAttackHook(CBasePlayer@, CBasePlayerWeapon@);
//Called when a player fires a weapon\'s tertiary attack.;
funcdef HookReturnCode WeaponTertiaryAttackHook(CBasePlayer@, CBasePlayerWeapon@);
//Callback for cvars.;
funcdef void CVarCallback(CCVar@ cvar, const string& in szOldValue, float flOldValue);
//Callback for client console commands.;
funcdef void ClientCommandCallback(const CCommand@ args);
//Callback for server console commands.;
funcdef void ConCommandCallback(const CCommand@ args);
//Funcdef for vote ended callbacks. If fResult is true, users voted for yes. Otherwise, voted for no.;
funcdef void VoteEnd(Vote@ pVote, bool fResult, int iVoters);
//Funcdef for vote blocked callbacks. The given time is when the active vote has ended.;
funcdef void VoteBlocked(Vote@ pVote, float flTime);
//Player slot callback for text menus.;
funcdef void TextMenuPlayerSlotCallback(CTextMenu@ menu, CBasePlayer@ pPlayer, int iSlot, const CTextMenuItem@ pItem);
//Function definition for custom entity Blocked functions;
funcdef void BlockedFunction(CBaseEntity@ pOther);
//Function definition for custom entity Touch functions;
funcdef void TouchFunction(CBaseEntity@ pOther);
//Function definition for custom entity Use functions;
funcdef void UseFunction(CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue);
//Function definition for custom entity Think functions;
funcdef void ThinkFunction();